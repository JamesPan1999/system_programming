<!DOCTYPE html>
<html data-theme="light" lang="zh-CN"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Linux系统编程学习笔记 | 来生拓己 オフィシャルサイト</title><meta name="keywords" content="Linux,Linux系统编程"><meta name="author" content="Kisugi Takumi,zenghongyi1@google.com"><meta name="copyright" content="Kisugi Takumi"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Linux系统编程学习笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux系统编程学习笔记">
<meta property="og:url" content="https://kisugitakumi.net/2022/11/20/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="来生拓己 オフィシャルサイト">
<meta property="og:description" content="Linux系统编程学习笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://kisugitakumi.net/img/linux.png">
<meta property="article:published_time" content="2022-11-20T06:46:25.000Z">
<meta property="article:modified_time" content="2023-03-16T08:36:54.271Z">
<meta property="article:author" content="Kisugi Takumi">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="Linux系统编程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://kisugitakumi.net/img/linux.png"><link rel="shortcut icon" href="Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20%E6%9D%A5%E7%94%9F%E6%8B%93%E5%B7%B1%20%E3%82%AA%E3%83%95%E3%82%A3%E3%82%B7%E3%83%A3%E3%83%AB%E3%82%B5%E3%82%A4%E3%83%88_files/favicon.png"><link rel="canonical" href="https://kisugitakumi.net/2022/11/20/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><link rel="preconnect" href="https://cdn.jsdelivr.net/"><link rel="preconnect" href="https://busuanzi.ibruce.info/"><link rel="stylesheet" href="Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20%E6%9D%A5%E7%94%9F%E6%8B%93%E5%B7%B1%20%E3%82%AA%E3%83%95%E3%82%A3%E3%82%B7%E3%83%A3%E3%83%AB%E3%82%B5%E3%82%A4%E3%83%88_files/index.css"><link rel="stylesheet" href="Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20%E6%9D%A5%E7%94%9F%E6%8B%93%E5%B7%B1%20%E3%82%AA%E3%83%95%E3%82%A3%E3%82%B7%E3%83%A3%E3%83%AB%E3%82%B5%E3%82%A4%E3%83%88_files/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20%E6%9D%A5%E7%94%9F%E6%8B%93%E5%B7%B1%20%E3%82%AA%E3%83%95%E3%82%A3%E3%82%B7%E3%83%A3%E3%83%AB%E3%82%B5%E3%82%A4%E3%83%88_files/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20%E6%9D%A5%E7%94%9F%E6%8B%93%E5%B7%B1%20%E3%82%AA%E3%83%95%E3%82%A3%E3%82%B7%E3%83%A3%E3%83%AB%E3%82%B5%E3%82%A4%E3%83%88_files/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Kisugi Takumi","link":"链接: ","source":"来源: 来生拓己 オフィシャルサイト","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Linux系统编程学习笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-03-16 16:36:54'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.0.0"><script src="Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20%E6%9D%A5%E7%94%9F%E6%8B%93%E5%B7%B1%20%E3%82%AA%E3%83%95%E3%82%A3%E3%82%B7%E3%83%A3%E3%83%AB%E3%82%B5%E3%82%A4%E3%83%88_files/tex-mml-chtml.js" id="MathJax-script" async=""></script><style type="text/css">.CtxtMenu_InfoClose {  top:.2em; right:.2em;}
.CtxtMenu_InfoContent {  overflow:auto; text-align:left; font-size:80%;  padding:.4em .6em; border:1px inset; margin:1em 0px;  max-height:20em; max-width:30em; background-color:#EEEEEE;  white-space:normal;}
.CtxtMenu_Info.CtxtMenu_MousePost {outline:none;}
.CtxtMenu_Info {  position:fixed; left:50%; width:auto; text-align:center;  border:3px outset; padding:1em 2em; background-color:#DDDDDD;  color:black;  cursor:default; font-family:message-box; font-size:120%;  font-style:normal; text-indent:0; text-transform:none;  line-height:normal; letter-spacing:normal; word-spacing:normal;  word-wrap:normal; white-space:nowrap; float:none; z-index:201;  border-radius: 15px;                     /* Opera 10.5 and IE9 */  -webkit-border-radius:15px;               /* Safari and Chrome */  -moz-border-radius:15px;                  /* Firefox */  -khtml-border-radius:15px;                /* Konqueror */  box-shadow:0px 10px 20px #808080;         /* Opera 10.5 and IE9 */  -webkit-box-shadow:0px 10px 20px #808080; /* Safari 3 & Chrome */  -moz-box-shadow:0px 10px 20px #808080;    /* Forefox 3.5 */  -khtml-box-shadow:0px 10px 20px #808080;  /* Konqueror */  filter:progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color="gray", Positive="true"); /* IE */}
</style><style type="text/css">.CtxtMenu_MenuClose {  position:absolute;  cursor:pointer;  display:inline-block;  border:2px solid #AAA;  border-radius:18px;  -webkit-border-radius: 18px;             /* Safari and Chrome */  -moz-border-radius: 18px;                /* Firefox */  -khtml-border-radius: 18px;              /* Konqueror */  font-family: "Courier New", Courier;  font-size:24px;  color:#F0F0F0}
.CtxtMenu_MenuClose span {  display:block; background-color:#AAA; border:1.5px solid;  border-radius:18px;  -webkit-border-radius: 18px;             /* Safari and Chrome */  -moz-border-radius: 18px;                /* Firefox */  -khtml-border-radius: 18px;              /* Konqueror */  line-height:0;  padding:8px 0 6px     /* may need to be browser-specific */}
.CtxtMenu_MenuClose:hover {  color:white!important;  border:2px solid #CCC!important}
.CtxtMenu_MenuClose:hover span {  background-color:#CCC!important}
.CtxtMenu_MenuClose:hover:focus {  outline:none}
</style><style type="text/css">.CtxtMenu_Menu {  position:absolute;  background-color:white;  color:black;  width:auto; padding:5px 0px;  border:1px solid #CCCCCC; margin:0; cursor:default;  font: menu; text-align:left; text-indent:0; text-transform:none;  line-height:normal; letter-spacing:normal; word-spacing:normal;  word-wrap:normal; white-space:nowrap; float:none; z-index:201;  border-radius: 5px;                     /* Opera 10.5 and IE9 */  -webkit-border-radius: 5px;             /* Safari and Chrome */  -moz-border-radius: 5px;                /* Firefox */  -khtml-border-radius: 5px;              /* Konqueror */  box-shadow:0px 10px 20px #808080;         /* Opera 10.5 and IE9 */  -webkit-box-shadow:0px 10px 20px #808080; /* Safari 3 & Chrome */  -moz-box-shadow:0px 10px 20px #808080;    /* Forefox 3.5 */  -khtml-box-shadow:0px 10px 20px #808080;  /* Konqueror */}
.CtxtMenu_MenuItem {  padding: 1px 2em;  background:transparent;}
.CtxtMenu_MenuArrow {  position:absolute; right:.5em; padding-top:.25em; color:#666666;  font-family: null; font-size: .75em}
.CtxtMenu_MenuActive .CtxtMenu_MenuArrow {color:white}
.CtxtMenu_MenuArrow.CtxtMenu_RTL {left:.5em; right:auto}
.CtxtMenu_MenuCheck {  position:absolute; left:.7em;  font-family: null}
.CtxtMenu_MenuCheck.CtxtMenu_RTL { right:.7em; left:auto }
.CtxtMenu_MenuRadioCheck {  position:absolute; left: .7em;}
.CtxtMenu_MenuRadioCheck.CtxtMenu_RTL {  right: .7em; left:auto}
.CtxtMenu_MenuInputBox {  padding-left: 1em; right:.5em; color:#666666;  font-family: null;}
.CtxtMenu_MenuInputBox.CtxtMenu_RTL {  left: .1em;}
.CtxtMenu_MenuComboBox {  left:.1em; padding-bottom:.5em;}
.CtxtMenu_MenuSlider {  left: .1em;}
.CtxtMenu_SliderValue {  position:absolute; right:.1em; padding-top:.25em; color:#333333;  font-size: .75em}
.CtxtMenu_SliderBar {  outline: none; background: #d3d3d3}
.CtxtMenu_MenuLabel {  padding: 1px 2em 3px 1.33em;  font-style:italic}
.CtxtMenu_MenuRule {  border-top: 1px solid #DDDDDD;  margin: 4px 3px;}
.CtxtMenu_MenuDisabled {  color:GrayText}
.CtxtMenu_MenuActive {  background-color: #606872;  color: white;}
.CtxtMenu_MenuDisabled:focus {  background-color: #E8E8E8}
.CtxtMenu_MenuLabel:focus {  background-color: #E8E8E8}
.CtxtMenu_ContextMenu:focus {  outline:none}
.CtxtMenu_ContextMenu .CtxtMenu_MenuItem:focus {  outline:none}
.CtxtMenu_SelectionMenu {  position:relative; float:left;  border-bottom: none; -webkit-box-shadow:none; -webkit-border-radius:0px; }
.CtxtMenu_SelectionItem {  padding-right: 1em;}
.CtxtMenu_Selection {  right: 40%; width:50%; }
.CtxtMenu_SelectionBox {  padding: 0em; max-height:20em; max-width: none;  background-color:#FFFFFF;}
.CtxtMenu_SelectionDivider {  clear: both; border-top: 2px solid #000000;}
.CtxtMenu_Menu .CtxtMenu_MenuClose {  top:-10px; left:-10px}
</style><style id="MJX-CHTML-styles">
mjx-container[jax="CHTML"] {
  line-height: 0;
}

mjx-container [space="1"] {
  margin-left: .111em;
}

mjx-container [space="2"] {
  margin-left: .167em;
}

mjx-container [space="3"] {
  margin-left: .222em;
}

mjx-container [space="4"] {
  margin-left: .278em;
}

mjx-container [space="5"] {
  margin-left: .333em;
}

mjx-container [rspace="1"] {
  margin-right: .111em;
}

mjx-container [rspace="2"] {
  margin-right: .167em;
}

mjx-container [rspace="3"] {
  margin-right: .222em;
}

mjx-container [rspace="4"] {
  margin-right: .278em;
}

mjx-container [rspace="5"] {
  margin-right: .333em;
}

mjx-container [size="s"] {
  font-size: 70.7%;
}

mjx-container [size="ss"] {
  font-size: 50%;
}

mjx-container [size="Tn"] {
  font-size: 60%;
}

mjx-container [size="sm"] {
  font-size: 85%;
}

mjx-container [size="lg"] {
  font-size: 120%;
}

mjx-container [size="Lg"] {
  font-size: 144%;
}

mjx-container [size="LG"] {
  font-size: 173%;
}

mjx-container [size="hg"] {
  font-size: 207%;
}

mjx-container [size="HG"] {
  font-size: 249%;
}

mjx-container [width="full"] {
  width: 100%;
}

mjx-box {
  display: inline-block;
}

mjx-block {
  display: block;
}

mjx-itable {
  display: inline-table;
}

mjx-row {
  display: table-row;
}

mjx-row > * {
  display: table-cell;
}

mjx-mtext {
  display: inline-block;
}

mjx-mstyle {
  display: inline-block;
}

mjx-merror {
  display: inline-block;
  color: red;
  background-color: yellow;
}

mjx-mphantom {
  visibility: hidden;
}

_::-webkit-full-page-media, _:future, :root mjx-container {
  will-change: opacity;
}

mjx-assistive-mml {
  position: absolute !important;
  top: 0px;
  left: 0px;
  clip: rect(1px, 1px, 1px, 1px);
  padding: 1px 0px 0px 0px !important;
  border: 0px !important;
  display: block !important;
  width: auto !important;
  overflow: hidden !important;
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -khtml-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

mjx-assistive-mml[display="block"] {
  width: 100% !important;
}

mjx-c::before {
  display: block;
  width: 0;
}

.MJX-TEX {
  font-family: MJXZERO, MJXTEX;
}

.TEX-B {
  font-family: MJXZERO, MJXTEX-B;
}

.TEX-I {
  font-family: MJXZERO, MJXTEX-I;
}

.TEX-MI {
  font-family: MJXZERO, MJXTEX-MI;
}

.TEX-BI {
  font-family: MJXZERO, MJXTEX-BI;
}

.TEX-S1 {
  font-family: MJXZERO, MJXTEX-S1;
}

.TEX-S2 {
  font-family: MJXZERO, MJXTEX-S2;
}

.TEX-S3 {
  font-family: MJXZERO, MJXTEX-S3;
}

.TEX-S4 {
  font-family: MJXZERO, MJXTEX-S4;
}

.TEX-A {
  font-family: MJXZERO, MJXTEX-A;
}

.TEX-C {
  font-family: MJXZERO, MJXTEX-C;
}

.TEX-CB {
  font-family: MJXZERO, MJXTEX-CB;
}

.TEX-FR {
  font-family: MJXZERO, MJXTEX-FR;
}

.TEX-FRB {
  font-family: MJXZERO, MJXTEX-FRB;
}

.TEX-SS {
  font-family: MJXZERO, MJXTEX-SS;
}

.TEX-SSB {
  font-family: MJXZERO, MJXTEX-SSB;
}

.TEX-SSI {
  font-family: MJXZERO, MJXTEX-SSI;
}

.TEX-SC {
  font-family: MJXZERO, MJXTEX-SC;
}

.TEX-T {
  font-family: MJXZERO, MJXTEX-T;
}

.TEX-V {
  font-family: MJXZERO, MJXTEX-V;
}

.TEX-VB {
  font-family: MJXZERO, MJXTEX-VB;
}

mjx-stretchy-v mjx-c, mjx-stretchy-h mjx-c {
  font-family: MJXZERO, MJXTEX-S1, MJXTEX-S4, MJXTEX, MJXTEX-A ! important;
}

@font-face /* 0 */ {
  font-family: MJXZERO;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Zero.woff") format("woff");
}

@font-face /* 1 */ {
  font-family: MJXTEX;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Main-Regular.woff") format("woff");
}

@font-face /* 2 */ {
  font-family: MJXTEX-B;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Main-Bold.woff") format("woff");
}

@font-face /* 3 */ {
  font-family: MJXTEX-I;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Math-Italic.woff") format("woff");
}

@font-face /* 4 */ {
  font-family: MJXTEX-MI;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Main-Italic.woff") format("woff");
}

@font-face /* 5 */ {
  font-family: MJXTEX-BI;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Math-BoldItalic.woff") format("woff");
}

@font-face /* 6 */ {
  font-family: MJXTEX-S1;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Size1-Regular.woff") format("woff");
}

@font-face /* 7 */ {
  font-family: MJXTEX-S2;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Size2-Regular.woff") format("woff");
}

@font-face /* 8 */ {
  font-family: MJXTEX-S3;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Size3-Regular.woff") format("woff");
}

@font-face /* 9 */ {
  font-family: MJXTEX-S4;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Size4-Regular.woff") format("woff");
}

@font-face /* 10 */ {
  font-family: MJXTEX-A;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_AMS-Regular.woff") format("woff");
}

@font-face /* 11 */ {
  font-family: MJXTEX-C;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Calligraphic-Regular.woff") format("woff");
}

@font-face /* 12 */ {
  font-family: MJXTEX-CB;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Calligraphic-Bold.woff") format("woff");
}

@font-face /* 13 */ {
  font-family: MJXTEX-FR;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Fraktur-Regular.woff") format("woff");
}

@font-face /* 14 */ {
  font-family: MJXTEX-FRB;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Fraktur-Bold.woff") format("woff");
}

@font-face /* 15 */ {
  font-family: MJXTEX-SS;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_SansSerif-Regular.woff") format("woff");
}

@font-face /* 16 */ {
  font-family: MJXTEX-SSB;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_SansSerif-Bold.woff") format("woff");
}

@font-face /* 17 */ {
  font-family: MJXTEX-SSI;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_SansSerif-Italic.woff") format("woff");
}

@font-face /* 18 */ {
  font-family: MJXTEX-SC;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Script-Regular.woff") format("woff");
}

@font-face /* 19 */ {
  font-family: MJXTEX-T;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Typewriter-Regular.woff") format("woff");
}

@font-face /* 20 */ {
  font-family: MJXTEX-V;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Vector-Regular.woff") format("woff");
}

@font-face /* 21 */ {
  font-family: MJXTEX-VB;
  src: url("https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Vector-Bold.woff") format("woff");
}
</style></head><body style="overflow: auto;"><div id="loading-box" class="loaded"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20%E6%9D%A5%E7%94%9F%E6%8B%93%E5%B7%B1%20%E3%82%AA%E3%83%95%E3%82%A3%E3%82%B7%E3%83%A3%E3%83%AB%E3%82%B5%E3%82%A4%E3%83%88_files/favicon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="site-data is-center"><div class="data-item"><a href="https://kisugitakumi.net/archives/"><div class="headline">文章</div><div class="length-num">136</div></a></div><div class="data-item"><a href="https://kisugitakumi.net/tags/"><div class="headline">标签</div><div class="length-num">106</div></a></div><div class="data-item"><a href="https://kisugitakumi.net/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="https://kisugitakumi.net/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="https://kisugitakumi.net/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="https://kisugitakumi.net/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="https://kisugitakumi.net/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-brain"></i><span> 我的豆瓣</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="https://kisugitakumi.net/books/"><i class="fa-fw fas fa-book"></i><span> 书籍</span></a></li><li><a class="site-page child" href="https://kisugitakumi.net/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="https://kisugitakumi.net/games/"><i class="fa-fw fab fa-steam-square"></i><span> 游戏</span></a></li><li><a class="site-page child" href="https://kisugitakumi.net/songs/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="https://kisugitakumi.net/create/"><i class="fa-fw fas fa-user-edit"></i><span> 我的创作</span></a></div><div class="menus_item"><a class="site-page" href="https://kisugitakumi.net/about/"><i class="fa-fw fas fa-kiss-wink-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img nav-fixed nav-visible" id="page-header"><nav id="nav" class="show"><span id="blog_name"><a id="site-name" href="https://kisugitakumi.net/">来生拓己 オフィシャルサイト</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="https://kisugitakumi.net/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="https://kisugitakumi.net/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="https://kisugitakumi.net/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="https://kisugitakumi.net/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-brain"></i><span> 我的豆瓣</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="https://kisugitakumi.net/books/"><i class="fa-fw fas fa-book"></i><span> 书籍</span></a></li><li><a class="site-page child" href="https://kisugitakumi.net/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="https://kisugitakumi.net/games/"><i class="fa-fw fab fa-steam-square"></i><span> 游戏</span></a></li><li><a class="site-page child" href="https://kisugitakumi.net/songs/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="https://kisugitakumi.net/create/"><i class="fa-fw fas fa-user-edit"></i><span> 我的创作</span></a></div><div class="menus_item"><a class="site-page" href="https://kisugitakumi.net/about/"><i class="fa-fw fas fa-kiss-wink-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Linux系统编程学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-11-20T06:46:25.000Z" title="发表于 2022-11-20 14:46:25">2022-11-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-16T08:36:54.271Z" title="更新于 2023-03-16 16:36:54">2023-03-16</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="https://kisugitakumi.net/categories/C%E8%AF%AD%E8%A8%80/">C语言</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">91.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>353分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Linux系统编程学习笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv">3565</span></span></div></div></div><article class="post-content" id="article-container"><h1 id="Linux系统编程学习笔记"><a href="#Linux系统编程学习笔记" class="headerlink" title="Linux系统编程学习笔记"></a>Linux系统编程学习笔记</h1><p>学习时间：2022年11月20日</p>
<p>学习来源：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1yJ411S7r6?">Linux系统编程（李慧琴）</a></p>
<p>参考资料：Unix环境高级编程，Linux系统编程</p>
<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><h3 id="1-1-环境"><a href="#1-1-环境" class="headerlink" title="1.1 环境"></a>1.1 环境</h3><p>平台：Centos7.6</p>
<p>工具：vim，gcc，make</p>
<h3 id="1-2-GCC"><a href="#1-2-GCC" class="headerlink" title="1.2 GCC"></a>1.2 GCC</h3><p>Linux系统下的GCC（<code>GNU Compiler Collection</code>）是GNU推出的功能强大、性能优越的多平台编译器，是GNU的代表作品之一。gcc是可以在多种硬体平台上编译出可执行程序的超级编译器，其执行效率与一般的编译器相比平均效率要高20%~30%。</p>
<p>GCC编译器能将C、C++语言源程序、汇程式化序和目标程序编译、链接成可执行文件，如果没有给出可执行文件的名字，gcc将生成一个名为<code>a.out</code>的文件。</p>
<p>GCC编译器编译C源文件为可执行文件的步骤：</p>
<ul>
<li>C源文件—-&gt;预处理<code>.i</code>—-&gt;编译<code>.s</code>（生成汇编文件）—-&gt;汇编<code>.o/.obj</code>（生成目标文件）—-&gt;链接<code>.out</code>（生成可执行文件）—-&gt;可执行文件</li>
</ul>
<blockquote>
<p>gcc命令参数（选项）</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">含义</th>
<th style="text-align:left">示例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>-c</code></td>
<td style="text-align:left">对文件进行预处理、编译和汇编，生成obj文件</td>
<td style="text-align:left"><code>gcc -c hello.c</code></td>
</tr>
<tr>
<td style="text-align:left"><code>-S</code></td>
<td style="text-align:left">只进行预处理和编译，生成汇编代码</td>
<td style="text-align:left"><code>gcc -S hello.c</code></td>
</tr>
<tr>
<td style="text-align:left"><code>-E</code></td>
<td style="text-align:left">只进行预处理，这个选项不生成文件，可以使用重定向或者<code>-o</code>选项使其生成一个文件</td>
<td style="text-align:left"><code>gcc -E hello.c &gt; hello.i</code>或者<code>gcc -E hello.c -o hello.i</code></td>
</tr>
<tr>
<td style="text-align:left"><code>-o</code></td>
<td style="text-align:left">指定目标的名称，默认为a.out</td>
<td style="text-align:left"><code>gcc -o hello hello.c</code></td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>过程演示</p>
</blockquote>
<p>例如源代码<code>main.c</code>：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello World!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>预编译：这个过程处理宏定义和include，去除注释，不会对语法进行检查。可以看到预编译后，源文件的代码从6行扩展了很多行，生成<code>main.i</code></li>
</ul>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E main.c &gt; main.i <span class="comment"># 或者 gcc -E main.c -o main.i</span></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 只展示了一部分</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">ftrylockfile</span> <span class="params">(FILE *__stream)</span> __<span class="title">attribute__</span> <span class="params">((__nothrow__ , __leaf__))</span> </span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">funlockfile</span> <span class="params">(FILE *__stream)</span> __<span class="title">attribute__</span> <span class="params">((__nothrow__ , __leaf__))</span></span>;</span><br><span class="line"># <span class="number">943</span> <span class="string">"/usr/include/stdio.h"</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line"># <span class="number">2</span> <span class="string">"main.c"</span> <span class="number">2</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello World!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>编译：这个阶段，检查语法，生成<strong>汇编</strong>代码<code>main.s</code></li>
</ul>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -S main.c -o main.s</span><br></pre></td></tr></tbody></table></figure>
<p><code>main.s</code>的内容：</p>
<figure class="highlight plaintext"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">plaintext</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">        .file   "main.c"</span><br><span class="line">        .section        .rodata</span><br><span class="line">.LC0:</span><br><span class="line">        .string "Hello World!"</span><br><span class="line">        .text</span><br><span class="line">        .globl  main</span><br><span class="line">        .type   main, @function</span><br><span class="line">main:</span><br><span class="line">.LFB0:</span><br><span class="line">        .cfi_startproc</span><br><span class="line">        pushq   %rbp</span><br><span class="line">        .cfi_def_cfa_offset 16</span><br><span class="line">        .cfi_offset 6, -16</span><br><span class="line">        movq    %rsp, %rbp</span><br><span class="line">        .cfi_def_cfa_register 6</span><br><span class="line">        movl    $.LC0, %edi</span><br><span class="line">        call    puts</span><br><span class="line">        movl    $0, %eax</span><br><span class="line">        popq    %rbp</span><br><span class="line">        .cfi_def_cfa 7, 8</span><br><span class="line">        ret</span><br><span class="line">        .cfi_endproc</span><br><span class="line">.LFE0:</span><br><span class="line">        .size   main, .-main</span><br><span class="line">        .ident  "GCC: (GNU) 4.8.5 20150623 (Red Hat 4.8.5-44)"</span><br><span class="line">        .section        .note.GNU-stack,"",@progbits</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>汇编：这个阶段，生成目标代码<code>main.o</code></li>
</ul>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c main.s -o main.o</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>链接：生成可执行代码<code>main</code>。<ul>
<li>链接分为两种，一种是静态链接，另外一种是动态链接。</li>
<li>使用静态链接的好处是，依赖的动态链接库较少，对动态链接库的版本不会很敏感，具有较好的兼容性；缺点是生成的程序比较大。</li>
<li>使用动态链接的好处是，生成的程序比较小，占用较少的内存。</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.o -o main</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>运行</li>
</ul>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng c]<span class="comment"># ./main</span></span><br><span class="line">Hello World!</span><br></pre></td></tr></tbody></table></figure>
<hr>
<p>一步到位：</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c -o</span><br></pre></td></tr></tbody></table></figure>
<p>此时会默认生成一个名为<code>a.out</code>的可执行文件。</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c -o myHello</span><br></pre></td></tr></tbody></table></figure>
<p>此时会生成一个名为<code>myHello</code>的可执行文件</p>
<h3 id="1-3-make"><a href="#1-3-make" class="headerlink" title="1.3 make"></a>1.3 make</h3><p>make命令是GNU工程化中的一个编译工具。make是依赖于Makefile来编译多个源文件的工具。在Makefile里同样是用gcc（或者别的编译器）来编译程序。</p>
<p>可以使用以下命令直接生成可执行文件：</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make main</span><br></pre></td></tr></tbody></table></figure>
<h3 id="1-4-makefile"><a href="#1-4-makefile" class="headerlink" title="1.4 makefile"></a>1.4 makefile</h3><p>一个工程中的源文件不计其数，其按类型、功能、模块分别放在若干个目录中，<code>makefile</code>定义了一系列的规则来指定哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作。</p>
<p><a href="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221121035110927.png" data-fancybox="gallery" data-caption="image-20221121035110927" data-thumb="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221121035110927.png"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221121035110927.png" alt="image-20221121035110927"></a></p>
<h4 id="1-4-1-使用gcc的例子"><a href="#1-4-1-使用gcc的例子" class="headerlink" title="1.4.1 使用gcc的例子"></a>1.4.1 使用gcc的例子</h4><ul>
<li>创建文件</li>
</ul>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch main.c tool1.c tool1.h tool2.c tool2.h</span><br></pre></td></tr></tbody></table></figure>
<p>可以使用<code>vim * -p</code>打开当前目录下的所有文件。<code>-p</code>是打开多个文件的选项。</p>
<p>在命令模式下，<code>gt</code>切换到下一个标签页，<code>gT</code>切换到上一个标签页。</p>
<p>退出多个标签时，可加上<code>a</code>，例如<code>:qa</code>或者<code>:wqa</code>等</p>
<ul>
<li><code>tool1.h</code>和<code>tool1.c</code></li>
</ul>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __TOOL1_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __TOOL1_H__</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mytool1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"tool1.h"</span> </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mytool1</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"tool1 print...\n"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>tool2.h</code>和<code>tool2.c</code></li>
</ul>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __TOOL2_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __TOOL2_H__</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mytool2</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"tool2.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mytool2</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"tool2 print...\n"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>main.c</code></li>
</ul>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"tool1.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"tool2.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    mytool1();</span><br><span class="line">    mytool2();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>对所有文件进行编译：</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc *.c</span><br></pre></td></tr></tbody></table></figure>
<p>执行<code>a.out</code></p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng makefile]<span class="comment"># ./a.out </span></span><br><span class="line">tool1 <span class="built_in">print</span>...</span><br><span class="line">tool2 <span class="built_in">print</span>...</span><br></pre></td></tr></tbody></table></figure>
<h4 id="1-4-2-语法规则"><a href="#1-4-2-语法规则" class="headerlink" title="1.4.2 语法规则"></a>1.4.2 语法规则</h4><figure class="highlight plaintext"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">plaintext</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">目标 ... : 依赖 ...</span><br><span class="line">	命令1</span><br><span class="line">	命令2</span><br><span class="line">	. . .</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>目标即要生成的文件。如果目标文件的更新时间晚于依赖文件更新时间，则说明依赖文件没有改动，目标文件不需要重新编译。否则会进行重新编译并更新目标文件。默认情况下Makefile的第一个目标为<strong>终极目标</strong>。</li>
<li>依赖：即目标文件由哪些文件生成。</li>
<li>命令：即通过执行命令由依赖文件生成目标文件。注意每条命令之前必须有一个tab保持缩进。</li>
</ul>
<blockquote>
<p>代码示例</p>
</blockquote>
<ul>
<li>新建makefile，<code>touch makefile</code></li>
</ul>
<figure class="highlight makefile"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">makefile</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">mytool:main.o tool1.o tool2.o</span></span><br><span class="line">    gcc main.o tool1.o tool2.o -o mytool</span><br><span class="line"><span class="section">main.o:main.c</span></span><br><span class="line">    gcc -c main.c -o main.o</span><br><span class="line"><span class="section">tool1.o:tool1.c</span></span><br><span class="line">    gcc -c tool1.c -o tool1.o</span><br><span class="line"><span class="section">tool2.o:tool2.c</span></span><br><span class="line">    gcc -c tool2.c -o tool2.o</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>执行<code>make</code>即可。</li>
</ul>
<hr>
<p>makefile会监视哪些源文件发生了变化，一旦发生变化，则会在有这个变化文件的编译链上重新编译。</p>
<ul>
<li>假设没有变化</li>
</ul>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng makefile]<span class="comment"># make</span></span><br><span class="line">make: `mytool<span class="string">' is up to date.</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>将<code>tool1.c</code>修改一点，再次make</li>
</ul>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng makefile]<span class="comment"># make</span></span><br><span class="line">gcc -c tool1.c -o tool1.o</span><br><span class="line">gcc main.o tool1.o tool2.o -o mytool</span><br><span class="line">[root@HongyiZeng makefile]<span class="comment"># ./mytool </span></span><br><span class="line">tool1.c is updated...</span><br><span class="line">tool2 <span class="built_in">print</span>...</span><br></pre></td></tr></tbody></table></figure>
<p>发现只有<code>tool1.c</code>影响到的地方被重新编译了，没有发生变化的地方则不会被重新编译。</p>
<hr>
<ul>
<li>代码清理<code>clean</code>：我们可以编译一条属于自己的clean语句，来清理make命令所产生的所有文件，例如：</li>
</ul>
<figure class="highlight makefile"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">makefile</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">mytool:main.o tool1.o tool2.o</span></span><br><span class="line">    gcc main.o tool1.o tool2.o -o mytool</span><br><span class="line"><span class="section">main.o:main.c</span></span><br><span class="line">    gcc -c main.c -o main.o</span><br><span class="line"><span class="section">tool1.o:tool1.c</span></span><br><span class="line">    gcc -c tool1.c -o tool1.o</span><br><span class="line"><span class="section">tool2.o:tool2.c</span></span><br><span class="line">    gcc -c tool2.c -o tool2.o</span><br><span class="line">    </span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm *.o mytool -rf</span><br></pre></td></tr></tbody></table></figure>
<p>使用：</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make clean</span><br></pre></td></tr></tbody></table></figure>
<hr>
<ul>
<li><p>变量：<code>$</code>符号表示取变量的值，当变量名多于一个字符时，使用<code>()</code></p>
</li>
<li><p>变量赋值：</p>
<ul>
<li><p><code>=</code>：最普通的等号，在Makefile中容易搞错赋值等号，使用 <code>=</code>进行赋值，变量的值是整个Makefile中<strong>最后被指定</strong>的值。</p>
<figure class="highlight makefile"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">makefile</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">VIR_A = A</span><br><span class="line">VIR_B = <span class="variable">$(VIR_A)</span> B</span><br><span class="line">VIR_A = AA</span><br></pre></td></tr></tbody></table></figure>
<p>经过上面的赋值后，最后VIR_B的值是<code>AA B</code>，而不是<code>A B</code>，在make时，会把整个Makefile展开，来决定变量的值</p>
</li>
<li><p><code>:=</code>：表示直接赋值，赋予当前位置的值。</p>
<figure class="highlight makefile"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">makefile</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">VIR_A := A</span><br><span class="line">VIR_B := <span class="variable">$(VIR_A)</span> B</span><br><span class="line">VIR_A := AA</span><br></pre></td></tr></tbody></table></figure>
<p>最后BIR_B的值是<code>A B</code>，即根据当前位置进行赋值。</p>
</li>
<li><p><code>?=</code>：表示如果该变量没有被赋值，赋值予等号后面的值。</p>
<figure class="highlight makefile"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">makefile</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VIR ?= new_value</span><br></pre></td></tr></tbody></table></figure>
<p>如果VIR在之前没有被赋值，那么VIR的值就为new_value。</p>
<figure class="highlight makefile"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">makefile</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">VIR := old_value</span><br><span class="line">VIR ?= new_value</span><br></pre></td></tr></tbody></table></figure>
<p>这种情况下，VIR的值就是old_value</p>
</li>
<li><p><code>+=</code>：和平时写代码的理解是一样的，表示将符号后面的值添加到前面的变量上</p>
</li>
</ul>
</li>
<li><p>预定义变量<code>CC</code>：c编译器的名称，默认值为<code>gcc</code></p>
</li>
</ul>
<blockquote>
<p>GCC编译选项<code>CFLAGS</code>参数</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-c</code></td>
<td>用于把源码文件编译成 .o 对象文件,不进行链接过程</td>
</tr>
<tr>
<td><code>-o</code></td>
<td>用于连接生成可执行文件，在其后可以指定输出文件的名称</td>
</tr>
<tr>
<td><code>-g</code></td>
<td>用于在生成的目标可执行文件中，添加调试信息，可以使用GDB进行调试</td>
</tr>
<tr>
<td><code>-Wall</code></td>
<td>生成常见的所有告警信息，且停止编译，具体是哪些告警信息，请参见GCC手册，一般用这个足矣！</td>
</tr>
<tr>
<td><code>-w</code></td>
<td>关闭所有告警信息</td>
</tr>
<tr>
<td><code>-O</code></td>
<td>表示编译优化选项，其后可跟优化等级0\1\2\3，默认是0，不优化</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>GCC链接选项<code>LDFLAGS</code>参数</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-llibrary</code></td>
<td>链接时在标准搜索目录中寻找库文件，搜索名为liblibrary.a 或 liblibrary.so</td>
</tr>
<tr>
<td><code>-Ldir</code></td>
<td>用于把新目录添加到库搜索路径上，可以使用相对和绝对路径，“-L.”、“-L./include”、“-L/opt/include”</td>
</tr>
<tr>
<td><code>-static</code></td>
<td>使用静态库链接生成目标文件，避免使用共享库，生成目标文件会比使用动态链接库大</td>
</tr>
</tbody>
</table>
</div>
<p>使用示例：例如posix线程中，查看创建线程的介绍<code>pthread_create</code>中：</p>
<p><a href="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20230115162552592.png" data-fancybox="gallery" data-caption="image-20230115162552592" data-thumb="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20230115162552592.png"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20230115162552592.png" alt="image-20230115162552592"></a></p>
<p>需要在编译和链接的选项中加上<code>-pthread</code>，因此，在编写makefile时需要加上：</p>
<figure class="highlight makefile"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">makefile</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CFLAGS+=-pthread</span><br><span class="line">LDFLAGS+=-pthread</span><br></pre></td></tr></tbody></table></figure>
<p>执行make时：</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cc -pthread -phread test.c -o <span class="built_in">test</span></span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>改造后的makefile</p>
</blockquote>
<figure class="highlight makefile"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">makefile</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">OBJS=main.o tool1.o tool2.o</span><br><span class="line">CFLAGS+=-c -Wall -g <span class="comment"># 编译选项</span></span><br><span class="line"></span><br><span class="line"><span class="section">mytool:<span class="variable">$(OBJS)</span></span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(OBJS)</span> -o mytool</span><br><span class="line"><span class="section">main.o:main.c</span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> main.c -o main.o</span><br><span class="line"><span class="section">tool1.o:tool1.c</span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> tool1.c -o tool1.o</span><br><span class="line"><span class="section">tool2.o:tool2.c</span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> tool2.c -o tool2.o</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm *.o mytool -rf</span><br></pre></td></tr></tbody></table></figure>
<p><code>$</code>的其他用法：</p>
<ul>
<li><code>$^</code> 表示所有的依赖文件</li>
<li><code>$@</code> 表示生成的目标文件</li>
<li><code>$&lt;</code> 代表第一个依赖文件</li>
</ul>
<blockquote>
<p>再次改造后的makefile</p>
</blockquote>
<figure class="highlight makefile"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">makefile</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">OBJS=main.o tool1.o tool2.o</span><br><span class="line">CFLAGS+=-c -Wall -g</span><br><span class="line"></span><br><span class="line"><span class="section">mytool:<span class="variable">$(OBJS)</span></span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="section">main.o:main.c</span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="section">tool1.o:tool1.c</span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="section">tool2.o:tool2.c</span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm *.o mytool -rf</span><br></pre></td></tr></tbody></table></figure>
<hr>
<p>实际上上面的三段代码都有固定的模式，如下：</p>
<figure class="highlight makefile"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">makefile</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">xxx.o:xxx.c</span></span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$^</span> -o <span class="variable">$@</span></span><br></pre></td></tr></tbody></table></figure>
<p>相同的部分<code>xxx</code>可以用通配符<code>%</code>代替。可以简化为：</p>
<figure class="highlight makefile"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">makefile</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">OBJS=main.o tool1.o tool2.o</span><br><span class="line">CFLAGS+=-c -Wall -g</span><br><span class="line"></span><br><span class="line"><span class="section">mytool:<span class="variable">$(OBJS)</span></span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="section">%.o:%.c</span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line">    </span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm *.o mytool -rf</span><br></pre></td></tr></tbody></table></figure>
<h3 id="1-5-POSIX"><a href="#1-5-POSIX" class="headerlink" title="1.5 POSIX"></a>1.5 POSIX</h3><p>来源：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/392588996">https://zhuanlan.zhihu.com/p/392588996</a> 侵权必删</p>
<h4 id="1-5-1-简介"><a href="#1-5-1-简介" class="headerlink" title="1.5.1 简介"></a>1.5.1 简介</h4><p>POSIX：可移植操作系统接口（<code>Portable Operating System Interface of UNIX</code>，缩写为 POSIX ）；</p>
<p>发布者为电气与电子工程师协会（Institute of Electrical and Electronics Engineers），简称IEEE。</p>
<p>POSIX是IEEE为要在各种UNIX操作系统上运行的软件而定义的一系列API标准的总称，其正式称呼为IEEE 1003，而国际标准名称为ISO/IEC 9945。</p>
<h4 id="1-5-2-历史"><a href="#1-5-2-历史" class="headerlink" title="1.5.2 历史"></a>1.5.2 历史</h4><p>POSIX是Unix的标准。</p>
<p>1974年，贝尔实验室正式对外发布Unix。因为涉及到反垄断等各种原因，加上早期的Unix不够完善，于是贝尔实验室以慷慨的条件向学校提供源代码，所以Unix在大专院校里获得了很多支持并得以持续发展。</p>
<p>于是出现了好些独立开发的与Unix基本兼容但又不完全兼容的OS，通称Unix-like OS。包括：</p>
<ol>
<li>美国加州大学伯克利分校的Unix4.xBSD(Berkeley Software Distribution)。</li>
<li>贝尔实验室发布的自己的版本，称为System V Unix。</li>
<li>其他厂商的版本，比如Sun Microsystems的Solaris系统,则是从这些原始的BSD和System V版本中衍生而来。</li>
</ol>
<p>20世纪80年代中期，Unix厂商试图通过加入新的、往往不兼容的特性来使它们的程序与众不同。</p>
<p>为了提高兼容性和应用程序的可移植性，阻止这种趋势， IEEE开始努力标准化Unix的开发，后来由 Richard Stallman命名为<code>Posix</code>。</p>
<p>这套标准涵盖了很多方面，比如Unix系统调用的C语言接口、shell程序和工具、线程及网络编程。</p>
<h4 id="1-5-3-可移植性"><a href="#1-5-3-可移植性" class="headerlink" title="1.5.3 可移植性"></a>1.5.3 可移植性</h4><h5 id="①-系统调用和库函数"><a href="#①-系统调用和库函数" class="headerlink" title="① 系统调用和库函数"></a>① 系统调用和库函数</h5><p>Linux下对文件操作有两种方式：<strong>系统调用</strong>（system call）和<strong>库函数调用</strong>（Library functions）。</p>
<ul>
<li>系统调用：系统调用是通向操作系统本身的接口，是面向底层硬件的。通过系统调用，可以使得用户态运行的进程与硬件设备(如CPU、磁盘、打印机等)进行交互，是操作系统留给应用程序的一个接口。</li>
<li>库函数调用：库函数（Library function）是把函数放到库里，供别人使用的一种方式。</li>
</ul>
<p>方法是把一些常用到的函数编完放到一个文件里，供不同的人进行调用。一般放在<code>.lib</code>文件中。</p>
<p>库函数调用则是面向应用开发的，库函数可分为两类：</p>
<ol>
<li>一类是C语言标准规定的库函数，</li>
<li>一类是编译器特定的库函数。</li>
</ol>
<p>(由于版权原因，库函数的源代码一般是不可见的，但在头文件中你可以看到它对外的接口)。</p>
<p><code>glibc</code> 是 Linux 下使用的开源的标准 C 库，它是 GNU 发布的 libc 库，即运行时库。这些基本函数都是被标准化了的，而且这些函数通常都是用汇编直接实现的。</p>
<p>glibc 为程序员提供丰富的 API（Application Programming Interface），这些API都是遵循POSIX标准的，API的函数名，返回值，参数类型等都必须按照POSIX标准来定义。</p>
<p><strong>POSIX兼容也就指定这些接口函数兼容，但是并不管API具体如何实现。</strong></p>
<h5 id="②-区别"><a href="#②-区别" class="headerlink" title="② 区别"></a>② 区别</h5><p><a href="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/v2-3a61e1a67e92a89bd5a4e5f050ee406f_r.jpg" data-fancybox="gallery" data-caption="img" data-thumb="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/v2-3a61e1a67e92a89bd5a4e5f050ee406f_r.jpg"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/v2-3a61e1a67e92a89bd5a4e5f050ee406f_r.jpg" alt="img"></a></p>
<p>如上图所示：</p>
<ul>
<li>库函数是语言或应用程序的一部分，而系统调用是内核提供给应用程序的接口，属于系统的一部分</li>
<li>库函数在用户地址空间执行，系统调用是在内核地址空间执行，库函数运行时间属于用户时间，系统调用属于系统时间，库函数开销较小，系统调用开销较大</li>
<li>系统调用依赖于平台，库函数并不依赖</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>函数库调用</th>
<th>系统调用</th>
</tr>
</thead>
<tbody>
<tr>
<td>定义差别</td>
<td>在所有的ANSI C编译器版本中，C函数库是相同的</td>
<td>各个操作系统的系统调用是不同的</td>
</tr>
<tr>
<td>调用差别</td>
<td>它调用函数库中的一段程序或函数</td>
<td>调用系统内核的服务</td>
</tr>
<tr>
<td>运行空间</td>
<td>用户地址空间</td>
<td>内核地址空间</td>
</tr>
<tr>
<td>开销</td>
<td>属于过程调用，开销小</td>
<td>需要在用户空间和内核空间上下文切换，开销较大</td>
</tr>
<tr>
<td>个数</td>
<td>在C函数库libc中大约有300个函数</td>
<td>在Linux中大约有100多个系统调用</td>
</tr>
<tr>
<td>典型调用</td>
<td>pringf，fread，malloc</td>
<td>chdir，fork，write，brk</td>
</tr>
</tbody>
</table>
</div>
<p><strong>系统调用是为了方便使用操作系统的接口，而库函数则是为了人们编程的方便。</strong></p>
<p><strong>库函数调用与系统无关，不同的系统，调用库函数，库函数会调用不同的底层函数实现，因此可移植性好。</strong></p>
<h4 id="1-5-4-实例"><a href="#1-5-4-实例" class="headerlink" title="1.5.4 实例"></a>1.5.4 实例</h4><p>当应用程序调用printf()函数时，printf函数会调用C库中的printf，继而调用C库中的write，C库最后调用内核的write()。</p>
<p>而另一些则不会使用系统调用，比如strlen, strcat, memcpy等。</p>
<p><a href="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/v2-7f5eb3c97342632b5975493cbdd45b9f_r.jpg" data-fancybox="gallery" data-caption="img" data-thumb="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/v2-7f5eb3c97342632b5975493cbdd45b9f_r.jpg"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/v2-7f5eb3c97342632b5975493cbdd45b9f_r.jpg" alt="img"></a></p>
<p>printf函数执行过程中，程序运行状态切换如下：</p>
<figure class="highlight plaintext"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">plaintext</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户态–&gt;系统调用–&gt;内核态–&gt;返回用户态</span><br></pre></td></tr></tbody></table></figure>
<p>printf函数、glibc库和系统调用在系统中关系图如下：</p>
<p><a href="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/v2-a8315ef7d9a895bb4649fe3cd6f3e96a_r.jpg" data-fancybox="gallery" data-caption="img" data-thumb="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/v2-a8315ef7d9a895bb4649fe3cd6f3e96a_r.jpg"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/v2-a8315ef7d9a895bb4649fe3cd6f3e96a_r.jpg" alt="img"></a></p>
<h2 id="2-标准IO"><a href="#2-标准IO" class="headerlink" title="2 标准IO"></a>2 标准IO</h2><p>该节对应<code>APUE</code>的第五章——标准IO库</p>
<h3 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h3><p>IO分为标准IO（<code>stdio</code>）和系统调用IO（<code>sysio</code>）；</p>
<p>系统调用IO根据操作系统的实现方式而定，对于程序员来说会造成很大困扰（例如打开文件，Linux的系统调用为<code>open</code>，而Windows的系统调用为<code>opendir</code>），于是又有了标准IO，提供了一套标准的IO实现的库函数（例如<code>pringtf</code>，<code>fopen</code>等），它实际上也是调用了系统IO进行操作，但是屏蔽了系统调用IO，方便程序员调用。</p>
<p>常用的标准IO库函数如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>打开关闭文件</th>
<th>输入输出流</th>
<th>文件指针操作</th>
<th>缓存相关</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>fopen</code></td>
<td><code>fgetc</code>，<code>fputc</code></td>
<td><code>fseek</code></td>
<td><code>fflush</code></td>
</tr>
<tr>
<td><code>fclose</code></td>
<td><code>fgets</code>，<code>fputs</code></td>
<td><code>ftell</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>fread</code>，<code>fwrite</code></td>
<td><code>rewind</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>printf</code>族，<code>scanf</code>族</td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>注意<code>FILE</code>类型贯穿始终；</p>
<h3 id="2-2-fopen"><a href="#2-2-fopen" class="headerlink" title="2.2 fopen"></a>2.2 fopen</h3><p>C 库函数 <code>fopen</code> 使用给定的模式 <strong>mode</strong> 打开 <strong>filename</strong> 所指向的文件。</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FILE *<span class="title">fopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">const</span> <span class="keyword">char</span> *mode)</span></span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>filename</strong> — 字符串，表示要打开的文件名称。</li>
<li><strong>mode</strong> — 字符串，表示文件的访问模式，该指针指向以下面字符开头的字符串：</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">模式</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">“r”</td>
<td style="text-align:left">打开一个用于读取的文件。该文件必须存在。</td>
</tr>
<tr>
<td style="text-align:left">“w”</td>
<td style="text-align:left">创建一个用于写入的空文件。如果文件名称与已存在的文件相同，则会删除已有文件的内容，文件被视为一个新的空文件。<strong>有则清空，无则创建</strong>。</td>
</tr>
<tr>
<td style="text-align:left">“a”</td>
<td style="text-align:left">追加到一个文件。写操作向<strong>文件末尾</strong>追加数据。如果文件不存在，则创建文件。</td>
</tr>
<tr>
<td style="text-align:left">“r+”</td>
<td style="text-align:left">打开一个用于更新的文件，可读取也可写入。该文件必须存在。</td>
</tr>
<tr>
<td style="text-align:left">“w+”</td>
<td style="text-align:left">创建一个用于读写的空文件。</td>
</tr>
<tr>
<td style="text-align:left">“a+”</td>
<td style="text-align:left">打开一个用于读取和追加的文件。</td>
</tr>
</tbody>
</table>
</div>
<p>只有模式<code>r</code>和<code>r+</code>要求文件必须存在，其他模式都是有则清空，无则创建；</p>
<p><strong>mode</strong>也可以包含字母<code>b</code>，放在最后或者中间，表示二进制流。例如<code>“rb”</code>，<code>“r+b”</code>；</p>
<ul>
<li>该函数返回一个 FILE 指针。否则返回 NULL，且设置<strong>全局变量</strong> <code>errno</code> 来标识错误。该全局变量在头文件<code>errno.h</code>中声明：（只展示部分）</li>
</ul>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EPERM 1 <span class="comment">/* Operation not permitted */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ENOENT 2 <span class="comment">/* No such file or directory */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ESRCH 3 <span class="comment">/* No such process */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EINTR 4 <span class="comment">/* Interrupted system call */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EIO 5 <span class="comment">/* I/O error */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ENXIO 6 <span class="comment">/* No such device or address */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> E2BIG 7 <span class="comment">/* Argument list too long */</span></span></span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    FILE *fp;</span><br><span class="line">    fp = fopen(<span class="string">"tmp"</span>, <span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"fopen() failed! errno = %d.\n"</span>, errno);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"OK!"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>编译执行后打印结果：</p>
<figure class="highlight plaintext"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">plaintext</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fopen() failed! errno = 2.</span><br></pre></td></tr></tbody></table></figure>
<p>可知<code>errno</code>为2，为<code>No such file or directory</code>；</p>
<p>在C标准中定义了两个函数帮助打印输出errno的对应错误原因，一个是<code>strerror</code>，另一个是<code>perror</code>；</p>
<hr>
<p>perror包含在<code>stdio.h</code>中：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数原型</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*功能：根据error打印对应的错误信息</span></span><br><span class="line"><span class="comment">*参数：s: 用户自定义信息字符串，一般是出错的函数名</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">perror</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p>修改后的程序为：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    FILE *fp;</span><br><span class="line">    fp = fopen(<span class="string">"tmp"</span>, <span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="comment">// fprintf(stderr, "fopen() failed! errno = %d.\n", errno);</span></span><br><span class="line">        perror(<span class="string">"fopen()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"OK!"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>打印结果：</p>
<figure class="highlight plaintext"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">plaintext</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fopen(): No such file or directory</span><br></pre></td></tr></tbody></table></figure>
<hr>
<p><code>strerror</code>包含在<code>&lt;string.h&gt;</code>头文件中</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数原型</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*功能：将某个错误代码转换成对应的错误信息</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strerror</span><span class="params">(<span class="keyword">int</span> errnuum)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p>修改后的程序为：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"fopen:%s\n"</span>, strerror(errno));</span><br></pre></td></tr></tbody></table></figure>
<hr>
<p>fopen函数解析：</p>
<p>由函数原型可知，fopen函数返回的是一个FILE类型的指针，FILE是一个结构体，由<code>typedef</code>进行了重命名，而指针实际上是指向结构体的指针。</p>
<p>问题：指针指向的内存空间是哪一块（或者说FILE结构体放在内存的哪一块）？是堆，是栈，还是静态区？</p>
<ul>
<li>栈</li>
</ul>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单的fopen源码分析</span></span><br><span class="line"><span class="function">FILE *<span class="title">fopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">const</span> <span class="keyword">char</span> *mode)</span> </span>{</span><br><span class="line">    FILE tmp;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 给结构体成员赋值初始化</span></span><br><span class="line">    tmp.xxx = xxx;</span><br><span class="line">    tmp.yyy = yyy;</span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> &amp;tmp;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>分析：<code>tmp</code>变量的存储类别是自动类型（块作用域，自动存储期），当程序退出这个块时，<strong>释放刚才为变量tmp匹配的内存</strong>，因此，指针指向的地址实际上没有tmp，是一个没有被分配的内存；</p>
<ul>
<li>静态区</li>
</ul>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单的fopen源码分析</span></span><br><span class="line"><span class="function">FILE *<span class="title">fopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">const</span> <span class="keyword">char</span> *mode)</span> </span>{</span><br><span class="line">    <span class="keyword">static</span> FILE tmp;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 给结构体成员赋值初始化</span></span><br><span class="line">    tmp.xxx = xxx;</span><br><span class="line">    tmp.yyy = yyy;</span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> &amp;tmp;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>加上<code>static</code>，将tmp保存在静态区（静态无链接），但是只能存在一个FILE实例（因为只有这一个内存区供指针指向）；例如：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fp1 = fopen(<span class="string">"a"</span>, <span class="string">"r"</span>);</span><br><span class="line">fp2 = fopen(<span class="string">"b"</span>, <span class="string">"r"</span>);</span><br><span class="line"><span class="comment">// 此时fp1实际指向了b，第二次的结果会把第一次的结果覆盖掉</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>堆（正解）</li>
</ul>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单的fopen源码分析</span></span><br><span class="line"><span class="function">FILE *<span class="title">fopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">const</span> <span class="keyword">char</span> *mode)</span> </span>{</span><br><span class="line">    FILE *tmp = <span class="literal">NULL</span>;</span><br><span class="line">    tmp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(FILE));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 给结构体成员赋值初始化</span></span><br><span class="line">    tmp-&gt;xxx = xxx;</span><br><span class="line">    tmp-&gt;yyy = yyy;</span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>此时变量<code>tmp</code>具有动态存储期，从调用<code>malloc</code>分配内存到调用<code>free</code>释放内存为止，而<code>free</code>就在<code>fclose</code>函数中被调用。</p>
<h3 id="2-3-fclose"><a href="#2-3-fclose" class="headerlink" title="2.3 fclose"></a>2.3 fclose</h3><p>C 库函数 <code>fclose</code> 关闭流 stream。刷新所有的缓冲区。</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fclose</span><span class="params">(FILE *stream)</span></span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>stream</strong> — 这是指向 FILE 对象的指针，该 FILE 对象指定了要被关闭的流。</li>
<li>如果流成功关闭，则该方法返回零。如果失败，则返回 EOF。</li>
</ul>
<blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    FILE *fp;</span><br><span class="line">    fp = fopen(<span class="string">"tmp"</span>, <span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp == <span class="literal">NULL</span>) {</span><br><span class="line">        perror(<span class="string">"fopen()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"OK!"</span>);</span><br><span class="line">    fclose(fp); <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="2-4-fgetc和fputc"><a href="#2-4-fgetc和fputc" class="headerlink" title="2.4 fgetc和fputc"></a>2.4 fgetc和fputc</h3><ul>
<li><code>getchar</code>和<code>putchar</code></li>
</ul>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getchar</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 从标准输入 stdin 获取一个字符（一个无符号字符）。这等同于 getc 带有 stdin 作为参数</span></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putchar</span><span class="params">(<span class="keyword">int</span> <span class="keyword">char</span>)</span></span>; <span class="comment">// 把参数 char 指定的字符（一个无符号字符）写入到标准输出 stdout 中。这等同于 putc 带有 stdout 作为参数</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>getc</code>和<code>putc</code></li>
</ul>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getc</span><span class="params">(FILE *stream)</span></span>; <span class="comment">// 从指定的流 stream 获取下一个字符（一个无符号字符），并把位置标识符往前移动。 </span></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putc</span><span class="params">(<span class="keyword">int</span> <span class="keyword">char</span>, FILE *stream)</span></span>; <span class="comment">// 把参数 char 指定的字符（一个无符号字符）写入到指定的流 stream 中，并把位置标识符往前移动。</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>fgetc</code>和<code>fputc</code></li>
</ul>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fgetc</span><span class="params">(FILE *stream)</span></span>; <span class="comment">// 从指定的流 stream 获取下一个字符（一个无符号字符），并把位置标识符往前移动。</span></span><br><span class="line"><span class="comment">// 该函数以无符号 char 强制转换为 int 的形式返回读取的字符，如果到达文件末尾或发生读错误，则返回 EOF。</span></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputc</span><span class="params">(<span class="keyword">int</span> <span class="keyword">char</span>, FILE *stream)</span></span>; <span class="comment">// 把参数 char 指定的字符（一个无符号字符）写入到指定的流 stream 中，并把位置标识符往前移动。</span></span><br><span class="line"><span class="comment">// 如果没有发生错误，则返回被写入的字符。如果发生错误，则返回 EOF，并设置错误标识符。</span></span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p><code>getc</code>，<code>putc</code>和<code>fgetc</code>，<code>fputc</code>的区别</p>
</blockquote>
<p>两者的使用完全相同，只是实现不同。这里的<code>f</code>指的是<code>function</code>，而不是<code>file</code>。</p>
<p><code>getc</code>，<code>putc</code>是通过<strong>宏定义</strong>实现，而<code>fgetc</code>，<code>fputc</code>是通过<strong>函数</strong>来实现。</p>
<p>宏只占用编译时间，不占用调用时间，而函数相反，因此内核的实现通常使用宏来定义函数，减少调用时间。</p>
<blockquote>
<p>代码示例</p>
</blockquote>
<p>需求：拷贝文件</p>
<figure class="highlight plaintext"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">plaintext</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./mycpy src dest</span><br></pre></td></tr></tbody></table></figure>
<p>实现代码：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 命令行传参</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>{</span><br><span class="line"></span><br><span class="line">    FILE *fps, *fpd;</span><br><span class="line">    <span class="keyword">int</span> ch; <span class="comment">// 存储读入的字符</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">3</span>) {</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Usage:%s &lt;src_file&gt; &lt;dest_file&gt;\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    fps = fopen(argv[<span class="number">1</span>], <span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">if</span>(fps == <span class="literal">NULL</span>) {</span><br><span class="line">        perror(<span class="string">"fopen()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    fpd = fopen(argv[<span class="number">2</span>], <span class="string">"w"</span>);</span><br><span class="line">    <span class="keyword">if</span>(fpd == <span class="literal">NULL</span>) {</span><br><span class="line">        fclose(fps);</span><br><span class="line">        perror(<span class="string">"fopen()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">        ch = fgetc(fps);</span><br><span class="line">        <span class="keyword">if</span>(ch == EOF) { <span class="comment">// 读到文件末尾结束循环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        fputc(ch, fpd);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 释放内存，后开的先关</span></span><br><span class="line">    fclose(fpd);</span><br><span class="line">    fclose(fps);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>使用：</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./mycpy /usr/<span class="built_in">local</span>/<span class="built_in">test</span> /temp/out</span><br></pre></td></tr></tbody></table></figure>
<h3 id="2-5-fgets和fputs"><a href="#2-5-fgets和fputs" class="headerlink" title="2.5 fgets和fputs"></a>2.5 fgets和fputs</h3><ul>
<li><code>gets</code>和<code>puts</code></li>
</ul>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">gets</span><span class="params">(<span class="keyword">char</span> *str)</span></span>; <span class="comment">// 从标准输入 stdin 读取一行，并把它存储在 str 所指向的字符串中。当读取到换行符时，或者到达文件末尾时，它会停止，具体视情况而定。</span></span><br><span class="line"><span class="comment">// 如果成功，该函数返回 str。如果发生错误或者到达文件末尾时还未读取任何字符，则返回 NULL。</span></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">puts</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span>; <span class="comment">// 把一个字符串写入到标准输出 stdout，直到空字符，但不包括空字符。换行符会被追加到输出中。</span></span><br><span class="line"><span class="comment">// 如果成功，该函数返回一个非负值为字符串长度（包括末尾的 \0），如果发生错误则返回 EOF。</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>fgets</code>和<code>fputs</code></li>
</ul>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从指定的流 stream 读取一行，并把它存储在 str 所指向的字符串内。当读取 (n-1) 个字符时，或者读取到换行符时，或者到达文件末尾时，它会停止，具体视情况而定。</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">fgets</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">int</span> n, FILE *stream)</span></span>; </span><br><span class="line"><span class="comment">// 如果成功，该函数返回相同的 str 参数。如果到达文件末尾或者没有读取到任何字符，str 的内容保持不变，并返回一个空指针。</span></span><br><span class="line"><span class="comment">// 如果发生错误，返回一个空指针。</span></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  把字符串写入到指定的流 stream 中，但不包括空字符。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str, FILE *stream)</span></span>;</span><br><span class="line"><span class="comment">// 该函数返回一个非负值，如果发生错误则返回 EOF。</span></span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>区别</p>
</blockquote>
<p> <code>fgets</code>比<code>gets</code>安全，使用<code>gets</code>编译时会警告。所以不要使用<code>gets</code>！</p>
<p>原因：函数 gets 可以<strong>无限读取</strong>，不会判断上限，所以程序员应该确保 buffer 的空间足够大，以便在执行读操作时不发生溢出。也就是说，gets 函数并不检查缓冲区 buffer 的空间大小，事实上它也无法检查缓冲区的空间。</p>
<p>如果函数的调用者提供了一个指向堆栈的指针，并且 gets 函数读入的字符数量超过了缓冲区的空间（即发生溢出），gets 函数会将多出来的字符继续写入堆栈中，这样就覆盖了堆栈中原来的内容，破坏一个或多个不相关变量的值。</p>
<hr>
<p><code>fgets</code>读取结束的条件，满足其一即可：</p>
<ul>
<li>读到<code>size-1</code>个字符时停止，<code>size</code>位置存放<code>\0</code></li>
<li>读到换行符<code>'\n'</code>时停止</li>
<li>读到文件末尾<code>EOF</code></li>
</ul>
<blockquote>
<p>简单的实例</p>
</blockquote>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 5</span></span><br><span class="line"><span class="keyword">char</span> buf[SIZE]; <span class="comment">// 栈上的动态内存</span></span><br><span class="line">fgets(buf, SIZE, stream);</span><br><span class="line"></span><br><span class="line">如果stream = <span class="string">"abcde"</span></span><br><span class="line">则buf = <span class="string">"abcd\0"</span>(读到size<span class="number">-1</span>)，文件指针指向e</span><br><span class="line"></span><br><span class="line">如果stream = <span class="string">"ab"</span></span><br><span class="line">则buf = <span class="string">"ab\n\0"</span>(读到换行符)，文件指针指向EOF</span><br><span class="line"></span><br><span class="line">极端的情况：</span><br><span class="line">如果stream = <span class="string">"abcd"</span></span><br><span class="line">则需要fgets读取两次才能读完</span><br><span class="line">第一次读取的为<span class="string">"abcd\0"</span>(读到SIZE<span class="number">-1</span>)，指针指向<span class="string">'\n'</span></span><br><span class="line">第二次读取的为<span class="string">"\n\0"</span>(读到换行符)，指针指向EOF</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>代码示例</p>
</blockquote>
<p>用<code>fgets</code>和<code>fputs</code>代替<code>fgtec</code>和<code>fputc</code>：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>{</span><br><span class="line"></span><br><span class="line">    FILE *fps, *fpd;</span><br><span class="line">    <span class="keyword">char</span> buf[SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">3</span>) {</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Usage:%s &lt;src_file&gt; &lt;dest_file&gt;\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    fps = fopen(argv[<span class="number">1</span>], <span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">if</span>(fps == <span class="literal">NULL</span>) {</span><br><span class="line">        perror(<span class="string">"fopen()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    fpd = fopen(argv[<span class="number">2</span>], <span class="string">"w"</span>);</span><br><span class="line">    <span class="keyword">if</span>(fpd == <span class="literal">NULL</span>) {</span><br><span class="line">        fclose(fps);</span><br><span class="line">        perror(<span class="string">"fopen()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(fgets(buf, SIZE, fps) != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="built_in">fputs</span>(buf, fpd);</span><br><span class="line"></span><br><span class="line">    fclose(fpd);</span><br><span class="line">    fclose(fps);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="2-6-fread和fwrite"><a href="#2-6-fread和fwrite" class="headerlink" title="2.6 fread和fwrite"></a>2.6 fread和fwrite</h3><p><code>fread</code>从给定流 <strong>stream</strong> 读取数据到 <strong>ptr</strong> 所指向的数组中。</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">fread</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nmemb, FILE *stream)</span></span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>ptr</strong> — 这是指向带有最小尺寸 <code>size*nmemb</code> 字节的内存块的指针。</li>
<li><strong>size</strong> — 这是要读取的每个元素的大小，以字节为单位。</li>
<li><strong>nmemb</strong> — 这是元素的个数，每个元素的大小为 size 字节。</li>
<li><strong>stream</strong> — 这是指向 FILE 对象的指针，该 FILE 对象指定了一个输入流。</li>
</ul>
<ul>
<li>成功读取的<strong>元素总数</strong>会以 size_t 对象返回，size_t 对象是一个整型数据类型。如果总数与 nmemb 参数不同，则可能发生了一个错误或者到达了文件末尾。</li>
</ul>
<p><code>fwrite</code>把 <strong>ptr</strong> 所指向的数组中的数据写入到给定流 <strong>stream</strong> 中。</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">fwrite</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nmemb, FILE *stream)</span></span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>ptr</strong> — 这是指向要被写入的元素数组的指针。</li>
<li><strong>size</strong> — 这是要被写入的每个元素的大小，以字节为单位。</li>
<li><strong>nmemb</strong> — 这是元素的个数，每个元素的大小为 size 字节。</li>
<li><strong>stream</strong> — 这是指向 FILE 对象的指针，该 FILE 对象指定了一个输出流。</li>
<li>如果成功，该函数返回一个 size_t 对象，表示元素的总数，该对象是一个整型数据类型。如果该数字与 nmemb 参数不同，则会显示一个错误。</li>
</ul>
<blockquote>
<p>简单的实例</p>
</blockquote>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">fread(buf, size, nmemb, fp);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况1：数据量足够</span></span><br><span class="line"><span class="comment">// 情况2：文件只有5个字节</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读10个对象，每个对象1个字节</span></span><br><span class="line">fread(buf, <span class="number">1</span>, <span class="number">10</span>, fp);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况1：</span></span><br><span class="line"><span class="comment">// 第一次读：返回10（读到10个对象），读到10个字节</span></span><br><span class="line"><span class="comment">// 情况2：</span></span><br><span class="line"><span class="comment">// 第一次读：返回5（读到5个对象），读到5个字节</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//--------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读1个对象，每个对象10个字节</span></span><br><span class="line">fread(buf, <span class="number">10</span>, <span class="number">1</span>, fp);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况1：</span></span><br><span class="line"><span class="comment">// 第一次读：返回1（读到1个对象），也读到10个字节</span></span><br><span class="line"><span class="comment">// 情况2：</span></span><br><span class="line"><span class="comment">// 第一次读：返回0（读不到1个对象，因为1个对象要10字节，而文件只有5个字节）</span></span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>代码示例</p>
</blockquote>
<p>用<code>fread</code>和<code>fwrite</code>代替<code>fgtec</code>和<code>fputc</code>：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>{</span><br><span class="line"></span><br><span class="line">    FILE *fps, *fpd;</span><br><span class="line">    <span class="keyword">char</span> buf[SIZE];</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">3</span>) {</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Usage:%s &lt;src_file&gt; &lt;dest_file&gt;\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    fps = fopen(argv[<span class="number">1</span>], <span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">if</span>(fps == <span class="literal">NULL</span>) {</span><br><span class="line">        perror(<span class="string">"fopen()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    fpd = fopen(argv[<span class="number">2</span>], <span class="string">"w"</span>);</span><br><span class="line">    <span class="keyword">if</span>(fpd == <span class="literal">NULL</span>) {</span><br><span class="line">        fclose(fps);</span><br><span class="line">        perror(<span class="string">"fopen()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 如果成功读到n(n&gt;0)个对象，则返回n</span></span><br><span class="line">    <span class="comment">// 将这n个对象写入流中</span></span><br><span class="line">    <span class="keyword">while</span>((n = fread(buf, <span class="number">1</span>, SIZE, fps)) &gt; <span class="number">0</span>) </span><br><span class="line">            fwrite(buf, <span class="number">1</span>, n, fpd);</span><br><span class="line"></span><br><span class="line">    fclose(fpd);</span><br><span class="line">    fclose(fps);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="2-7-printf和scanf"><a href="#2-7-printf和scanf" class="headerlink" title="2.7 printf和scanf"></a>2.7 printf和scanf</h3><blockquote>
<p><code>printf</code>一族函数</p>
</blockquote>
<ul>
<li><code>printf</code>：发送格式化输出到标准输出 stdout。</li>
</ul>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>fprintf</code>：发送格式化输出到流 stream 中。可以实现格式化输出的<strong>重定向</strong>，例如重定向至文件中。</li>
</ul>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fprintf</span><span class="params">(FILE *stream, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>sprintf</code>：发送格式化输出到 <strong>str</strong> 所指向的字符串。它能够将多种数据类型（整型、字符型）的数据综合为字符串类型。有溢出风险，可以使用<code>snprintf</code>来防止。</li>
</ul>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sprintf</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>atoi</code>：把参数 <strong>str</strong> 所指向的字符串转换为一个整数（类型为 int 型）。包含在<code>stdlib.h</code>中。</li>
</ul>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">atoi</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span></span><br></pre></td></tr></tbody></table></figure>
<p>代码示例：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    <span class="keyword">char</span> str[] = <span class="string">"123456"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, atoi(str)); <span class="comment">// 123456</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    <span class="keyword">char</span> str[] = <span class="string">"123a456"</span>;</span><br><span class="line">	<span class="comment">// 遇到字符就停止</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, atoi(str)); <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">int</span> year = <span class="number">2022</span>, month = <span class="number">11</span>, day = <span class="number">28</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 将格式化输出重定向为字符串</span></span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">"%d-%d-%d"</span>, year, month, day);</span><br><span class="line">    <span class="built_in">puts</span>(buf);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p><code>scanf</code>一族函数</p>
</blockquote>
<ul>
<li><code>scanf</code></li>
<li><code>fscanf</code></li>
<li><code>sscanf</code></li>
</ul>
<h3 id="2-8-fseek和ftell"><a href="#2-8-fseek和ftell" class="headerlink" title="2.8 fseek和ftell"></a>2.8 fseek和ftell</h3><p><code>fseek</code>：设置流 <strong>stream</strong> 的文件位置为给定的偏移 <strong>offset</strong>，参数 offset 意味着从给定的 <strong>whence</strong> 位置查找的字节数。</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fseek</span><span class="params">(FILE *stream, <span class="keyword">long</span> <span class="keyword">int</span> offset, <span class="keyword">int</span> whence)</span></span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>stream</strong> — 这是指向 FILE 对象的指针，该 FILE 对象标识了流。</li>
<li><strong>offset</strong> — 这是相对 whence 的偏移量，以<strong>字节</strong>为单位。</li>
<li><strong>whence</strong> — 这是表示开始添加偏移 offset 的位置。它一般指定为下列常量之一：</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">常量</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>SEEK_SET</code></td>
<td style="text-align:left">文件的开头</td>
</tr>
<tr>
<td style="text-align:left"><code>SEEK_CUR</code></td>
<td style="text-align:left">文件指针的当前位置</td>
</tr>
<tr>
<td style="text-align:left"><code>SEEK_END</code></td>
<td style="text-align:left">文件的末尾</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>如果成功，则该函数返回零，否则返回非零值。</li>
</ul>
<hr>
<p><code>ftell</code>：返回给定流 stream 的当前文件位置。</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">int</span> <span class="title">ftell</span><span class="params">(FILE *stream)</span></span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>stream</strong> — 这是指向 FILE 对象的指针，该 FILE 对象标识了流。</li>
<li>该函数返回位置标识符的当前值。如果发生错误，则返回 -1L，全局变量 errno 被设置为一个正值。</li>
</ul>
<blockquote>
<p>程序实例——求程序的有效字节</p>
</blockquote>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span>{</span><br><span class="line"></span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>) {</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Usage...\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    fp = fopen(argv[<span class="number">1</span>], <span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp == <span class="literal">NULL</span>) {</span><br><span class="line">        perror(<span class="string">"fopen()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">	<span class="comment">// 将指针定位在文件末尾</span></span><br><span class="line">    fseek(fp, <span class="number">0</span>, SEEK_END);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ftell(fp));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><a href="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221130104327899.png" data-fancybox="gallery" data-caption="image-20221130104327899" data-thumb="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221130104327899.png"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221130104327899.png" alt="image-20221130104327899"></a></p>
<hr>
<p><code>rewind</code>：设置文件位置为给定流 <strong>stream</strong> 的文件的开头。</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rewind</span><span class="params">(FILE *stream)</span></span></span><br></pre></td></tr></tbody></table></figure>
<p>相当于<code>(void) fseek(stream, 0, SEEK_SET);</code></p>
<blockquote>
<p>注意</p>
</blockquote>
<p><code>fseek</code>和<code>ftell</code>中偏移<code>offset</code>的修饰类型是<code>long</code>，因此只能对2G左右大小的文件进行操作，否则会超出<code>long</code>的范围；</p>
<p><code>fseeko</code>和<code>ftello</code>则将偏移的修饰类型使用<code>typedef</code>定义为<code>offset_t</code>，具体类型交由系统决定，因此不存在文件大小的限制。但是这两个函数不是C标准库函数，而是隶属于POSIX标准（POSIX是标准C库的超集，或者说，C库是普通话，而POSIX是方言）。</p>
<h3 id="2-9-fflush"><a href="#2-9-fflush" class="headerlink" title="2.9 fflush"></a>2.9 fflush</h3><p><code>fflush</code>：刷新流 stream 的<strong>输出缓冲区</strong>。刷新，指的是将缓冲区（内存上的一片区域）的内容写入到磁盘（外存）中，或者输出到终端上显示。</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fflush</span><span class="params">(FILE *stream)</span></span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>如果参数为<code>NULL</code>，则刷新所有的已打开的流</li>
<li>如果成功，该函数返回零值。如果发生错误，则返回 EOF，且设置错误标识符（即 feof）。</li>
</ul>
<blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Before while(1)"</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"After while(1)"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>打印结果：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 什么都不打印</span></span><br></pre></td></tr></tbody></table></figure>
<p>原因：</p>
<ul>
<li>对于标准输出，输出缓冲区刷新的时机：<ul>
<li>输出缓冲区满</li>
<li>或者遇到换行符<code>\n</code></li>
<li>强制刷新，或者进程结束</li>
</ul>
</li>
</ul>
<p>因此，可以修改为：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 遇到\n刷新</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Before while(1)\n"</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"After while(1)\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>或者修改为：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Before while(1)"</span>);</span><br><span class="line">    <span class="comment">// 强制刷新</span></span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">	<span class="comment">// 或者 fflush(NULL);</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"After while(1)"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
<p>缓冲区的作用：大多数情况下是好事，合并系统调用，增加程序的吞吐量。</p>
<p>缓冲的分类：</p>
<ul>
<li>行缓冲<code>line buffered</code>：针对<strong>标准输出</strong>（终端设备），有换行刷新，缓冲满刷新，强制刷新三种，后两个和全缓冲一致；</li>
<li>全缓冲<code>fully buffered</code>：<strong>默认缓冲机制</strong>（除标准输出【终端设备】，例如重定向到文件），有缓冲满刷新，强制刷新两种，强制刷新例如调用<code>fflush</code>函数，或者进程结束时也会强制刷新；此时换行符仅仅只是个换行符，没有刷新功能；</li>
<li>无缓冲<code>unbuffered</code>：例如<code>stderr</code>，需要立即输出，数据会立即读入内存或者输出到外存文件和设备上；</li>
</ul>
<p><code>setvbuf</code>：定义流 stream 应如何缓冲。理解即可。</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setvbuf</span><span class="params">(FILE *stream, <span class="keyword">char</span> *buffer, <span class="keyword">int</span> mode, <span class="keyword">size_t</span> size)</span></span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>stream</strong> — 这是指向 FILE 对象的指针，该 FILE 对象标识了一个打开的流。</li>
<li><strong>buffer</strong> — 这是分配给用户的缓冲。如果设置为 NULL，该函数会自动分配一个指定大小的缓冲。</li>
<li><strong>mode</strong> — 这指定了文件缓冲的模式：</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">模式</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">_IOFBF</td>
<td style="text-align:left"><strong>全缓冲</strong>：对于输出，数据在缓冲填满时被一次性写入。对于输入，缓冲会在请求输入且缓冲为空时被填充。</td>
</tr>
<tr>
<td style="text-align:left">_IOLBF</td>
<td style="text-align:left"><strong>行缓冲</strong>：对于输出，数据在遇到换行符或者在缓冲填满时被写入，具体视情况而定。对于输入，缓冲会在请求输入且缓冲为空时被填充，直到遇到下一个换行符。</td>
</tr>
<tr>
<td style="text-align:left">_IONBF</td>
<td style="text-align:left"><strong>无缓冲</strong>：不使用缓冲。每个 I/O 操作都被即时写入。buffer 和 size 参数被忽略。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="2-10-getline"><a href="#2-10-getline" class="headerlink" title="2.10 getline"></a>2.10 getline</h3><p>之前介绍的函数，都不能获得<strong>完整的一整行</strong>（有缓冲区大小的限制），而下面介绍的<code>getline</code>函数则可以动态分配内存，当装不下完整一行时，又会申请额外的内存来存储。</p>
<p><code>getline</code>是C++标准库函数，但不是C标准库函数，而是POSIX所定义的标准库函数（在POSIX IEEE Std 1003.1-2008标准出来之前，则只是GNU扩展库里的函数）。在gcc编译器中，对标准库<code>stdio</code>进行了扩展，加入了一个getline函数。</p>
<p><code>getline</code>会生成一个包含一串从输入流读入的字符的字符串，直到以下情况发生会导致生成的此字符串结束：</p>
<ul>
<li>到文件结束</li>
<li>遇到函数的定界符</li>
<li>输入达到最大限度</li>
</ul>
<p>函数原型：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE <span class="comment">// 通常将这种宏写在makefile中，现在的编译器没有了该宏，直接使用即可</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">getline</span><span class="params">(<span class="keyword">char</span> **lineptr, <span class="keyword">size_t</span> *n, FILE *stream)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p><code>lineptr</code>：指向存放该行字符的指针，如果是NULL，则有系统帮助malloc，请在使用完成后free释放。该参数是一个二级指针，因此传参需要一级指针的地址。即函数会把读取到的字符串的首地址存放在一级指针中。</p>
  <figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传参：</span></span><br><span class="line"><span class="keyword">char</span> *ptr;</span><br><span class="line"><span class="comment">// 函数内的实际操作：</span></span><br><span class="line"><span class="comment">// 假设读取到的字符串Hello的首地址为0x000</span></span><br><span class="line">&amp;ptr = <span class="number">0x000</span>; <span class="comment">// 此时ptr就指向了Hello</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><code>n</code>：如果是由系统malloc的指针填0；</p>
</li>
<li><p><code>stream</code>：函数需要读取的FILE流</p>
</li>
<li><p>返回值：成功返回读取的字节数，失败或读完返回<code>-1</code>。</p>
</li>
</ul>
<blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>{</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="comment">// 一定要初始化，否则指针会指向内存中的随机位置</span></span><br><span class="line">    <span class="keyword">char</span> *linebuf = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">size_t</span> linesize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>) {</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Usage...\n"</span>);</span><br><span class="line">    }</span><br><span class="line">    fp = fopen(argv[<span class="number">1</span>], <span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp == <span class="literal">NULL</span>) {</span><br><span class="line">        perror(<span class="string">"fopen()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">        <span class="comment">// 当返回-1时则读完</span></span><br><span class="line">    	<span class="keyword">if</span>(getline(&amp;linebuf, &amp;linesize, fp) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">       	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="built_in">strlen</span>(linebuf));</span><br><span class="line">    }</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="2-11-临时文件"><a href="#2-11-临时文件" class="headerlink" title="2.11 临时文件"></a>2.11 临时文件</h3><p>临时文件产生的问题：</p>
<ul>
<li>如何命名不冲突</li>
<li>如何保证及时销毁</li>
</ul>
<hr>
<p><code>tmpnam</code>：生成并返回一个有效的临时文件名，该文件名之前是不存在的。如果 <strong>str</strong> 为空，则只会返回临时文件名。</p>
<p>存在并发问题，可能会产生两个或多个名字相同的临时文件。</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">tmpnam</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>str</strong> — 这是一个指向字符数组的指针，其中，临时文件名将被存储为 C 字符串。</li>
<li>返回一个指向 C 字符串的指针，该字符串存储了临时文件名。如果 str 是一个空指针，则该指针指向一个内部缓冲区，缓冲区在下一次调用函数时被覆盖。</li>
<li>如果 str 不是一个空指针，则返回 str。如果函数未能成功创建可用的文件名，则返回一个空指针。</li>
</ul>
<hr>
<p><code>tmpfile</code>：以二进制更新模式(<code>wb+</code>)创建临时文件。被创建的临时文件会在流关闭的时候或者在程序终止的时候自动删除。</p>
<p>该文件没有名字（匿名文件）只返回指向FILE的指针，因此不存在命名冲突的问题，同时会自动删除，因此可以及时销毁。</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FILE *<span class="title">tmpfile</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>如果成功，该函数返回一个指向被创建的临时文件的流指针。如果文件未被创建，则返回 NULL。</li>
</ul>
<h2 id="3-系统调用IO"><a href="#3-系统调用IO" class="headerlink" title="3 系统调用IO"></a>3 系统调用IO</h2><p>该节对应<code>APUE</code>的第三章——文件IO</p>
<h3 id="3-1-简介"><a href="#3-1-简介" class="headerlink" title="3.1 简介"></a>3.1 简介</h3><p>UNIX系统的大多数文件IO只需用到5个函数：</p>
<ul>
<li><code>open</code></li>
<li><code>close</code></li>
<li><code>read</code></li>
<li><code>write</code></li>
<li><code>lseek</code></li>
</ul>
<h3 id="3-2-文件描述符"><a href="#3-2-文件描述符" class="headerlink" title="3.2 文件描述符"></a>3.2 文件描述符</h3><h4 id="3-2-1-FILE结构体"><a href="#3-2-1-FILE结构体" class="headerlink" title="3.2.1 FILE结构体"></a>3.2.1 FILE结构体</h4><p>查看<code>stdio.h</code>头文件中，有<code>FILE</code>结构体的定义：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//stdio.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">iobuf</span> {</span></span><br><span class="line">    <span class="keyword">char</span>*  _ptr;        <span class="comment">//文件输入的下一个位置</span></span><br><span class="line">    <span class="keyword">int</span>    _cnt;        <span class="comment">//当前缓冲区的相对位置</span></span><br><span class="line">    <span class="keyword">char</span>*  _base;       <span class="comment">//文件初始位置</span></span><br><span class="line">    <span class="keyword">int</span>    _flag;       <span class="comment">//文件标志</span></span><br><span class="line">    <span class="keyword">int</span>    _file;       <span class="comment">//文件有效性</span></span><br><span class="line">    <span class="keyword">int</span>    _charbuf;    <span class="comment">//缓冲区是否可读取</span></span><br><span class="line">    <span class="keyword">int</span>    _bufsiz;     <span class="comment">//缓冲区字节数</span></span><br><span class="line">    <span class="keyword">char</span>*  _tmpfname;   <span class="comment">//临时文件名</span></span><br><span class="line">} FILE;</span><br></pre></td></tr></tbody></table></figure>
<p>其中<code>_file</code>就是文件描述符。</p>
<h4 id="3-2-2-文件描述符"><a href="#3-2-2-文件描述符" class="headerlink" title="3.2.2 文件描述符"></a>3.2.2 文件描述符</h4><p>文件描述符（<code>fd</code>，<code>file descriptor</code>）是文件IO（也系统IO）中贯穿始终的类型。如下图所示：</p>
<p><a href="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221201164844626.png" data-fancybox="gallery" data-caption="image-20221201164844626" data-thumb="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221201164844626.png"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221201164844626.png" alt="image-20221201164844626"></a></p>
<ul>
<li>当某一个进程执行系统调用<code>open</code>函数，会创建一个结构体，该结构体类似于FILE结构体，其中最基本的成员有一个指针<code>pos</code>，用于指向<code>inode</code>文件的某一个位置；</li>
<li><p>同时，该进程会维护一个数组（文件描述符表），该数组存储上述结构体的地址，而<strong>数组下标就是文件描述符</strong><code>fd</code>，即<strong>文件描述符的本质就是一个整型数</strong>；</p>
<ul>
<li>该数组默认大小为1024，即可以打开的最大文件数量为1024，但可以设置<code>ulimit</code>来更改数组大小；注意该数组和对应产生的结构体只存在于这个进程空间内，而不是进程间共享；</li>
<li>当调用<code>open</code>函数时，系统会自动打开三个流<code>stdin</code>，<code>stdout</code>和<code>stderr</code>，这三个流分别占据该数组的<code>0,1,2</code>号位置；</li>
<li>结构体FILE中的成员<code>_file</code>就是整型数组下标<code>fd</code>，即文件描述符</li>
<li>每打开一个新文件，则占用一个数组空间，而且是空闲的最小的数组下标。即文件描述符优先使用当前可用范围内<strong>最小</strong>的。同一个文件可以被多次打开，但是每打开一次都需要一个新的文件描述符和新的结构体，例如图中的结构体1和结构体2，指向了同一个inode；</li>
</ul>
</li>
<li><p>执行系统调用<code>close</code>时，就将对应fd下标的数组空间清除掉，并清除该地址指向的结构体；</p>
</li>
<li>结构体中有一个成员用于记录<strong>引用计数</strong>，例如图中，将5号位置的<code>0x006</code>地址复制一份存储在6号位置，此时有两个指针指向了同一个结构体3，此时结构体3的引用计数为2，当5号指针<code>free</code>时，结构体3的引用计数减1为1，不为0，则不会释放掉，否则6号位置的指针将成为<strong>野指针</strong>；</li>
</ul>
<h3 id="3-3-open和close"><a href="#3-3-open和close" class="headerlink" title="3.3 open和close"></a>3.3 open和close</h3><h4 id="3-3-1-文件权限"><a href="#3-3-1-文件权限" class="headerlink" title="3.3.1 文件权限"></a>3.3.1 文件权限</h4><h5 id="①-rwx"><a href="#①-rwx" class="headerlink" title="① rwx"></a>① rwx</h5><p>Linux下一切皆文件，不同的用户对文件拥有不同的权限。</p>
<p>文件具有三种权限：</p>
<figure class="highlight plaintext"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">plaintext</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rwx    可读可写可执行,转换为数字就是421</span><br></pre></td></tr></tbody></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>针对文件</th>
<th>针对目录</th>
</tr>
</thead>
<tbody>
<tr>
<td>r</td>
<td>是否可以查看文件内容</td>
<td>是否能够列出<code>ls</code>目录内容</td>
</tr>
<tr>
<td>w</td>
<td>是否可以编辑文件内容</td>
<td>是否能够创建、删除、复制、移动文档</td>
</tr>
<tr>
<td>x</td>
<td>是否能够执行该文件</td>
<td>是否可以进入目录和获得目录下文件的列表，要对目录下存在的文件进行读取和修改，必须要能进入目录，所以必须要目录有执行权限</td>
</tr>
</tbody>
</table>
</div>
<h5 id="②-文件属性"><a href="#②-文件属性" class="headerlink" title="② 文件属性"></a>② 文件属性</h5><p>查看当前目录下的所有文件的属性：</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ll</span><br></pre></td></tr></tbody></table></figure>
<p><a href="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221202132740517.png" data-fancybox="gallery" data-caption="image-20221202132740517" data-thumb="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221202132740517.png"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221202132740517.png" alt="image-20221202132740517"></a></p>
<p>或者可以查看单个文件权限：</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ll atoi</span><br></pre></td></tr></tbody></table></figure>
<p>基本的文件属性格式如下：</p>
<figure class="highlight plaintext"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">plaintext</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类型 权限 链接数 属主 属组 大小 修改日期 文件名</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>类型和权限：<ul>
<li>第1列表示文件的类型：<code>dcb-lsp</code><ul>
<li><code>d</code>：目录</li>
<li><code>-</code>：普通文件</li>
<li><code>l</code>：软链接（类似Windows的快捷方式）</li>
<li><code>b</code>：块设备文件（例如硬盘、光驱等）</li>
<li><code>p</code>：管道文件</li>
<li><code>c</code>：字符设备文件（例如屏幕等串口设备）</li>
<li><code>s</code>：套接口文件</li>
</ul>
</li>
<li>第2至10列为文件或目录的权限，分为3组：<ul>
<li>拥有者权限<code>owner</code>：文件和文件目录的所有者</li>
<li>所属组<code>group</code>：文件和文件目录的所有者所在的组的其他用户</li>
<li>其它用户<code>other</code>：不属于上面的两个的用户</li>
</ul>
</li>
</ul>
</li>
<li>链接数：有多少文件名链接到此节点（i-node）；每个文件都会将它的权限与属性记录到文件系统的i-node中，不过我们使用的目录树却是使
用文件名来记录，因此每个文件名就会连接到一个i-node，这个属性记录的就是有多少不同的文件名链接到相同的一个i-node号码。</li>
</ul>
<p>例如第一行的文件属性为：</p>
<figure class="highlight plaintext"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">plaintext</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-rwxr-xr-x 1 root root 8496 Nov 28 14:54 atoi</span><br></pre></td></tr></tbody></table></figure>
<p>则为普通文件，拥有者有读写和执行权限，而所属组用户和其他用户只有读取和执行权限，没有写权限；属主和属组均为<code>root</code>；</p>
<h5 id="③-umask"><a href="#③-umask" class="headerlink" title="③ umask"></a>③ umask</h5><p>Linux具有默认权限：</p>
<ul>
<li><p>一个目录被创建，默认权限是<code>drwxrwxrwx</code>，即777</p>
</li>
<li><p>一个普通文件被创建，默认权限是<code>-rw-rw-rw-</code>，即666</p>
</li>
</ul>
<p>但实际上所创建的文件和目录，看到的权限往往不是上面这个值。原因就是创建文件或目录的时候还要受到 <code>umask</code> 的影响。umask值表明了需要从默认权限中去掉哪些权限来成为最终的默认权限值。</p>
<p>查看umask的值：</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng io]<span class="comment"># umask</span></span><br><span class="line">0002</span><br></pre></td></tr></tbody></table></figure>
<p>可以看到umask值为0002</p>
<ul>
<li>第一个0与特殊权限（特殊权限的内容参见<code>6.6.2节</code>）有关，后三位<code>002</code>则与普通权限<code>rwx</code>有关</li>
<li><code>002</code>中第一个0与拥有者权限有关，表示从拥有者权限减0，也就是权限不变，所以文件的创建者的权限就是是默认权限<code>rw</code>（<code>6 - 0 = 0</code>）</li>
<li><code>002</code>中第二个0与组权限有关，表示从组的权限减0，所以组的权限也保持默认权限（rw）</li>
<li><code>002</code>最后一位2则与系统中其他用户的权限有关，由于w=2，所以需要从其他用户默认权限<code>rw</code>减去2，也就是去掉写（w）权限，则其他人的权限为rw - w = r（<code>6 - 2 = 4</code>，对应r权限）</li>
<li>最终，创建文件的最终默认权限为 <code>-rw-rw-r--</code> </li>
</ul>
<p>同理目录权限的计算也是如此。</p>
<p>也可以临时更改umask的值：</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng io]<span class="comment"># umask 027</span></span><br><span class="line">[root@HongyiZeng io]<span class="comment"># umask</span></span><br><span class="line">027</span><br></pre></td></tr></tbody></table></figure>
<p>即去掉所属组用户的写权限，去掉其他用户的所有权限。</p>
<p>如果需要永久更改umask的话，需要修改文件<code>/etc/bashrc</code>中的umask值：</p>
<p><a href="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221202134734807.png" data-fancybox="gallery" data-caption="image-20221202134734807" data-thumb="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221202134734807.png"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221202134734807.png" alt="image-20221202134734807"></a></p>
<h4 id="3-3-2-open"><a href="#3-3-2-open" class="headerlink" title="3.3.2 open"></a>3.3.2 open</h4><p>安装<code>man</code>手册：</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y man-pages</span><br></pre></td></tr></tbody></table></figure>
<hr>
<p><code>open</code>用于打开或创建一个文件或者设备。</p>
<p>所在头文件：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br></pre></td></tr></tbody></table></figure>
<p>函数原型1：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>将准备打开的文件或是设备的名字作为参数path传给函数，flags用来指定文件访问模式。</li>
<li>open系统调用成功返回一个新的文件描述符，失败返回<code>-1</code>。</li>
</ul>
<p>其中，flags是由必需文件访问模式和可选模式一起构成的(通过按位或<code>|</code>)：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>必需部分</th>
<th>可选部分（只列出常用的）</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>O_RDONLY</code>：以只读方式打开</td>
<td><code>O_CREAT</code>：按照参数<code>mode</code>给出的访问模式创建文件</td>
</tr>
<tr>
<td><code>O_WRONLY</code>：以只写方式打开</td>
<td><code>O_EXCL</code>：与<code>O_CREAT</code>一起使用，确保创建出文件，避免两个程序同时创建同一个文件，如文件存在则open调用失败</td>
</tr>
<tr>
<td><code>O_RDWR</code>：以读写方式打开</td>
<td><code>O_APPEND</code>：把写入数据追加在文件的末尾</td>
</tr>
<tr>
<td></td>
<td><code>O_TRUNC</code>：把文件长度设置为0，丢弃原有内容</td>
</tr>
<tr>
<td></td>
<td><code>O_NONBLOCK</code>：以非阻塞模式打开文件</td>
</tr>
</tbody>
</table>
</div>
<p>其中，对于可选部分，又分为文件创建选项和文件状态选项：</p>
<ul>
<li>文件创建选项：<code>O_CREAT</code>，<code>O_EXCL</code>，<code>O_NOCTTY</code>，<code>O_TRUNC</code></li>
<li>文件状态选项：除文件创建选项之外的选项</li>
</ul>
<blockquote>
<p>fopen和open的文件访问模式的联系</p>
</blockquote>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">r -&gt; O_RDONLY <span class="comment">// 只读存在的文件</span></span><br><span class="line">r+ -&gt; O_RDWR <span class="comment">// 读写存在的文件</span></span><br><span class="line">w -&gt; O_WRONLY|O_CREAT|O_TRUNC <span class="comment">// 只写，并且有则清空，无则创建</span></span><br><span class="line">w+ -&gt; O_RDWR|O_CREAT|O_TRUNC <span class="comment">// 读写，并且有则清空，无则创建</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></tbody></table></figure>
<hr>
<p>函数原型2：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> *path, <span class="keyword">int</span> flags, <span class="keyword">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p>在第一种调用方式上，加上了第三个参数<code>mode</code>，主要是搭配<code>O_CREAT</code>使用，这个参数规定了属主、同组和其他人对文件的文件操作权限。只列出部分：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字段</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>S_IRUSR</code></td>
<td>读权限</td>
</tr>
<tr>
<td><code>S_IWUSR</code></td>
<td>写权限 ——文件属主</td>
</tr>
<tr>
<td><code>S_IXUSR</code></td>
<td>执行权限</td>
</tr>
</tbody>
</table>
</div>
<p>可以用数字设定法：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>数字</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>无权限</td>
</tr>
<tr>
<td>1</td>
<td>x</td>
</tr>
<tr>
<td>2</td>
<td>w</td>
</tr>
<tr>
<td>4</td>
<td>r</td>
</tr>
</tbody>
</table>
</div>
<p>注意mode还要和umask计算才能得出最终的权限；</p>
<p>例如：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> fd = open(<span class="string">"./file.txt"</span>,O_WRONLY | O_CREAT, <span class="number">0600</span>);</span><br></pre></td></tr></tbody></table></figure>
<p>创建一个普通文件，权限为<code>0600</code>，拥有者有读写权限，组用户和其他用户无权限。</p>
<blockquote>
<p>补充：变参函数</p>
</blockquote>
<p>变参数函数的原型声明为：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">type <span class="title">VAFunction</span><span class="params">(type arg1, type arg2, ...)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p>变参函数可以接受不同类型的参数，也可以接受不同个数的参数。</p>
<p>参数可以分为两部分：个数确定的固定参数和个数可变的可选参数。函数至少需要一个固定参数，固定参数的声明和普通函数一样；可选参数由于个数不确定，声明时用 <code>...</code> 表示。固定参数和可选参数共同构成一个函数的参数列表。</p>
<p>以<code>printf</code>为例，它就是一个变参函数：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span>{    </span><br><span class="line">    <span class="keyword">int</span> i;    </span><br><span class="line">    <span class="keyword">int</span> len;    </span><br><span class="line">    va_list args; <span class="comment">/* va_list 即 char * */</span></span><br><span class="line">    </span><br><span class="line">    va_start(args, fmt);    </span><br><span class="line">    <span class="comment">/* 内部使用了 va_arg() */</span></span><br><span class="line">    len = <span class="built_in">vsprintf</span>(g_PCOutBuf,fmt,args);</span><br><span class="line">    </span><br><span class="line">    va_end(args);    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(g_PCOutBuf); i++)</span><br><span class="line">    {</span><br><span class="line">        putc(g_PCOutBuf[i]);</span><br><span class="line">    }    </span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="3-3-3-close"><a href="#3-3-3-close" class="headerlink" title="3.3.3 close"></a>3.3.3 close</h4><p><code>close</code>：关闭一个文件描述符</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p>返回 0 表示成功，或者 -1 表示有错误发生，并设值<code>errno</code>；</p>
<h3 id="3-4-read，write和lseek"><a href="#3-4-read，write和lseek" class="headerlink" title="3.4 read，write和lseek"></a>3.4 read，write和lseek</h3><p><code>read</code>所在头文件和函数原型：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>从与文件描述符fd相关联的文件中读取前count字节的内容，并且写入到数据区buf中</li>
<li>read系统调用返回的是实际读入的字节数，发生错误返回<code>-1</code></li>
</ul>
<p><code>write</code>所在头文件和函数原型：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>把缓存区buf中的前count字节写入到与文件描述符fd有关的文件中</li>
<li>write系统调用返回的是实际写入到文件中的字节数，发生错误返回<code>-1</code>，注意返回0不是发生错误，而是写入的字节数为0</li>
</ul>
<p><code>lseek</code>所在头文件和函数原型：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">off_t</span> <span class="title">lseek</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset, <span class="keyword">int</span> whence)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p><code>lseek</code>设置文件位置为给定的偏移 <strong>offset</strong>，参数 offset 意味着从给定的 <strong>whence</strong> 位置查找的字节数。</p>
<p><code>whence</code>取值：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字段</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>SEEK_SET</code></td>
<td>文件开头</td>
</tr>
<tr>
<td><code>SEEK_END</code></td>
<td>文件末尾</td>
</tr>
<tr>
<td><code>SEEK_CUR</code></td>
<td>文件当前位置</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>代码示例</p>
</blockquote>
<p>用系统调用io实现<code>mycpy</code>的功能。</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFSIZE 1024 <span class="comment">// 缓冲区大小</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>{</span><br><span class="line">    <span class="comment">// 源文件和目标文件的文件描述符</span></span><br><span class="line">    <span class="keyword">int</span> sfd, dfd;</span><br><span class="line">    <span class="comment">// 读写缓冲</span></span><br><span class="line">    <span class="keyword">char</span> buf[BUFSIZE];</span><br><span class="line">    <span class="comment">// len：读文件的返回字节数</span></span><br><span class="line">    <span class="comment">// ret：写文件的返回字节数</span></span><br><span class="line">    <span class="comment">// pos：写文件的当前位置</span></span><br><span class="line">    <span class="keyword">int</span> len, ret, pos;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">3</span>) {</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Usage...\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 以只读方式打开文件，打开文件失败</span></span><br><span class="line">    <span class="keyword">if</span>((sfd = open(argv[<span class="number">1</span>], O_RDONLY)) &lt; <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">"open()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 以只读方式打开文件，有则清空，无则创建</span></span><br><span class="line">    <span class="comment">// 打开文件失败</span></span><br><span class="line">    <span class="keyword">if</span>((dfd = open(argv[<span class="number">2</span>], O_WRONLY|O_CREAT|O_TRUNC, <span class="number">0600</span>)) &lt; <span class="number">0</span>) {</span><br><span class="line">        close(sfd);</span><br><span class="line">        perror(<span class="string">"open()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">if</span>((len = read(sfd, buf, BUFSIZE)) &lt; <span class="number">0</span>) {</span><br><span class="line">            perror(<span class="string">"read()"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 读完文件</span></span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        pos = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 防止读到的字节没有完全写入文件</span></span><br><span class="line">        <span class="comment">// 保证读多少，就写多少</span></span><br><span class="line">        <span class="keyword">while</span>(len &gt; <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">if</span>((ret = write(dfd, buf + pos, len)) &lt; <span class="number">0</span>) {</span><br><span class="line">                perror(<span class="string">"write()"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">            pos += ret;</span><br><span class="line">            len -= ret;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">	<span class="comment">// 关闭文件描述符</span></span><br><span class="line">    close(dfd);</span><br><span class="line">    close(sfd);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="3-5-IO效率"><a href="#3-5-IO效率" class="headerlink" title="3.5 IO效率"></a>3.5 IO效率</h3><ul>
<li><strong>文件I/O：</strong>文件I/O又称为无缓冲IO，低级磁盘I/O，遵循POSIX相关标准。任何兼容POSIX标准的操作系统上都支持文件I/O。</li>
<li><strong>标准I/O：</strong>标准I/O是ANSI 
C建立的一个标准I/O模型，又称为高级磁盘I/O，是一个标准函数包和stdio.h头文件中的定义，具有一定的可移植性。标准I/O库处理很多细节。
例如缓存分配，以优化长度执行I/O等。标准的I/O提供了三种类型的缓存（行缓存、全缓存和无缓存）。</li>
</ul>
<p>Linux 中使用的是<code>GLIBC</code>，它是标准C库的超集。不仅包含ANSI C中定义的函数，还包括POSIX标准中定义的函数。因此，Linux 下既可以使用标准I/O，也可以使用文件I/O。</p>
<p>缓存是内存上的某一块区域。缓存的一个作用是<strong>合并系统调用</strong>，即将多次的标准IO操作合并为一个系统调用操作。</p>
<p>文件IO不使用缓存，每次调用读写函数时，从用户态切换到内核态，对磁盘上的实际文件进行读写操作，因此<strong>响应速度快</strong>，坏处是频繁的系统调用会<strong>增加系统开销（用户态和内核态来回切换）</strong>，例如调用<code>write</code>写入一个字符时，磁盘上的文件中就多了一个字符。</p>
<p>标准IO使用缓存，未刷新缓冲前的多次读写时，实际上操作的是内存上的缓冲区，与磁盘上的实际文件无关，直到刷新缓冲时，才调用一次文件IO，从用户态切换到内核态，对磁盘上的实际文件进行操作。因此标准IO<strong>吞吐量大</strong>，相应的响应时间比文件IO长。但是差别不大，<strong>建议使用标准IO来操作文件</strong>。</p>
<hr>
<p>两种IO可以相互转化：</p>
<p><code>fileno</code>：返回结构体FILE的成员<code>_file</code>，即文件描述符。<code>标准IO-&gt;文件IO</code></p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fileno</span><span class="params">(FILE *stream)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p><code>fdopen</code>：通过文件描述符fd，返回FILE结构体。<code>文件IO-&gt;标准IO</code></p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FILE *<span class="title">fdopen</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *mode)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<hr>
<p>注意：即使对同一个文件，也不要混用两种IO，否则容易发生错误。</p>
<p>原因：FILE结构体的<code>pos</code>和进程中的结构体的<code>pos</code>基本上不一样。</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FILE *fp;</span><br><span class="line"><span class="comment">// 连续写入两个字符</span></span><br><span class="line">fputc(fp) -&gt; pos++</span><br><span class="line">fputc(fp) -&gt; pos++    </span><br></pre></td></tr></tbody></table></figure>
<p>但是，进程维护的结构体中的<code>pos</code>并未加2；只有刷新缓冲区时，该<code>pos</code>才会加2；</p>
<blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">'a'</span>);</span><br><span class="line">    write(<span class="number">1</span>, <span class="string">"b"</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">'a'</span>);</span><br><span class="line">    write(<span class="number">1</span>, <span class="string">"b"</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">'a'</span>);</span><br><span class="line">    write(<span class="number">1</span>, <span class="string">"b"</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>打印结果：</p>
<figure class="highlight plaintext"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">plaintext</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bbbaaa</span><br></pre></td></tr></tbody></table></figure>
<p>解析：遇到文件IO则立即输出，遇到标准IO，则需要等待缓冲区刷新的时机，这里是进程结束后，进行了强制刷新，将3个a字符输出到终端上。</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">'a'</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    write(<span class="number">1</span>, <span class="string">"b"</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">'a'</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    write(<span class="number">1</span>, <span class="string">"b"</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">'a'</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    write(<span class="number">1</span>, <span class="string">"b"</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>打印结果：</p>
<figure class="highlight plaintext"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">plaintext</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ababab</span><br></pre></td></tr></tbody></table></figure>
<hr>
<p><code>strace</code>命令能够显示所有由用户空间程序发出的系统调用。</p>
<p>以上面第一个程序为例：</p>
<figure class="highlight plaintext"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">plaintext</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace ./ab</span><br></pre></td></tr></tbody></table></figure>
<p>打印结果：</p>
<p><a href="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221202160702527.png" data-fancybox="gallery" data-caption="image-20221202160702527" data-thumb="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221202160702527.png"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221202160702527.png" alt="image-20221202160702527"></a></p>
<blockquote>
<p>BUFSIZE对IO效率的影响</p>
</blockquote>
<p><a href="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221203120510389.png" data-fancybox="gallery" data-caption="image-20221203120510389" data-thumb="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221203120510389.png"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221203120510389.png" alt="image-20221203120510389"></a></p>
<p>图中用户CPU时间是程序在用户态下的执行时间；系统CPU时间是程序在内核态下的执行时间；时钟时间是两个时间的总和；</p>
<p>BUFSIZE受栈大小的影响；此测试所用的文件系统是Linux ext4文件系统，其磁盘块长度为<code>4096</code>字节。这也证明了图中系统 CPU 时间的几个最小值差不多出现在BUFFSIZE 为4096 及以后的位置，继续增加缓冲区长度对此时间几乎没有影响。</p>
<h3 id="3-6-C程序的内存空间布局"><a href="#3-6-C程序的内存空间布局" class="headerlink" title="3.6 C程序的内存空间布局"></a>3.6 C程序的内存空间布局</h3><blockquote>
<p>补充：内存地址和内存空间</p>
</blockquote>
<p>内存地址是一个编号，通常由16进制表示，它代表一个内存空间。在计算机中存储器的容量是以字节为基本单位的，也就是说<strong>一个内存地址代表一个字节（8bit）的存储空间</strong>，即<strong>按字节寻址</strong>。</p>
<p>假设一个int类型的变量x占用4个字节，则会占用4个连续的内存空间，x的内存地址则为第一个内存空间的地址。</p>
<p>对于32位操作系统，内存地址长度为32位，则可以表示2的32次方个内存空间（可寻址空间），即4GB；</p>
<p>计算：<code>2^32 * 1B = 2^32B = 2^22 KB = 2^12 MB = 2^2 GB = 4GB</code></p>
<p>对于64位操作系统，内存地址长度为64位，则可以表示2的64次方个内存空间（<code>16777216TB</code>）；但实际上，主板和CPU的限制导致一般的电脑所支持的内存最大只有16GB而已。</p>
<hr>
<p>C程序（例如<code>a.out</code>）运行时会被加载入内存中，而这个内存一般分为五个分区：栈区、堆区、数据区、常量区、代码区。</p>
<p><a href="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221202212432432.png" data-fancybox="gallery" data-caption="image-20221202212432432" data-thumb="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221202212432432.png"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221202212432432.png" alt="image-20221202212432432"></a></p>
<p><a href="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221202214105130.png" data-fancybox="gallery" data-caption="image-20221202214105130" data-thumb="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221202214105130.png"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221202214105130.png" alt="image-20221202214105130"></a></p>
<h4 id="3-6-1-动态区"><a href="#3-6-1-动态区" class="headerlink" title="3.6.1 动态区"></a>3.6.1 动态区</h4><p>动态区的内容会根据执行情况而动态变化。</p>
<h5 id="①-栈区"><a href="#①-栈区" class="headerlink" title="① 栈区"></a>① 栈区</h5><p>栈（stack）是用户存放程序临时创建的<strong>局部变量</strong>，在函数被调用时，其<strong>参数</strong>也会被压入发起调用的进程栈中，并且等调用结束后，<strong>函数的返回值</strong>也会被存放在回栈中。</p>
<ul>
<li><strong>栈的大小</strong>：最大大小由编译时确定，不会太大。</li>
<li><strong>释放和分配</strong>：由编译器自动分配释放，由操作系统自动管理，无须手动管理。</li>
<li><strong>栈区地址</strong>：由高地址向低地址生长。</li>
<li>若越界访问则会出现<strong>段错误</strong>（Segmentation Fault）</li>
<li>若多次递归调用增加栈帧导致越界则会出现<strong>栈溢出</strong>（Stack Overflow）</li>
</ul>
<p>栈的大小可以通过<code>ulimit</code>命令查看：</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -s <span class="comment"># 只查看stack的大小</span></span><br><span class="line"><span class="built_in">ulimit</span> -a <span class="comment"># 查看当前所有的资源限制，stack 字段，单位Kbytes</span></span><br></pre></td></tr></tbody></table></figure>
<p><a href="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221202212135917.png" data-fancybox="gallery" data-caption="image-20221202212135917" data-thumb="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221202212135917.png"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221202212135917.png" alt="image-20221202212135917"></a></p>
<p>可以看到栈的大小默认为8192KB，即8M；</p>
<blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> x =<span class="number">10</span>;  <span class="comment">// 栈存储</span></span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">20</span>; <span class="comment">// 栈存储</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h5 id="②-堆区"><a href="#②-堆区" class="headerlink" title="② 堆区"></a>② 堆区</h5><ul>
<li><strong>堆区存放</strong>：程序运行中<strong>动态存储分配</strong>的空间</li>
<li><strong>堆区大小</strong>：视内存大小而定，由程序员进行分配。</li>
<li><strong>堆区地址</strong>：由低地址向高地址生长</li>
</ul>
<blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> x =<span class="number">10</span>;  <span class="comment">// 栈分配</span></span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">20</span>; <span class="comment">// 栈分配</span></span><br><span class="line">    <span class="keyword">char</span> *p = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">256</span>); <span class="comment">//堆分配</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="3-6-2-静态区"><a href="#3-6-2-静态区" class="headerlink" title="3.6.2 静态区"></a>3.6.2 静态区</h4><p>静态区的内容在整个程序的生命周期内都存在，由编译器在编译的时候分配。</p>
<h5 id="①-数据区"><a href="#①-数据区" class="headerlink" title="① 数据区"></a>① 数据区</h5><p>根据数据是否被初始化又分为：<code>bss</code>段与<code>data</code>段。</p>
<ul>
<li>未初始化数据段（<code>bss</code>）</li>
</ul>
<p>通常将此段称为<code>bss</code>段，这一名称来源于早期汇编程序的一个操作符，意思是<code>block started by symbol（由符号开始的块）</code>。</p>
<p><strong>存放未初始化的全局变量</strong>，属于静态内存分配。在程序开始执行之前，<strong>内核</strong>将此段初始化为0。</p>
<blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> sum[<span class="number">1000</span>]; <span class="comment">// 此变量存放在非初始化数据段中</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>已初始化数据段（<code>data</code>）</li>
</ul>
<p><strong>存放已初始化的全局变量和静态变量</strong>，属于静态内存分配，其内容由<strong>程序</strong>初始化。</p>
<blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> PI= <span class="number">3.14f</span>; <span class="comment">// 此变量以初值存放在初始化数据段中</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h5 id="②-常量区"><a href="#②-常量区" class="headerlink" title="② 常量区"></a>② 常量区</h5><p>常量区存放字符串常量、const修饰的全局变量。程序运行期间，常量区的内容不可以被修改。</p>
<h5 id="③-代码区"><a href="#③-代码区" class="headerlink" title="③ 代码区"></a>③ 代码区</h5><p>代码区（<code>text</code>），又叫：正文段、代码段。</p>
<p>通常是用来存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读，某些架构也允许代码段为可写，即允许修改程序。</p>
<h4 id="3-6-3-栈的地址测试"><a href="#3-6-3-栈的地址测试" class="headerlink" title="3.6.3 栈的地址测试"></a>3.6.3 栈的地址测试</h4><figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">10</span>; <span class="comment">// 栈分配</span></span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">10</span>; <span class="comment">// 栈分配</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *p = &amp;x; <span class="comment">// 栈分配</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&amp;x = %p\n"</span>, &amp;x);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&amp;y = %p\n"</span>, &amp;y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&amp;p = %p\n"</span>, &amp;p);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>打印结果：</p>
<figure class="highlight plaintext"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">plaintext</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp;x = 0x7ffd1ce3e33c</span><br><span class="line">&amp;y = 0x7ffd1ce3e338</span><br><span class="line">&amp;p = 0x7ffd1ce3e330</span><br></pre></td></tr></tbody></table></figure>
<p>可以看到x，y，p的地址从高向低依次排列。</p>
<h4 id="3-6-4-堆的地址测试"><a href="#3-6-4-堆的地址测试" class="headerlink" title="3.6.4 堆的地址测试"></a>3.6.4 堆的地址测试</h4><figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *p = &amp;x;</span><br><span class="line">    <span class="keyword">char</span> *q = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">256</span> * <span class="keyword">sizeof</span>(<span class="keyword">char</span>)); <span class="comment">// 堆上分配</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&amp;x = %p\n"</span>, &amp;x);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&amp;y = %p\n"</span>, &amp;y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&amp;p = %p\n"</span>, &amp;p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&amp;q = %p\n"</span>, &amp;q);</span><br><span class="line">	</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>打印结果：</p>
<figure class="highlight plaintext"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">plaintext</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&amp;x = 0x7ffd4ab330fc</span><br><span class="line">&amp;y = 0x7ffd4ab330f8</span><br><span class="line">&amp;p = 0x7ffd4ab330f0</span><br><span class="line">&amp;q = 0x7ffd4ab330e8</span><br></pre></td></tr></tbody></table></figure>
<p>可以看到分配在堆区的q的地址在其他三个的低处，且距离较远。</p>
<h4 id="3-6-5-静态区演示"><a href="#3-6-5-静态区演示" class="headerlink" title="3.6.5 静态区演示"></a>3.6.5 静态区演示</h4><figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// 数据区：data段</span></span><br><span class="line"><span class="keyword">char</span> m = <span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">char</span> n = <span class="string">'a'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据区：bss段</span></span><br><span class="line"><span class="keyword">char</span> arr1[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据区：data段</span></span><br><span class="line"><span class="keyword">char</span> <span class="keyword">static</span> MAX = <span class="string">'a'</span>;</span><br><span class="line"><span class="comment">// 数据区：bss段</span></span><br><span class="line"><span class="keyword">char</span> <span class="keyword">static</span> MIN;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 栈区</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 常量区</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> z = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 数据区：data段</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> a = <span class="string">'a'</span>;</span><br><span class="line">    <span class="comment">// 数据区：bss段</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> b;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// "Hello World"在常量区</span></span><br><span class="line">    <span class="comment">// p在栈区</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *p = <span class="string">"Hello World"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// "123456"和arr均在栈区，且地址相同</span></span><br><span class="line">    <span class="keyword">char</span> arr2[] = <span class="string">"123456"</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    test();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="3-7-文件共享"><a href="#3-7-文件共享" class="headerlink" title="3.7 文件共享"></a>3.7 文件共享</h3><p>如果两个独立进程各自打开了同一文件：</p>
<p><a href="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221203121019961.png" data-fancybox="gallery" data-caption="image-20221203121019961" data-thumb="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221203121019961.png"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221203121019961.png" alt="image-20221203121019961"></a></p>
<ul>
<li>在完成每个write后，在<strong>文件表项（即类似于FILE的结构体）</strong>中的当前文件偏移量即增加所写入的字节数。如果这导致当前文件偏移量超出了当前文件长度，则将i节点表项中的当前文件长度设置为当前文件偏移量（也就是该文件加长了）。</li>
<li>如果用<code>O_APPEND</code>标志打开一个文件，则相应标志也被设置到文件表项的<strong>文件状态标志</strong>中。每次对这种具有追加写标志的文件执行写操作时，文件表项中的当前文件偏移量首先会被设置为i节点表项中的文件长度。这就使得每次写入的数据都追加到文件的当前尾端处。</li>
<li>若一个文件用<code>lseek</code>定位到文件当前的尾端，则文件表项中的当前文件偏移量被设置为i节点表项中的当前文件长度。<code>lseek</code>函数只修改文件表项中的当前文件偏移量，不进行任何I/O操作。</li>
</ul>
<p>可能有多个文件描述符指向同一个文件表项（例如使用dup），对于多个进程读取同一文件都能正确工作。每个进程都有它自己的文件表项，其中也有它自己的当前文件偏移量。但是，当多个进程<strong>写同一文件</strong>时，则可能产生预想不到的结果。为了说明如何避免这种情况，需要理解<strong>原子操作</strong>的概念。</p>
<p>原子操作：不可分割的操作；</p>
<p>原子操作的作用：解决竞争和冲突；</p>
<h3 id="3-8-dup和dup2"><a href="#3-8-dup和dup2" class="headerlink" title="3.8 dup和dup2"></a>3.8 dup和dup2</h3><p><code>dup</code>函数用于复制文件描述符，重定向输入输出。</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup</span><span class="params">(<span class="keyword">int</span> oldfd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup2</span><span class="params">(<span class="keyword">int</span> oldfd, <span class="keyword">int</span> newfd)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p>返回值：</p>
<ul>
<li>成功：<ul>
<li>dup函数返回当前系统可用的<strong>最小整数值</strong>，并且该描述符对应的文件与参数描述符<code>oldfd</code>所对应的文件一致，即指向同一个结构体；</li>
<li>dup2函数返回第一个<code>不小于newfd</code>的整数值，分两种情况：<ul>
<li>如果newfd已经打开，则先将其关闭，再指向文件描述符oldfd的结构体；</li>
<li>如果newfd等于oldfd，则什么也不做；</li>
</ul>
</li>
</ul>
</li>
<li>失败：dup和dup2函数均返回<code>-1</code>，并设置errno。</li>
</ul>
<blockquote>
<p>代码示例</p>
</blockquote>
<p>需求：将<code>puts</code>重定向到一个文件中</p>
<ul>
<li>方法1：</li>
</ul>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FNAME <span class="meta-string">"/tmp/out"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    close(<span class="number">1</span>); <span class="comment">// 关闭stdout，使描述符1空闲</span></span><br><span class="line">    <span class="keyword">if</span>((fd = open(FNAME, O_WRONLY|O_CREAT|O_TRUNC, <span class="number">0600</span>)) &lt; <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">"open()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Hello World"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>结果：</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng sysio]<span class="comment"># ./dup</span></span><br><span class="line">[root@HongyiZeng sysio]<span class="comment"># cat /tmp/out</span></span><br><span class="line">Hello World</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>方法2：使用<code>dup</code></li>
</ul>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FNAME <span class="meta-string">"/tmp/out"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((fd = open(FNAME, O_WRONLY|O_CREAT|O_TRUNC, <span class="number">0600</span>)) &lt; <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">"open()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 关闭stdout</span></span><br><span class="line">    close(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 复制fd，让其占据1的描述符</span></span><br><span class="line">    dup(fd);</span><br><span class="line">    <span class="comment">// 关闭fd</span></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Hello World"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>图示：</p>
<p><a href="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221203125442239.png" data-fancybox="gallery" data-caption="image-20221203125442239" data-thumb="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221203125442239.png"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221203125442239.png" alt="image-20221203125442239"></a></p>
<p>注意结构体中有引用计数，当<code>fd=3</code>被关闭时，还有<code>fd=1</code>指向这个结构体，因此结构体不会被销毁掉。存在并发问题。</p>
<ul>
<li>方法3：使用<code>dup2</code></li>
</ul>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FNAME <span class="meta-string">"/tmp/out"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((fd = open(FNAME, O_WRONLY|O_CREAT|O_TRUNC, <span class="number">0600</span>)) &lt; <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">"open()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 如果fd = 1，则什么也不做，返回fd</span></span><br><span class="line">    <span class="comment">// 如果fd != 1，则关闭1指向的结构体，再打开1，指向fd的结构体，返回1</span></span><br><span class="line">    dup2(fd, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd != <span class="number">1</span>) {</span><br><span class="line">        close(fd);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Hello World"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><code>dup2</code>是一个原子操作，相当于：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dup2(fd, <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 相当于:</span></span><br><span class="line">close(<span class="number">1</span>);</span><br><span class="line">dup(fd);</span><br></pre></td></tr></tbody></table></figure>
<h3 id="3-9-fcntl和ioctl"><a href="#3-9-fcntl和ioctl" class="headerlink" title="3.9 fcntl和ioctl"></a>3.9 fcntl和ioctl</h3><p><code>fcntl</code>针对文件描述符提供控制。</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, ... <span class="comment">/* arg */</span> )</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p>返回值：若成功，则依赖于<code>cmd</code>，若失败，则返回<code>-1</code></p>
<p>函数功能：</p>
<ul>
<li>复制一个已有的描述符（<code>cmd=F_DUPFD或F_DUPFD_CLOEXEC</code>）</li>
<li>获取/设置文件描述符标志（<code>cmd=F_GETFD或F_SETFD</code>）</li>
<li>获取/设置文件状态标志（<code>cmd=F_GETFL或F_SETFL</code>）</li>
<li>获取/设置异步I/O所有权（<code>cmd=F_GETOWN或F_SETOWN</code>）</li>
<li>获取/设置记录锁（<code>cmd=F_GETLK、F_SETLK或F_SETLKW</code>）</li>
</ul>
<hr>
<p><code>ioctl</code>：用于控制设备</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ioctl</span><span class="params">(<span class="keyword">int</span> d, <span class="keyword">int</span> request, ...)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p><code>ioctl</code>函数一直是IO操作的杂物箱。不能用本章中其他函数表示的I/O操作通常都能用ioctl表示。<strong>终端I/O是使用ioctl最多的地方</strong>。</p>
<h3 id="3-10-dev-fd目录"><a href="#3-10-dev-fd目录" class="headerlink" title="3.10 /dev/fd目录"></a>3.10 /dev/fd目录</h3><p><strong>对于每个进程</strong>，内核都提供有一个<strong>特殊的虚拟目录</strong><code>/dev/fd</code>。</p>
<p>该目录中包含<code>/dev/fd/n</code>形式的文件名，其中n是与进程中打开文件描述符相对应的编号。也就是说，<code>/dev/fd/0</code>就对应于进程的标志输入。</p>
<p>打开/dev/fd目录中的一个文件等同于复制对应的文件描述符，所以下面两行代码是等价的：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fd = open(<span class="string">"/dev/fd/1"</span>, O_WRONLY);</span><br><span class="line"><span class="comment">// 等价于：</span></span><br><span class="line">fd = dup(<span class="number">1</span>);</span><br></pre></td></tr></tbody></table></figure>
<h3 id="3-11-补充：几个文件的区别"><a href="#3-11-补充：几个文件的区别" class="headerlink" title="3.11 补充：几个文件的区别"></a>3.11 补充：几个文件的区别</h3><h4 id="3-11-1-用户变量"><a href="#3-11-1-用户变量" class="headerlink" title="3.11.1 用户变量"></a>3.11.1 用户变量</h4><p> <code>~/.bashrc</code>和<code>~/.bash_file</code>这两个看到<code>~</code>，应该明白，这是用户目录下的，即里面的环境变量也叫shell变量，是局部的，只对特定的shell有效，用vim在用户目录下的<code>.bash_profile</code>文件中增加变量，<strong>变量仅会对当前用户有效</strong>，并且是“永久的”。</p>
<p>要让刚才的修改马上生效，需要执行以下代码：</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bash_profile</span><br></pre></td></tr></tbody></table></figure>
<p>两个的区别：<code>.bash_profile</code>只在会话开始时被读取一次，而<code>.bashrc</code>则每次打开新的终端时，都会被读取。</p>
<ul>
<li>当shell是交互式登录shell时，读取<code>.bash_profile</code>文件，如在系统启动、远程登录或使用su -切换用户时；</li>
<li>当shell是交互式登录和非登录shell时都会读取<code>.bashrc</code>文件，如：在图形界面中打开新终端或使用su切换用户时，均属于非登录shell的情况。</li>
</ul>
<h4 id="3-11-2-全局变量"><a href="#3-11-2-全局变量" class="headerlink" title="3.11.2 全局变量"></a>3.11.2 全局变量</h4><p><code>/etc/profile</code> 和<code>/etc/profile.d</code>，前面的是文件，后面一看也就明白<code>.d</code>表示目录， <code>/etc/profile</code>里面的变量是全局的，对所有用户的shell有效。</p>
<p> 用vim在文件<code>/etc/profile</code>文件中增加变量，该变量将会对Linux下<strong>所有用户有效</strong>，并且是“永久的”。</p>
<p>要让刚才的修改马上生效，需要执行以下代码</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></tbody></table></figure>
<h2 id="4-文件系统"><a href="#4-文件系统" class="headerlink" title="4 文件系统"></a>4 文件系统</h2><p>该节对应<code>APUE</code>的第四章——文件和目录，第六章——系统数据文件和信息</p>
<h3 id="4-1-Linux文件目录构成"><a href="#4-1-Linux文件目录构成" class="headerlink" title="4.1 Linux文件目录构成"></a>4.1 Linux文件目录构成</h3><h4 id="4-1-1-概述"><a href="#4-1-1-概述" class="headerlink" title="4.1.1 概述"></a>4.1.1 概述</h4><p><a href="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221203172157027.png" data-fancybox="gallery" data-caption="image-20221203172157027" data-thumb="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221203172157027.png"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221203172157027.png" alt="image-20221203172157027"></a></p>
<p>树状目录结构：</p>
<p><a href="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221203172208754.png" data-fancybox="gallery" data-caption="image-20221203172208754" data-thumb="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221203172208754.png"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221203172208754.png" alt="image-20221203172208754"></a></p>
<p>目录解释：</p>
<ul>
<li><strong>/bin</strong>：bin 是 Binaries (二进制文件) 的缩写，这个目录存放着最经常使用的命令。</li>
<li><strong>/boot：</strong>这里存放的是启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件。</li>
<li><strong>/dev ：</strong>dev 是 Device(设备) 的缩写，该目录下存放的是 Linux 的外部设备，在 Linux 中访问设备的方式和访问文件的方式是相同的（一切皆文件）。</li>
<li><strong>/etc：</strong>etc 是 Etcetera(等等) 的缩写，这个目录用来存放所有的系统管理所需要的配置文件和子目录。</li>
<li><strong>/home</strong>：用户的主目录（家目录），在 Linux 中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的，如上图中的 alice、bob 和 eve。</li>
<li><strong>/lib</strong>：lib 是 Library(库) 的缩写这个目录里存放着系统最基本的动态连接共享库，其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库。</li>
<li><strong>/lost+found</strong>：这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</li>
<li><strong>/media</strong>：linux 系统会自动识别一些设备，例如U盘、光驱等等，当识别后，Linux 会把识别的设备挂载到这个目录下。</li>
<li><strong>/mnt</strong>：系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在 /mnt/ 上，然后进入该目录就可以查看光驱里的内容了。</li>
<li><strong>/opt</strong>：opt 是 optional(可选) 的缩写，这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。</li>
<li><strong>/proc</strong>：proc 是 Processes(进程) 的缩写，/proc 是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。</li>
<li><strong>/root</strong>：该目录为系统管理员，也称作超级权限者的用户主目录。</li>
<li><strong>/sbin</strong>：s 就是 Super User 的意思，是 Superuser Binaries (超级用户的二进制文件) 的缩写，这里存放的是系统管理员使用的系统管理程序。</li>
<li><strong>/tmp</strong>：tmp 是 temporary(临时) 的缩写这个目录是用来存放一些临时文件的。</li>
<li><strong>/usr</strong>：usr 是 <code>unix shared resources</code>(共享资源) 的缩写，这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于 windows 下的 <code>C:/Windows/</code> 目录。<ul>
<li><code>/usr/lib</code>理解为<code>C:/Windows/System32</code></li>
<li><code>/usr/local</code>：用户级的程序目录，可以理解为<code>C:/Progrem Files/</code>。用户自己编译的软件默认会安装到这个目录下。</li>
<li><code>/opt</code>：用户级的程序目录，可以理解为<code>D:/Software</code>，opt有可选的意思，这里可以用于放置第三方大型软件（或游戏），当你不需要时，直接<code>rm -rf</code>掉即可。</li>
</ul>
</li>
<li><strong>/var</strong>：var 是 variable(变量) 的缩写，这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。</li>
<li><strong>/run</strong>：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让它指向 run。</li>
</ul>
<blockquote>
<p>切换用户</p>
</blockquote>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su 用户名</span><br></pre></td></tr></tbody></table></figure>
<hr>
<p><code>~</code>代表当前登录用户的用户目录（家目录）。</p>
<p>如果当前的用户是root，则<code>~</code>代表<code>/root</code>：</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[lighthouse@HongyiZeng ~]$ su root</span><br><span class="line">Password: </span><br><span class="line">[root@HongyiZeng lighthouse]<span class="comment"># cd ~</span></span><br><span class="line">[root@HongyiZeng ~]<span class="comment"># pwd</span></span><br><span class="line">/root</span><br></pre></td></tr></tbody></table></figure>
<p>如果当前的用户是其他用户，则<code>~</code>代表<code>/home/用户名</code>：</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[lighthouse@HongyiZeng ~]$ <span class="built_in">pwd</span></span><br><span class="line">/home/lighthouse</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h4 id="4-1-2-etc-passwd"><a href="#4-1-2-etc-passwd" class="headerlink" title="4.1.2 /etc/passwd"></a>4.1.2 /etc/passwd</h4><p><code>/etc/passwd</code>为用户信息文件存放路径。</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">root:x:<span class="number">0</span>:<span class="number">0</span>:root:/root:/bin/bash</span><br><span class="line">bin:x:<span class="number">1</span>:<span class="number">1</span>:bin:/bin:/sbin/nologin</span><br><span class="line">daemon:x:<span class="number">2</span>:<span class="number">2</span>:daemon:/sbin:/sbin/nologin</span><br><span class="line">adm:x:<span class="number">3</span>:<span class="number">4</span>:adm:/var/adm:/sbin/nologin</span><br><span class="line">lp:x:<span class="number">4</span>:<span class="number">7</span>:lp:/var/spool/lpd:/sbin/nologin</span><br><span class="line">sync:x:<span class="number">5</span>:<span class="number">0</span>:sync:/sbin:/bin/sync</span><br><span class="line">shutdown:x:<span class="number">6</span>:<span class="number">0</span>:shutdown:/sbin:/sbin/shutdown</span><br><span class="line">halt:x:<span class="number">7</span>:<span class="number">0</span>:halt:/sbin:/sbin/halt</span><br><span class="line">mail:x:<span class="number">8</span>:<span class="number">12</span>:mail:/var/spool/mail:/sbin/nologin</span><br><span class="line"><span class="keyword">operator</span>:x:<span class="number">11</span>:<span class="number">0</span>:<span class="keyword">operator</span>:/root:/sbin/nologin</span><br><span class="line">games:x:<span class="number">12</span>:<span class="number">100</span>:games:/usr/games:/sbin/nologin</span><br><span class="line">ftp:x:<span class="number">14</span>:<span class="number">50</span>:FTP User:/var/ftp:/sbin/nologin</span><br><span class="line">nobody:x:<span class="number">99</span>:<span class="number">99</span>:Nobody:/:/sbin/nologin</span><br><span class="line">systemd-network:x:<span class="number">192</span>:<span class="number">192</span>:systemd Network Management:/:/sbin/nologin</span><br><span class="line">dbus:x:<span class="number">81</span>:<span class="number">81</span>:System message bus:/:/sbin/nologin</span><br><span class="line">polkitd:x:<span class="number">999</span>:<span class="number">998</span>:User <span class="keyword">for</span> polkitd:/:/sbin/nologin</span><br><span class="line">libstoragemgmt:x:<span class="number">998</span>:<span class="number">997</span>:daemon account <span class="keyword">for</span> libstoragemgmt:/var/run/lsm:/sbin/nologin</span><br><span class="line">rpc:x:<span class="number">32</span>:<span class="number">32</span>:Rpcbind Daemon:/var/lib/rpcbind:/sbin/nologin</span><br><span class="line">ntp:x:<span class="number">38</span>:<span class="number">38</span>::/etc/ntp:/sbin/nologin</span><br><span class="line">abrt:x:<span class="number">173</span>:<span class="number">173</span>::/etc/abrt:/sbin/nologin</span><br><span class="line">sshd:x:<span class="number">74</span>:<span class="number">74</span>:Privilege-separated SSH:/var/empty/sshd:/sbin/nologin</span><br><span class="line">postfix:x:<span class="number">89</span>:<span class="number">89</span>::/var/spool/postfix:/sbin/nologin</span><br><span class="line">chrony:x:<span class="number">997</span>:<span class="number">995</span>::/var/lib/chrony:/sbin/nologin</span><br><span class="line">tcpdump:x:<span class="number">72</span>:<span class="number">72</span>::/:/sbin/nologin</span><br><span class="line">syslog:x:<span class="number">996</span>:<span class="number">994</span>::/home/syslog:/bin/<span class="literal">false</span></span><br><span class="line">lighthouse:x:<span class="number">1000</span>:<span class="number">1000</span>::/home/lighthouse:/bin/bash</span><br></pre></td></tr></tbody></table></figure>
<p>每一行分为7个字段，以冒号<code>:</code>进行分割，含义如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字段</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>用户名</td>
<td>用户登录系统时使用的用户名</td>
</tr>
<tr>
<td>密码</td>
<td>密码位，通常将<code>passwd</code>文件中的口令字段使用一个<code>x</code>来代替，将<code>/etc /shadow</code>作为真正的口令文件</td>
</tr>
<tr>
<td>UID</td>
<td>用户标识号</td>
</tr>
<tr>
<td>GID</td>
<td>缺省组标识号</td>
</tr>
<tr>
<td>注释性描述</td>
<td>例如存放用户全名等信息</td>
</tr>
<tr>
<td>宿主目录</td>
<td>用户登录系统后的缺省目录</td>
</tr>
<tr>
<td>命令解释器</td>
<td>用户使用的shell，默认为bash</td>
</tr>
</tbody>
</table>
</div>
<h4 id="4-1-3-etc-group"><a href="#4-1-3-etc-group" class="headerlink" title="4.1.3 /etc/group"></a>4.1.3 /etc/group</h4><p><code>/ect/group</code> 文件是用户组配置文件，即用户组的所有信息都存放在此文件中。只列出部分：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root:x:<span class="number">0</span>:</span><br><span class="line">lighthouse:x:<span class="number">1000</span>:lighthouse</span><br></pre></td></tr></tbody></table></figure>
<p>每一行分为4个字段，以冒号<code>:</code>进行分割，含义如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字段</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>组名</td>
<td>用户组名称</td>
</tr>
<tr>
<td>组密码</td>
<td>和 /etc/passwd 文件一样，这里的 “x” 仅仅是密码标识</td>
</tr>
<tr>
<td>GID</td>
<td>组标识号</td>
</tr>
<tr>
<td>组中的用户</td>
<td>此字段列出每个群组包含的所有用户</td>
</tr>
</tbody>
</table>
</div>
<h4 id="4-1-4-usr-include"><a href="#4-1-4-usr-include" class="headerlink" title="4.1.4 /usr/include"></a>4.1.4 /usr/include</h4><p>linux系统编程往往需要引用c头文件，linux下，头文件一般存储到<code>/usr/include</code>：</p>
<p><a href="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221203190639497.png" data-fancybox="gallery" data-caption="image-20221203190639497" data-thumb="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221203190639497.png"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221203190639497.png" alt="image-20221203190639497"></a></p>
<h4 id="补充-inode"><a href="#补充-inode" class="headerlink" title="补充 inode"></a>补充 inode</h4><h5 id="①-简介"><a href="#①-简介" class="headerlink" title="① 简介"></a>① 简介</h5><p>文件数据是储存在硬盘上的，硬盘的最小存储单位叫做<strong>扇区</strong>。每个扇区存储512字节，而连续的8个扇区组成了一个<strong>块</strong>（block），大小为<code>4kB</code>。<strong>文件数据都存储在块中</strong>，为了能够方便找到存储数据的位置我们还必须找到一个地方存储文件的属性，这种存储文具属性信息的区域叫做<code>inode</code>（索引节点）。</p>
<h5 id="②-inode的信息"><a href="#②-inode的信息" class="headerlink" title="② inode的信息"></a>② inode的信息</h5><p>inode（<strong>本质上是一个结构体</strong>）包含文件的属性信息有以下内容：<strong>注意，没有文件名和inode编号</strong></p>
<ul>
<li>文件的字节数</li>
<li>文件拥有者的id</li>
<li>文件所属组id</li>
<li>文件的读写执行权限</li>
<li>文件的时间戳，共有三个：<ul>
<li>ctime指inode上一次变动的时间</li>
<li>mtime指文件内容上一次变动时间</li>
<li>atime指文件上一次打开时间。</li>
</ul>
</li>
<li>硬链接数，即有多少个文件指向这个inode</li>
<li><p>文件数据块（block）的位置，即指向数据块的<strong>指针</strong>，包括一级指针，二级指针和三级指针，一般为15个指针</p>
<p>inode也会消耗硬盘空间，所以硬盘格式化的时候，操作系统自动将硬盘划分为两个区域。一个是<strong>数据区</strong>，存放文件数据，另一个是<strong>inode区（inode table）</strong>，存放inode所包含的信息，inode区本质上是一个<strong>结构体数组</strong>，数组下标就是inode编号<code>inode_num</code>。</p>
</li>
</ul>
<p><a href="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221205182107212.png" data-fancybox="gallery" data-caption="image-20221205182107212" data-thumb="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221205182107212.png"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221205182107212.png" alt="image-20221205182107212"></a></p>
<p> 每个inode节点（结构体）的大小，一般是128字节或者256字节。inode节点的总数。在格式化时就给定，一般是每1kb或者每2kb就设置一个inode。假定在一块1GB的硬盘中，每个inode节点的大小就会达到128MB。</p>
<p>inode编号是很重要的，当系统在找一个文件时，步骤如下：</p>
<ol>
<li>通过文件名先找到文件的inode编号（数组下标）</li>
<li>通过inode编号找到文件inode信息（结构体）</li>
<li>通过inode信息中的block<strong>指针</strong>找到文件内容。</li>
</ol>
<h5 id="③-相关命令"><a href="#③-相关命令" class="headerlink" title="③ 相关命令"></a>③ 相关命令</h5><p><code>stat</code>显示文件的状态信息。stat命令的输出信息比ls命令的输出信息要更详细。</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng sysio]<span class="comment"># ls</span></span><br><span class="line">ab  ab.c  dup  dup.c  mycpy  mycpy.c  <span class="built_in">test</span></span><br><span class="line">[root@HongyiZeng sysio]<span class="comment"># stat ab.c</span></span><br><span class="line">  文件: ‘ab.c’</span><br><span class="line">  大小: 193             块: 8          IO 块: 4096   普通文件</span><br><span class="line">设备: fd01h/64769d    Inode: 797269      硬链接: 1</span><br><span class="line">权限: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)</span><br><span class="line">最近访问: 2022-12-02 16:05:47.044135336 +0800</span><br><span class="line">最近修改: 2022-12-02 16:05:45.239158807 +0800</span><br><span class="line">最近改动: 2022-12-02 16:05:45.245158729 +0800</span><br><span class="line"> 创建时间: -</span><br></pre></td></tr></tbody></table></figure>
<p><code>ls -i</code>用于查看某个文件的inode编号。</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng sysio]<span class="comment"># ls -i ab.c</span></span><br><span class="line">797269 ab.c</span><br></pre></td></tr></tbody></table></figure>
<h5 id="④-硬链接"><a href="#④-硬链接" class="headerlink" title="④ 硬链接"></a>④ 硬链接</h5><p> 一般情况下，文件名和inode号码是一一对应关系，每个inode号码对应一个文件名，但是Linux系统<strong>允许多个文件名指向同一个inode号码</strong>，这就意味着，可以用不同的文件名访问同样的内容；对文件内容进行修改，会影响到所有文件名；但是删除一个文件名，不影响另一个文件名访问，相当于源文件的副本，这种情况叫做硬链接。</p>
<p>inode信息中有一项叫做链接数，记录指向该inode的文件总数，这时会加1，反过来，删除一个文件名，会减一，当链接数变为0时，表明没有文件指向这个inode号码，系统就会回收这个inode号码与文件数据块区。</p>
<h5 id="⑤-符号链接"><a href="#⑤-符号链接" class="headerlink" title="⑤ 符号链接"></a>⑤ 符号链接</h5><p>文件A与文件B的号码虽然不一样，但是文件A的内容是文件B的路径，A就是B的软链接文件。读取文件A时，系统会自动访问导向文件B的文件名，然后再根据B的inode去访问存储在块中的数据。</p>
<p>而这意味着，文件A依赖于文件B而存在，若删除了文件B，打开文件A就会报错。这就是软连接与硬链接最大的不同：<strong>文件A指向文件B的文件名，而不是inode号码，文件B的inode链接数不会发生变化</strong>。</p>
<h3 id="4-2-文件和目录"><a href="#4-2-文件和目录" class="headerlink" title="4.2 文件和目录"></a>4.2 文件和目录</h3><h4 id="4-2-1-stat"><a href="#4-2-1-stat" class="headerlink" title="4.2.1 stat"></a>4.2.1 stat</h4><p>系统调用<code>stat</code>用于获取文件的属性。</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, struct stat *buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fstat</span><span class="params">(<span class="keyword">int</span> fd, struct stat *buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lstat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, struct stat *buf)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>stat</code>：第一个形参：文件路径； 第二个形参：一个指向结构体<code>stat</code>的指针，因此需要传入结构体的地址；</li>
<li><code>fstat</code>：第一个形参是文件描述符；</li>
<li><code>lstat</code>：lstat函数的形参跟stat函数的形参一样。其功能也跟stat函数功能一样，仅有一点不
同：stat函数是穿透（追踪）函数，即对软链接文件进行操作时，操作的是链接到的那一个文件，不是软链接文件本身；而lstat函数是不穿透（不追踪）
函数，对软链接文件进行操作时，操作的是<strong>软链接文件本身</strong>。注：软链接严格来说应该叫<strong>符号链接</strong>。</li>
<li>返回值：成功返回0，失败返回-1，并且将详细错误信息赋值给errno全局变量。</li>
</ul>
<p><code>struct stat</code>类型的说明：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> {</span></span><br><span class="line">    <span class="keyword">dev_t</span> st_dev;     <span class="comment">/* 文件的设备编号 */</span></span><br><span class="line">    <span class="keyword">ino_t</span> st_ino;     <span class="comment">/* 索引结点编号 */</span></span><br><span class="line">    <span class="keyword">mode_t</span> st_mode;    <span class="comment">/* 文件类型和权限*/</span></span><br><span class="line">    <span class="keyword">nlink_t</span> st_nlink;   <span class="comment">/*硬链接数 */</span></span><br><span class="line">    <span class="keyword">uid_t</span> st_uid;     <span class="comment">/*用户ID*/</span></span><br><span class="line">    <span class="keyword">gid_t</span> st_gid;     <span class="comment">/* 组ID*/</span></span><br><span class="line">    <span class="keyword">dev_t</span> st_rdev;    <span class="comment">/* 设备类型（若此文件为设备文件，则为设备编号*/</span></span><br><span class="line">    <span class="keyword">off_t</span> st_size;    <span class="comment">/* 文件大小，以字节为单位*/</span></span><br><span class="line">    <span class="keyword">blksize_t</span> st_blksize; <span class="comment">/*文件系统的I/O块大小*/</span></span><br><span class="line">    <span class="keyword">blkcnt_t</span> st_blocks;  <span class="comment">/* 块数 */</span></span><br><span class="line">    <span class="keyword">time_t</span> st_atime;   <span class="comment">/* 访问时间 */</span></span><br><span class="line">    <span class="keyword">time_t</span> st_mtime;   <span class="comment">/* 修改时间 */</span></span><br><span class="line">    <span class="keyword">time_t</span> st_ctime;   <span class="comment">/* 更改时间 */</span></span><br><span class="line">}; </span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>代码示例</p>
</blockquote>
<p>打印出文件的大小。</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意返回值是off_t类型</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">off_t</span> <span class="title">flen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fname)</span> </span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">statres</span>;</span> <span class="comment">// 声明一个stat类型的结构体statres</span></span><br><span class="line">    <span class="keyword">if</span>(stat(fname, &amp;statres) &lt; <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">"stat()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">	<span class="comment">// 返回st_size成员</span></span><br><span class="line">    <span class="keyword">return</span> statres.st_size;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>) {</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Usage...\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"total size: %lld\n"</span>, flen(argv[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><code>off_t</code>类型用于指示文件的偏移量，通常就是<code>long</code>类型，其默认为一个32位的整数，在gcc编译中会被编译为<code>long int</code>类型，在64位的Linux系统中则会被编译为<code>long long int</code>，这是一个64位的整数，其定义在<code>unistd.h</code>头文件中可以查看。</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">ifndef</span> __off_t_defined</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">ifndef</span> __USE_FILE_OFFSET64</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">__off_t</span> <span class="keyword">off_t</span>;</span><br><span class="line"><span class="meta">#  <span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">__off64_t</span> <span class="keyword">off_t</span>;</span><br><span class="line"><span class="meta">#  <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> __off_t_defined</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> defined __USE_LARGEFILE64 &amp;&amp; !defined __off64_t_defined</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">__off64_t</span> <span class="keyword">off64_t</span>;</span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> __off64_t_defined</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure>
<h4 id="4-2-2-空洞文件"><a href="#4-2-2-空洞文件" class="headerlink" title="4.2.2 空洞文件"></a>4.2.2 空洞文件</h4><p>在描述文件属性的结构体<code>stat</code>中，有以下三个描述文件大小的成员：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> {</span></span><br><span class="line">    <span class="keyword">off_t</span> st_size;    <span class="comment">/* 文件大小，以字节为单位*/</span></span><br><span class="line">    <span class="keyword">blksize_t</span> st_blksize; <span class="comment">/*文件系统的I/O块大小*/</span></span><br><span class="line">    <span class="keyword">blkcnt_t</span> st_blocks;  <span class="comment">/* 块数 */</span></span><br><span class="line">}; </span><br></pre></td></tr></tbody></table></figure>
<p>其中，块大小一般为4096字节，即<code>4KB</code>（一个块为连续8个扇区，每个扇区为512B）；块数为该文件的占用的块数；</p>
<p>注意：<code>st_size ≠ st_blksize * st_blocks</code>；或者说，<code>st_size</code>是文件的<strong>逻辑大小</strong>，而<code>st_blksize * st_blocks</code>是文件的<strong>物理大小</strong>；</p>
<blockquote>
<p>代码示例</p>
</blockquote>
<p>创建一个<code>5GB</code>大小的文件：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>) {</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Usage..."</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((fd = open(argv[<span class="number">1</span>], O_WRONLY|O_CREAT|O_TRUNC, <span class="number">0600</span>)) &lt; <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">"open"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">	<span class="comment">// 先让指针从文件开头向后移动5G个字节</span></span><br><span class="line">    lseek(fd, <span class="number">5LL</span> * <span class="number">1024LL</span> * <span class="number">1024LL</span> * <span class="number">1024LL</span> - <span class="number">1LL</span>, SEEK_SET);</span><br><span class="line">	<span class="comment">// 在最后写入一个空字符</span></span><br><span class="line">    write(fd, <span class="string">""</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>执行结果：</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng fs]<span class="comment"># make big</span></span><br><span class="line">cc     big.c   -o big</span><br><span class="line">[root@HongyiZeng fs]<span class="comment"># ./big /tmp/bigfile</span></span><br><span class="line">[root@HongyiZeng fs]<span class="comment"># stat /tmp/bigfile </span></span><br><span class="line">  File: ‘/tmp/bigfile’</span><br><span class="line">  Size: 5368709120      Blocks: 8          IO Block: 4096   regular file</span><br><span class="line">Device: fd01h/64769d    Inode: 26199       Links: 1</span><br><span class="line">Access: (0600/-rw-------)  Uid: (    0/    root)   Gid: (    0/    root)</span><br><span class="line">Access: 2022-12-05 16:19:40.734216438 +0800</span><br><span class="line">Modify: 2022-12-05 16:19:40.734216438 +0800</span><br><span class="line">Change: 2022-12-05 16:19:40.734216438 +0800</span><br><span class="line"> Birth: -</span><br></pre></td></tr></tbody></table></figure>
<p>可以看出，大小为5368709120B，但是占用的块数却为8，即实际占用的物理大小为<code>4KB * 8 = 32KB</code>。</p>
<p>如果将该文件进行拷贝，再查看拷贝文件的属性：</p>
<figure class="highlight plaintext"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">plaintext</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng fs]# cp /tmp/bigfile /tmp/bigfile.bak</span><br><span class="line">[root@HongyiZeng fs]# stat /tmp/bigfile.bak </span><br><span class="line">  File: ‘/tmp/bigfile.bak’</span><br><span class="line">  Size: 5368709120      Blocks: 0           IO Block: 4096   regular file</span><br><span class="line">Device: fd01h/64769d    Inode: 26200       Links: 1</span><br><span class="line">Access: (0600/-rw-------)  Uid: (    0/    root)   Gid: (    0/    root)</span><br><span class="line">Access: 2022-12-05 16:26:39.166784814 +0800</span><br><span class="line">Modify: 2022-12-05 16:26:39.166784814 +0800</span><br><span class="line">Change: 2022-12-05 16:26:39.166784814 +0800</span><br><span class="line"> Birth: -</span><br></pre></td></tr></tbody></table></figure>
<hr>
<p>使用 lseek 可以修改文件的当前读写位置偏移量，此函数不但可以改变位置偏移量，并且还允许文件偏移量超出文件长度，譬如有一个 <code>test_file</code>，该文件的大小是 4K（也就是 4096 个字节），通过 lseek 系统调用可以将该文件的读写偏移量移动到偏移文件头部 6000 个字节处。</p>
<p>接下来使用 write 函数对文件进行写入操作，也就是说此时将是从偏移文件头部 6000 个字节处开始写入数据，也就意味着 4096~6000 字节之间出现了一个<strong>空洞</strong>，因为这部分空间并没有写入任何数据，所以形成了空洞，这部分区域就被称为文件空洞，那么相应的该文件也被称为<strong>空洞文件</strong>。文件空洞部分实际上并不会占用任何物理空间，直到在某个时刻对空洞部分进行写入数据时才会为它分配对应的空间，但是空洞文件形成时，逻辑上该文件的大小是包含了空洞部分的大小的，这点需要注意。</p>
<blockquote>
<p>空洞文件的作用</p>
</blockquote>
<p>空洞文件的好处是：空洞文件对多线程共同操作文件是很有用的。</p>
<p>因为我们在创建一个很大文件的时候，我们就把一个文件分成很多的段，然后采用多线程的方式，让每个线程负责写入其中的某一段的数据。这样的话比我们用单个线程写入是快很多的。</p>
<p>例如：</p>
<ul>
<li>在使用迅雷下载文件时，还未下载完成，就发现该文件已经占据了全部文件大小的空间，这也是空洞文件；下载时如果没有空洞文件，多线程下载时文件就只能从一个地方写入，这就不能发挥多线程的作用了；如果有了空洞文件，可以从不同的地址同时写入，就达到了多线程的优势；</li>
<li>在创建虚拟机时，你给虚拟机分配了 100G 的磁盘空间，但其实系统安装完成之后，开始也不过只用了 3、4G 的磁盘空间，如果一开始就把 100G 分配出去，资源是很大的浪费。</li>
</ul>
<h4 id="4-2-3-st-mode"><a href="#4-2-3-st-mode" class="headerlink" title="4.2.3 st_mode"></a>4.2.3 st_mode</h4><h5 id="①-简介-1"><a href="#①-简介-1" class="headerlink" title="① 简介"></a>① 简介</h5><p><code>st_mode</code>是一个16位的位图，用于表示文件类型，文件访问权限以及特殊权限位。</p>
<p>它的类型为<code>mode_t</code>，其实就是普通的<code>unsigned int</code>，但是只是用了低16位。</p>
<p><a href="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221205165451681.png" data-fancybox="gallery" data-caption="image-20221205165451681" data-thumb="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221205165451681.png"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221205165451681.png" alt="image-20221205165451681"></a></p>
<h5 id="②-实例分析"><a href="#②-实例分析" class="headerlink" title="② 实例分析"></a>② 实例分析</h5><p>假设<code>st_mode</code>表示为八进制的<code>100664</code>：</p>
<p><a href="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221205165902073.png" data-fancybox="gallery" data-caption="image-20221205165902073" data-thumb="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221205165902073.png"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221205165902073.png" alt="image-20221205165902073"></a></p>
<p>则有：</p>
<ul>
<li>1000: 这是一个常规文件</li>
<li>000: 执行时设置信息为空，黏着位为 0</li>
<li>110-110-100: 用户权限为 <code>RW-</code>，组员权限为<code>RW-</code>，其他人权限为<code>R--</code></li>
</ul>
<h5 id="③-宏"><a href="#③-宏" class="headerlink" title="③ 宏"></a>③ 宏</h5><p>通过手工分析 st_mode 字段，实际上是很不方便的。实际写程序，可使用 <code>st_mode &amp; 掩码</code>来得到 st_mode 中特定的部分。比如：</p>
<figure class="highlight plaintext"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">plaintext</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">st_mode &amp; 0170000 : 得到文件类型</span><br><span class="line">st_mode &amp; 0007000 : 得到执行文件时设置信息</span><br><span class="line">st_mode &amp; 0000777 : 得到权限位</span><br><span class="line">st_mode &amp; 00100: 判断所有者是否可执行</span><br><span class="line">(以上数字均为八进制)</span><br></pre></td></tr></tbody></table></figure>
<p>为了方便使用，用 linux 预定义的一些宏来代替这些生硬的数字。</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//bit15 ~ bit12 , 文件类型属性区域</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  S_IFMT      0170000     文件类型的位遮罩</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  S_IFSOCK    0140000     socket</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  S_IFLNK     0120000     符号链接(symbolic link)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  S_IFREG     0100000     一般文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  S_IFBLK     0060000     区块装置(block device)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  S_IFDIR     0040000     目录</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  S_IFCHR     0020000     字符装置(character device)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  S_IFIFO     0010000     先进先出(fifo)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_ISSOCK(m) (((m) &amp; S_IFMT) == S_IFSOCK)  <span class="comment">//提供了一些宏函数来帮助用户执行&amp;操作，是则返回1</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_ISLNK(m)  (((m) &amp; S_IFMT) == S_IFLNK)  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_ISREG(m)  (((m) &amp; S_IFMT) == S_IFREG)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_ISBLK(m)  (((m) &amp; S_IFMT) == S_IFBLK)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_ISDIR(m)  (((m) &amp; S_IFMT) == S_IFDIR)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_ISCHR(m)  (((m) &amp; S_IFMT) == S_IFCHR)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_ISFIFO(m) (((m) &amp; S_IFMT) == S_IFIFO)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//bit11 ~ bit9，权限的特殊属性区域</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  S_ISUID      0004000     文件的(set user-id on execution)位</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  S_ISGID      0002000     文件的(set group-id on execution)位</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  S_ISVTX      0001000     文件的sticky位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//bit8 ~ bit0，权限属性区域</span></span><br><span class="line"><span class="comment">//文件所有者（owner）</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_IRWXU 00700	<span class="comment">/* mask for file owner permissions */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_IRUSR 00400	<span class="comment">/* owner has read permission */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_IWUSR 00200	<span class="comment">/* owner has write permission */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_IXUSR 00100	<span class="comment">/* owner has execute permission */</span></span></span><br><span class="line"> <span class="comment">//组用户（group）</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_IRWXG 00070	<span class="comment">/* mask for group permissions */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_IRGRP 00040	<span class="comment">/* group has read permission */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_IWGRP 00020	<span class="comment">/* group has write permission */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_IXGRP 00010	<span class="comment">/* group has execute permission */</span></span></span><br><span class="line"> <span class="comment">//其他用户（other）</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_IRWXO 00007	<span class="comment">/* mask for permissions for others (not in group) */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_IROTH 00004	<span class="comment">/* others have read permission */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_IWOTH 00002	<span class="comment">/* others have write permission */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_IXOTH 00001	<span class="comment">/* others have execute permission */</span></span></span><br></pre></td></tr></tbody></table></figure>
<h5 id="④-代码示例"><a href="#④-代码示例" class="headerlink" title="④ 代码示例"></a>④ 代码示例</h5><figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ftype</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fname)</span> </span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">statres</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(stat(fname, &amp;statres) &lt; <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">"stat()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(S_ISREG(statres.st_mode))</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'-'</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(S_ISDIR(statres.st_mode))</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'d'</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(S_ISSOCK(statres.st_mode))</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'s'</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'?'</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fper</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fname)</span> </span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">statres</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(stat(fname, &amp;statres)) {</span><br><span class="line">        perror(<span class="string">"fper()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> statres.st_mode &amp; S_IRWXU;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>) {</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Usage...\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"File type: %c\n"</span>, ftype(argv[<span class="number">1</span>]));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Permission of owner: %o\n"</span>, fper(argv[<span class="number">1</span>]));</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>执行结果：</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng fs]<span class="comment"># ./ftype ftype.c </span></span><br><span class="line">File <span class="built_in">type</span>: -</span><br><span class="line">Permission of owner: 600</span><br><span class="line">[root@HongyiZeng fs]<span class="comment"># ./ftype ftype</span></span><br><span class="line">File <span class="built_in">type</span>: -</span><br><span class="line">Permission of owner: 700</span><br></pre></td></tr></tbody></table></figure>
<h4 id="4-2-4-文件权限"><a href="#4-2-4-文件权限" class="headerlink" title="4.2.4 文件权限"></a>4.2.4 文件权限</h4><h5 id="①-umask"><a href="#①-umask" class="headerlink" title="① umask"></a>① umask</h5><p>umask函数原型：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">mode_t</span> <span class="title">umask</span><span class="params">(<span class="keyword">mode_t</span> mask)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p>在进程创建一个新的文件或目录时，如调用open函数创建一个新文件，新文件的实际存取权限是mode与umask按照 <code>mode &amp; ~umask</code>运算以后的结果。umask函数用来修改进程的umask，作用是防止出现权限过松的文件。</p>
<h5 id="②-chmod"><a href="#②-chmod" class="headerlink" title="② chmod"></a>② chmod</h5><p>补充：chmod命令</p>
<p>语法：</p>
<figure class="highlight plaintext"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">plaintext</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod [对谁操作(ugoa)] [操作符 (+-=)] [赋予的权限(rwxs或数字)] 文件名1 文件名2...</span><br></pre></td></tr></tbody></table></figure>
<p><a href="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221205171940635.png" data-fancybox="gallery" data-caption="image-20221205171940635" data-thumb="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221205171940635.png"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221205171940635.png" alt="image-20221205171940635"></a></p>
<p>例如：</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng fs]<span class="comment"># ll big.c</span></span><br><span class="line">-rw-r--r-- 1 root root 420 Dec  5 16:19 big.c</span><br><span class="line">[root@HongyiZeng fs]<span class="comment"># chmod 664 big.c</span></span><br><span class="line">[root@HongyiZeng fs]<span class="comment"># ll big.c</span></span><br><span class="line">-rw-rw-r-- 1 root root 420 Dec  5 16:19 big.c</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng fs]<span class="comment"># ll big.c</span></span><br><span class="line">-rw-rw-r-- 1 root root 420 Dec  5 16:19 big.c</span><br><span class="line">[root@HongyiZeng fs]<span class="comment"># chmod a+x big.c</span></span><br><span class="line">[root@HongyiZeng fs]<span class="comment"># ll big.c</span></span><br><span class="line">-rwxrwxr-x 1 root root 420 Dec  5 16:19 big.c</span><br><span class="line">[root@HongyiZeng fs]<span class="comment"># chmod o-x big.c</span></span><br><span class="line">[root@HongyiZeng fs]<span class="comment"># ll big.c</span></span><br><span class="line">-rwxrwxr-- 1 root root 420 Dec  5 16:19 big.c</span><br></pre></td></tr></tbody></table></figure>
<hr>
<p>chmod函数原型：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chmod</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchmod</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p>chmod是对指定的文件进行操作，而fchmod则是对已经打开的文件进行操作。所以它们的第一个参数不一样。</p>
<p>返回值：如果改变成功返回0，否则返回-1</p>
<blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">"a"</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == fd)</span><br><span class="line">    {</span><br><span class="line">       perror(<span class="string">"open fail"</span>);</span><br><span class="line">       <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"> 	<span class="comment">// 将fd的权限更改为0777</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == fchmod(fd, <span class="number">0777</span>))</span><br><span class="line">    {</span><br><span class="line">        perror(<span class="string">"fchmod fail"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"> 	</span><br><span class="line">    <span class="comment">// 将b文件的权限更改为0777</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == chmod(<span class="string">"b"</span>, <span class="number">0777</span>))</span><br><span class="line">    {</span><br><span class="line">       perror(<span class="string">"fchmod fail"</span>);</span><br><span class="line">       <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h5 id="③-粘住位"><a href="#③-粘住位" class="headerlink" title="③ 粘住位"></a>③ 粘住位</h5><p>在UNIX尚未使用分页技术的早期版本中，<code>S_ISVTX</code>位被称为粘住位（<code>sticky bit</code>）。</p>
<p>如果一个<strong>可执行程序文件</strong>的这一位被设置了，那么在该程序第一次被执行并结束时，其程序正文部分的一个副本仍被保
存在交换区，（程序的正文部分是机器指令部分）。这使得下次执行该程序时能较快地将其装入内存中。其原因是：交换区占用连续磁盘空间，可将它视为连续文
件，而且一个程序的正文部分在交换区中也是连续存放的，而在一般的UNIX文件系统中，文件的各数据块很可能是随机存放的。</p>
<p>对于常用的应用程序，例如文本编辑器和C编译器，我们常常设置它们所在文件的粘住位。自然，对于在交换区中可以同时存放的设置了粘住位的文件数是有
一定限制的，以免过多占用交换区空间，但无论如何这是一个有用的技术。后来的UNIX版本称它为保存正文位（saved-text 
bit），因此也就有了常量<code>S_ISVTX</code>。现今较新的UNIX系统大多数都配置有虚拟存储系统以及快速文件系统，所以不再需要使用这种技术。</p>
<p>现今的系统扩展了粘住位的使用范围，<strong>允许针对目录设置粘住位</strong>。如果对一个目录设置了粘住位，则只有对该目录具有写权限的用户在满足下列之一的情况下，才能删除或更名该目录下的文件或目录：</p>
<ul>
<li>拥有此文件</li>
<li>拥有此目录</li>
<li>是超级用户</li>
</ul>
<p>目录<code>/tmp</code>是设置粘住位的典型候选者：任何用户都可在这个目录中创建文件。任一用户（用户、组和其他）对这个目录的权限通常都是读、写和执行（<code>rwx</code>）。但是用户不应能删除或更名属于其他人的文件，为此在这个目录的文件模式中都设置了粘住位。</p>
<p>即：假如<code>/tmp</code>下的文件A被用户U1所有，文件A的权限为777，那么所有用户都可以对该文件进行修改、移动、重命名等操作，<strong>但无法删除该文件</strong>。通常的用途在于用户团队协作的目录，用户可以相互修改文件，却<strong>只有用户所有者才能删除</strong>。</p>
<p><a href="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221205173224552.png" data-fancybox="gallery" data-caption="image-20221205173224552" data-thumb="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221205173224552.png"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221205173224552.png" alt="image-20221205173224552"></a></p>
<p>图中最后一位<code>t</code>就是粘住位。</p>
<h4 id="4-2-5-文件系统"><a href="#4-2-5-文件系统" class="headerlink" title="4.2.5 文件系统"></a>4.2.5 文件系统</h4><h5 id="①-磁盘的结构"><a href="#①-磁盘的结构" class="headerlink" title="① 磁盘的结构"></a>① 磁盘的结构</h5><p><a href="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221205180529903.png" data-fancybox="gallery" data-caption="image-20221205180529903" data-thumb="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221205180529903.png"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221205180529903.png" alt="image-20221205180529903"></a></p>
<blockquote>
<p>磁盘</p>
</blockquote>
<p>一个磁盘（如一个 1T 的机械硬盘）由多个盘片（如下图中的 0 号盘片）叠加而成。</p>
<p>盘片的表面涂有磁性物质，这些磁性物质用来记录二进制数据。因为正反两面都可涂上磁性物质，故一个盘片可能会有两个盘面。</p>
<p><a href="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221205180620706.png" data-fancybox="gallery" data-caption="image-20221205180620706" data-thumb="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221205180620706.png"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221205180620706.png" alt="image-20221205180620706"></a></p>
<blockquote>
<p>磁道和扇区</p>
</blockquote>
<p>每个盘片被划分为一个个磁道（一个一个半径不同的同心圆环），每个磁道又划分为一个个扇区（磁道上的一个弧段）。扇区是磁盘的最小组成单元，通常是<code>512字节</code>。如下图：</p>
<p><a href="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221205180731436.png" data-fancybox="gallery" data-caption="image-20221205180731436" data-thumb="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221205180731436.png"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221205180731436.png" alt="image-20221205180731436"></a></p>
<p>其中，最内侧磁道上的扇区面积最小，因此数据密度最大。</p>
<blockquote>
<p>柱面</p>
</blockquote>
<p>每个盘面对应一个磁头。所有的磁头都是连在同一个磁臂上的，因此所有磁头只能“共进退”。</p>
<p>所有盘面中半径相同的磁道组成柱面。如下图：</p>
<p><a href="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221205180822250.png" data-fancybox="gallery" data-caption="image-20221205180822250" data-thumb="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221205180822250.png"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221205180822250.png" alt="image-20221205180822250"></a></p>
<blockquote>
<p>磁盘容量计算</p>
</blockquote>
<p>存储容量 ＝ 磁头数 × 磁道(柱面)数 × 每道扇区数 × 每扇区字节数</p>
<blockquote>
<p>磁盘的物理地址</p>
</blockquote>
<p>由上，可用<code>（柱面号，盘面号，扇区号）</code>来定位任意一个“磁盘块”，这里的“磁盘块”，实质上就是一个扇区。</p>
<p>可根据该地址读取一个“块”，操作如下：</p>
<ol>
<li>根据“柱面号”前后移动磁臂，让磁头指向指定柱面；</li>
<li>旋转磁盘，让磁头抵达待读的起始扇区。</li>
<li>激活指定盘面对应的磁头；</li>
<li>旋转磁盘，指定的扇区会从磁头下面划过，这样就完成了对指定扇区的读/写。</li>
</ol>
<blockquote>
<p>块和簇</p>
</blockquote>
<p>磁盘块/簇（虚拟出来的）。 块是操作系统中最小的<strong>逻辑存储单位</strong>。操作系统与磁盘打交道的最小单位是磁盘块。</p>
<p>在Windows下如<code>NTFS</code>等文件系统中叫做簇；</p>
<p>在Linux下如<code>Ext4</code>等文件系统中叫做块（block）。一般来说，一个块（<code>block</code>）包含连续的8个扇区，每个扇区<code>512B</code>，因此一个块大小为<code>4096KB</code>。</p>
<p>每个簇或者块可以包括2、4、8、16、32、64…2的n次方个扇区。</p>
<h5 id="②-文件系统简介"><a href="#②-文件系统简介" class="headerlink" title="② 文件系统简介"></a>② 文件系统简介</h5><p>文件系统：文件或数据的存储和管理。目前，正在使用的UNIX文件系统有多种实现。</p>
<ul>
<li>传统的基于BSD的UNIX文件系统（称为<code>UFS</code>）。UFS是以Berkeley快速文件系统为基础的。本节讨论该文件系统。</li>
<li>读、写DOS格式软盘的文件系统（称为<code>PCFS</code>）</li>
<li>读CD的文件系统（称为<code>HSFS</code>）</li>
</ul>
<p>我们可以把一个磁盘分成一个或多个分区。<strong>每个分区可以包含一个文件系统</strong>。</p>
<p><a href="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221205180335105.png" data-fancybox="gallery" data-caption="image-20221205180335105" data-thumb="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221205180335105.png"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221205180335105.png" alt="image-20221205180335105"></a></p>
<ul>
<li><strong>i节点</strong>即为inode结构体的数组</li>
<li>数据块一般被分成了大小为4KB的块（block）</li>
<li>i节点图（i节点位图）：用来判断inode的空闲与占用情况</li>
<li>块位图：用来判断数据块的占用与空闲情况</li>
</ul>
<hr>
<p>对于普通文件，如下图：</p>
<p><a href="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221205181426945.png" data-fancybox="gallery" data-caption="image-20221205181426945" data-thumb="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221205181426945.png"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221205181426945.png" alt="image-20221205181426945"></a></p>
<ul>
<li>i节点结构体中通常包含15个指针来指向数据块，最后三个指针为一二三级指针，用于扩充文件的大小；图中的i节点指向了三个数据块。</li>
<li>在图中有两个目录项（两个不同文件名的文件，但是inode编号相同）指向同一个i节点（此时称为<strong>硬链接</strong>，即<strong>目录项就是硬链接的同义词</strong>）。每个i节点中都有一个硬链接计数<code>st_nlink</code>，其值是指向该i节点的目录项数。只有当链接计数减少至0时，才可删除该文件（也就是可以释放该文件占用的数据块）。</li>
<li>i节点包含了文件有关的所有信息∶文件类型、文件访问权限位、文件长度和指向文件数据块的指针等。stat 结构中的大多数信息都取自i节点。<strong>只有两项重要数据存放在目录项中∶文件名和i节点编号</strong>。</li>
</ul>
<p>对于目录，目录也是一种文件，它的属性也需要inode结构体存储，它的物理存储也需要通过inode中的指针来指向的数据块（此时的数据块就是<strong>目录块</strong>）来存储；</p>
<p>目录块存储的内容非常的简单，由<strong>目录项</strong>组成，<code>每条目录项有包含的文件名以及该文件名对应的inode编号</code>。</p>
<p>如下图所示：</p>
<p><a href="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221205194706533.png" data-fancybox="gallery" data-caption="image-20221205194706533" data-thumb="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221205194706533.png"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221205194706533.png" alt="image-20221205194706533"></a></p>
<ul>
<li>编号为2549的i节点（<code>testdir</code>），其类型字段<code>st_mode</code>表示它是一个目录（因此它指向一个特殊的数据块——目录块），链接计数为2。任何一个叶目录（不包含任何其他目录的目录）的链接计数总是2，数值2来自于命名该目录（testdir）的目录项以及在该目录中的<code>.</code>项。</li>
<li>编号为1267的i节点，其类型字段<code>st_mode</code>表示它是一个目录，链接计数大于或等于3。它大于或等于3的原因是，至少有3个目录项指向它∶一个是命名它的目录项，第二个是在该目录中的<code>.</code>项，第三个是在其子目录 testdir 中的<code>..</code>项。注意，在父目录中的每一个子目录都使该父目录的链接计数增加1。</li>
</ul>
<h5 id="③-链接"><a href="#③-链接" class="headerlink" title="③ 链接"></a>③ 链接</h5><p>链接分为硬链接和符号链接（注意不是软链接）。</p>
<p>创建链接的命令：</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln src dest <span class="comment"># 创建src的硬链接为dest</span></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s src dest <span class="comment"># 创建src的符号链接为dest</span></span><br></pre></td></tr></tbody></table></figure>
<hr>
<p>硬链接对比：</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng tmp]<span class="comment"># ln bigfile bigfile_link</span></span><br><span class="line">[root@HongyiZeng tmp]<span class="comment"># stat bigfile</span></span><br><span class="line">  File: ‘bigfile’</span><br><span class="line">  Size: 5368709120      Blocks: 8          IO Block: 4096   regular file</span><br><span class="line">Device: fd01h/64769d    Inode: 26199       Links: 2</span><br><span class="line">Access: (0600/-rw-------)  Uid: (    0/    root)   Gid: (    0/    root)</span><br><span class="line">Access: 2022-12-05 16:26:39.166784814 +0800</span><br><span class="line">Modify: 2022-12-05 16:19:40.734216438 +0800</span><br><span class="line">Change: 2022-12-05 20:29:33.176048702 +0800</span><br><span class="line"> Birth: -</span><br><span class="line">[root@HongyiZeng tmp]<span class="comment"># stat bigfile_link </span></span><br><span class="line">  File: ‘bigfile_link’</span><br><span class="line">  Size: 5368709120      Blocks: 8          IO Block: 4096   regular file</span><br><span class="line">Device: fd01h/64769d    Inode: 26199       Links: 2</span><br><span class="line">Access: (0600/-rw-------)  Uid: (    0/    root)   Gid: (    0/    root)</span><br><span class="line">Access: 2022-12-05 16:26:39.166784814 +0800</span><br><span class="line">Modify: 2022-12-05 16:19:40.734216438 +0800</span><br><span class="line">Change: 2022-12-05 20:29:33.176048702 +0800</span><br><span class="line"> Birth: -</span><br></pre></td></tr></tbody></table></figure>
<p>字段<code>Link</code>即为文件的硬链接数，硬链接数为2，说明有两个目录项指向了这个inode，并且注意两个文件的inode编号相同，说明同时指向了这个inode；</p>
<p>将源文件<code>bigfile</code>删除后，<code>bigfile_link</code>仍然存在：</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng tmp]<span class="comment"># rm -rf bigfile</span></span><br><span class="line">[root@HongyiZeng tmp]<span class="comment"># stat bigfile_link </span></span><br><span class="line">  File: ‘bigfile_link’</span><br><span class="line">  Size: 5368709120      Blocks: 8          IO Block: 4096   regular file</span><br><span class="line">Device: fd01h/64769d    Inode: 26199       Links: 1</span><br><span class="line">Access: (0600/-rw-------)  Uid: (    0/    root)   Gid: (    0/    root)</span><br><span class="line">Access: 2022-12-05 16:26:39.166784814 +0800</span><br><span class="line">Modify: 2022-12-05 16:19:40.734216438 +0800</span><br><span class="line">Change: 2022-12-05 20:33:03.459331364 +0800</span><br><span class="line"> Birth: -</span><br></pre></td></tr></tbody></table></figure>
<p>此时硬链接数<code>Link</code>变为1；</p>
<hr>
<p>符号链接对比：</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng tmp]<span class="comment"># ln -s bigfile_link bigfile_s</span></span><br><span class="line">[root@HongyiZeng tmp]<span class="comment"># stat bigfile_link </span></span><br><span class="line">  File: ‘bigfile_link’</span><br><span class="line">  Size: 5368709120      Blocks: 8          IO Block: 4096   regular file</span><br><span class="line">Device: fd01h/64769d    Inode: 26199       Links: 1</span><br><span class="line">Access: (0600/-rw-------)  Uid: (    0/    root)   Gid: (    0/    root)</span><br><span class="line">Access: 2022-12-05 16:26:39.166784814 +0800</span><br><span class="line">Modify: 2022-12-05 16:19:40.734216438 +0800</span><br><span class="line">Change: 2022-12-05 20:33:03.459331364 +0800</span><br><span class="line"> Birth: -</span><br><span class="line">[root@HongyiZeng tmp]<span class="comment"># stat bigfile_s</span></span><br><span class="line">  File: ‘bigfile_s’ -&gt; ‘bigfile_link’</span><br><span class="line">  Size: 12              Blocks: 0          IO Block: 4096   symbolic link</span><br><span class="line">Device: fd01h/64769d    Inode: 26201       Links: 1</span><br><span class="line">Access: (0777/lrwxrwxrwx)  Uid: (    0/    root)   Gid: (    0/    root)</span><br><span class="line">Access: 2022-12-05 20:34:11.189456100 +0800</span><br><span class="line">Modify: 2022-12-05 20:34:11.189456100 +0800</span><br><span class="line">Change: 2022-12-05 20:34:11.189456100 +0800</span><br><span class="line"> Birth: -</span><br><span class="line">[root@HongyiZeng tmp]<span class="comment"># ll bigfile_s</span></span><br><span class="line">lrwxrwxrwx 1 root root 12 Dec  5 20:34 bigfile_s -&gt; bigfile_link</span><br></pre></td></tr></tbody></table></figure>
<p>可以看到硬链接数并未改变；此外符号链接文件的大小为12字节，物理占用的块甚至为0；文件类型标识也变为了<code>symbolic link</code>和<code>l</code>；</p>
<p>删除原始文件后，发现符号链接文件的链接已成非法链接（红色部分）：</p>
<p><a href="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221205203655039.png" data-fancybox="gallery" data-caption="image-20221205203655039" data-thumb="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221205203655039.png"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221205203655039.png" alt="image-20221205203655039"></a></p>
<hr>
<p>相关的系统调用：</p>
<p><code>link</code> 函数专门用来创建硬链接的，功能和 ln 命令一样。</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">link</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *oldpath, <span class="keyword">const</span> <span class="keyword">char</span> *newpath)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p><code>unlink</code>函数删除一个文件的目录项并减少它的链接数，若成功则返回0，否则返回-1，错误原因存于error。</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span></span><br></pre></td></tr></tbody></table></figure>
<hr>
<p>对比：硬链接不能给分区建立，不能给目录建立，而符号链接可以。</p>
<h4 id="4-2-6-杂项"><a href="#4-2-6-杂项" class="headerlink" title="4.2.6 杂项"></a>4.2.6 杂项</h4><blockquote>
<p>文件的删除、重命名和移动</p>
</blockquote>
<ul>
<li><code>remove</code></li>
</ul>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">remove</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>rename</code>：是<code>mv</code>命令的系统调用</li>
</ul>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rename</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *oldpath, <span class="keyword">const</span> <span class="keyword">char</span> *newpath)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>更改文件的时间</p>
</blockquote>
<ul>
<li><code>utime</code>：可更改文件的最后读的时间和最后修改的时间</li>
</ul>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utime.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">utime</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">const</span> struct utimbuf *times)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>更改当前工作路径</p>
</blockquote>
<ul>
<li><code>chdir</code>：是<code>cd</code>命令的系统调用</li>
</ul>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchdir</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>getcwd</code>：是<code>pwd</code>命令的系统调用</li>
</ul>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">getcwd</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">getwd</span><span class="params">(<span class="keyword">char</span> *buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">get_current_dir_name</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<h4 id="4-2-7-glob"><a href="#4-2-7-glob" class="headerlink" title="4.2.7 glob"></a>4.2.7 glob</h4><p>该节内容为分析目录和读取目录内容。</p>
<p>glob函数原型（模型匹配函数）：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glob.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">glob</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pattern, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="keyword">int</span> (*errfunc) (<span class="keyword">const</span> <span class="keyword">char</span> *epath, <span class="keyword">int</span> eerrno),</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="keyword">glob_t</span> *pglob)</span></span>;</span><br><span class="line"><span class="comment">// 释放glob函数调用的空间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">globfree</span><span class="params">(<span class="keyword">glob_t</span> *pglob)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>pattern</code>： 通配符，要分析的<code>pattern</code>，如<code>/*</code>表示匹配根文件下的所有文件（不包括隐藏文件）   </li>
<li><code>flags</code>：flags参数可以设置特殊要求，如无特殊要求置为0</li>
<li><code>errfunc</code>：函数指针，glob函数执行出错会执行的函数，出错的路径会回填到epath中，出错的原因回填到eerrno中。如不关注错误可设置为<code>NULL</code></li>
<li><code>pglob</code>：解析出来的结果放在这个参数里，是一个结构体指针</li>
<li>返回值：成功返回0，错误返回非0</li>
</ul>
<p>其中，<code>glob_t</code>是一个结构体：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    <span class="comment">// pathc与pathv类似于main函数参数argc与argv</span></span><br><span class="line">    <span class="keyword">size_t</span>    gl_pathc;    <span class="comment">//匹配到的数量</span></span><br><span class="line">    <span class="keyword">char</span>    **gl_pathv;    <span class="comment">//匹配到的元素放在这里</span></span><br><span class="line">    <span class="keyword">size_t</span>    gl_offs; </span><br><span class="line">} <span class="keyword">glob_t</span>;</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>程序实例</p>
</blockquote>
<p>打印出<code>/etc/*.conf</code>的文件名。</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glob.h&gt;</span></span></span><br><span class="line"><span class="comment">// 通配符</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAT <span class="meta-string">"//etc//*.conf"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">errfunc</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *epath, <span class="keyword">int</span> eerrno)</span> </span>{</span><br><span class="line">    <span class="built_in">puts</span>(epath);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"ERROR: %d"</span>, eerrno);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">glob_t</span> globres;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    err = glob(PAT, <span class="number">0</span>, errfunc, &amp;globres);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(err) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"ERROR CODE = %d\n"</span>, err);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; globres.gl_pathc; i++) {</span><br><span class="line">        <span class="built_in">puts</span>(globres.gl_pathv[i]);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 释放空间</span></span><br><span class="line">	globfree(&amp;globres);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>执行结果：</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng fs]<span class="comment"># ./glob </span></span><br><span class="line">/etc/GeoIP.conf</span><br><span class="line">/etc/asound.conf</span><br><span class="line">/etc/chrony.conf</span><br><span class="line">/etc/dat.conf</span><br><span class="line">其余略</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>一组对目录操作的函数</p>
</blockquote>
<p>和对文件操作的函数基于<code>FILE</code>结构体类似，对目录的操作基于名为<code>DIR</code>的结构体。</p>
<p>下面是常用的对目录进行操作的函数，他们的功能可以被<code>glob</code>替代。</p>
<p>暂略</p>
<h2 id="5-进程环境"><a href="#5-进程环境" class="headerlink" title="5 进程环境"></a>5 进程环境</h2><p>本节对应第七章——进程环境；</p>
<h3 id="5-1-main函数"><a href="#5-1-main函数" class="headerlink" title="5.1 main函数"></a>5.1 main函数</h3><p>C程序总是从main函数开始执行，从main函数结束执行。即main是程序的入口和出口。</p>
<p>当内核执行C程序时（使用一个exec函数），在调用main前先调用一个特殊的<strong>启动例程</strong>。可执行程序文件将此启动例程指定为程序的起始地址———这是由连接编辑器设置的，而连接编辑器则由C编译器调用。</p>
<p>启动例程从内核取得命令行参数和环境变量值，然后为按上述方式调用main函数做好安排。</p>
<h3 id="5-2-进程终止"><a href="#5-2-进程终止" class="headerlink" title="5.2 进程终止"></a>5.2 进程终止</h3><h4 id="5-2-1-终止方式"><a href="#5-2-1-终止方式" class="headerlink" title="5.2.1 终止方式"></a>5.2.1 终止方式</h4><p>共有8种方式让进程终止。其中5种为正常退出：</p>
<ol>
<li>从main返回</li>
<li>调用<code>exit</code>（C库函数）</li>
<li>调用<code>_exit</code>或<code>_Exit</code>（系统调用）</li>
<li>最后一个线程从其启动例程返回</li>
<li>从最后一个线程调用<code>pthread_exit</code></li>
</ol>
<p>异常终止有3种方式：</p>
<ol>
<li>调用<code>abort</code></li>
<li>接到一个信号</li>
<li>最后一个线程对取消请求做出响应</li>
</ol>
<h4 id="5-2-2-main函数的返回值"><a href="#5-2-2-main函数的返回值" class="headerlink" title="5.2.2 main函数的返回值"></a>5.2.2 <code>main</code>函数的返回值</h4><p>main函数的返回值给main函数的<strong>父进程</strong>。</p>
<p>假设一个程序名为<code>main_test</code>，则在终端上执行该程序时，父进程为<code>shell</code>：</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./main_test</span><br></pre></td></tr></tbody></table></figure>
<p>可通过<code>$?</code>（表示显示最后命令的退出状态）查看该返回值。</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello World!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>执行结果：</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng fs]<span class="comment"># ./main1 </span></span><br><span class="line">Hello World!</span><br><span class="line">[root@HongyiZeng fs]<span class="comment"># echo $?</span></span><br><span class="line">0</span><br></pre></td></tr></tbody></table></figure>
<p>如果将程序更改为：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello World!\n"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>则执行结果为：</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng fs]<span class="comment"># ./main1 </span></span><br><span class="line">Hello World!</span><br><span class="line">[root@HongyiZeng fs]<span class="comment"># echo $?</span></span><br><span class="line">13</span><br></pre></td></tr></tbody></table></figure>
<p>此时会将<code>printf</code>的返回值（打印字符的个数）作为main函数的返回值给父进程<code>shell</code>。</p>
<h4 id="5-2-3-钩子函数atexit"><a href="#5-2-3-钩子函数atexit" class="headerlink" title="5.2.3 钩子函数atexit"></a>5.2.3 钩子函数<code>atexit</code></h4><p>按照ISO C的规定，一个进程可以登记多至32个函数，这些函数将由<code>exit</code>自动调用。我们称这些函数为<strong>终止处理程序</strong>（<code>exit handler</code>），并调用 <code>atexit</code> 函数来登记这些函数。</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">atexit</span><span class="params">(<span class="keyword">void</span> (*func)(<span class="keyword">void</span>))</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p><code>atexit</code>当程序<strong>正常终止时</strong>，调用指定的函数（终止处理程序） <strong>func</strong>。可以在任何地方注册终止函数，但它会在程序终止的时候被调用。先注册的后调用。</p>
<ul>
<li><strong>func</strong> — 在程序终止时被调用的函数，该函数无参且无返回值，它是一个函数指针，因此传入的参数应该是一个函数的地址，即函数名（函数名就是函数的首地址）。</li>
<li>如果函数成功注册，则该函数返回零，否则返回一个非零值。</li>
</ul>
<blockquote>
<p>程序实例</p>
</blockquote>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 终止处理程序</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"f1() is working!"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 终止处理程序</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"f2() is working!"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 终止处理程序</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f3</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"f3() is working!"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Begin"</span>);</span><br><span class="line">    <span class="comment">// 先注册的后被调用</span></span><br><span class="line">    <span class="comment">// 钩子函数的书写顺序并不是实际执行顺序，atexit会在程序终止时被调用</span></span><br><span class="line">    <span class="comment">// atexit参数用指针来接收，因此需要传入地址，而函数名就是函数的地址</span></span><br><span class="line">    atexit(f1);</span><br><span class="line">    atexit(f2);</span><br><span class="line">    atexit(f3);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"End"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>执行结果：</p>
<figure class="highlight plaintext"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">plaintext</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Begin</span><br><span class="line">End</span><br><span class="line">f3() is working!</span><br><span class="line">f2() is working!</span><br><span class="line">f1() is working!</span><br></pre></td></tr></tbody></table></figure>
<h4 id="5-2-4-exit和-exit"><a href="#5-2-4-exit和-exit" class="headerlink" title="5.2.4 exit和_exit"></a>5.2.4 exit和_exit</h4><p><code>exit</code>是库函数，而<code>_exit</code>是系统调用，前者使用了后者。</p>
<p>除此之外，<code>_exit()</code>执行后会立即返回给内核，而<code>exit()</code>要先执行一些清除和终止操作，然后将控制权交给内核。</p>
<p><a href="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221210113101221.png" data-fancybox="gallery" data-caption="image-20221210113101221" data-thumb="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221210113101221.png"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221210113101221.png" alt="image-20221210113101221"></a></p>
<h3 id="5-3-命令行参数"><a href="#5-3-命令行参数" class="headerlink" title="5.3 命令行参数"></a>5.3 命令行参数</h3><p>暂略</p>
<h3 id="5-4-环境变量"><a href="#5-4-环境变量" class="headerlink" title="5.4 环境变量"></a>5.4 环境变量</h3><h4 id="5-4-1-简介"><a href="#5-4-1-简介" class="headerlink" title="5.4.1 简介"></a>5.4.1 简介</h4><p>环境变量的含义：程序（操作系统命令和应用程序）的执行都需要运行环境，这个环境是由多个环境变量组成的。</p>
<p>按变量的周期划为永久变量和临时性变量2种：</p>
<ol>
<li>永久变量：通过修改配置文件，配置之后变量永久生效。</li>
<li>临时性变量：使用命令如export等命令设置，设置之后马上生效。当关闭shell的时候失效（这种主要用于测试比较多）。</li>
</ol>
<p>按照影响范围分为用户变量和系统变量2种：</p>
<ol>
<li>用户变量（局部变量）：修改的设置只对某个用户的路径或执行起作用；</li>
<li>系统变量（全局变量）：影响范围是整个系统；</li>
</ol>
<p>环境变量本质上是一个<code>kv键值对</code>。</p>
<h4 id="5-4-2-查看环境变量"><a href="#5-4-2-查看环境变量" class="headerlink" title="5.4.2 查看环境变量"></a>5.4.2 查看环境变量</h4><p>在Shell下，用<code>env</code>命令查看<strong>当前用户</strong>全部的环境变量。</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng fs]<span class="comment"># env</span></span><br><span class="line">XDG_SESSION_ID=139874</span><br><span class="line">HOSTNAME=HongyiZeng</span><br><span class="line">TERM=xterm-256color</span><br><span class="line">SHELL=/bin/bash</span><br><span class="line">HISTSIZE=3000</span><br><span class="line">SSH_TTY=/dev/pts/0</span><br><span class="line">USER=root</span><br><span class="line">MAIL=/var/spool/mail/root</span><br><span class="line">PATH=/usr/<span class="built_in">local</span>/sbin:/usr/<span class="built_in">local</span>/bin:/usr/sbin:/usr/bin:/usr/<span class="built_in">local</span>/java/jdk1.8.0_161/bin:/root/bin:/root/bin</span><br><span class="line">PWD=/usr/<span class="built_in">local</span>/linux_c/fs</span><br><span class="line">JAVA_HOME=/usr/<span class="built_in">local</span>/java/jdk1.8.0_161</span><br><span class="line">LANG=en_US.UTF-8</span><br><span class="line">NEXUS_HOME=/usr/<span class="built_in">local</span>/nexus/nexus-3.20.1-01</span><br><span class="line">SHLVL=1</span><br><span class="line">HOME=/root</span><br><span class="line">LOGNAME=root</span><br><span class="line">CLASSPATH=/usr/<span class="built_in">local</span>/java/jdk1.8.0_161/lib/</span><br><span class="line">SSH_CONNECTION=81.69.102.136 35390 10.0.24.5 22</span><br><span class="line">LESSOPEN=||/usr/bin/lesspipe.sh %s</span><br><span class="line">PROMPT_COMMAND=<span class="built_in">history</span> -a; <span class="built_in">history</span> -a; <span class="built_in">printf</span> <span class="string">"\033]0;%s@%s:%s\007"</span> <span class="string">"<span class="variable">${USER}</span>"</span> <span class="string">"<span class="variable">${HOSTNAME%%.*}</span>"</span> <span class="string">"<span class="variable">${PWD/#$HOME/~}</span>"</span></span><br><span class="line">XDG_RUNTIME_DIR=/run/user/0</span><br><span class="line">HISTTIMEFORMAT=%F %T </span><br><span class="line">_=/usr/bin/env</span><br><span class="line">OLDPWD=/usr/<span class="built_in">local</span>/linux_c</span><br></pre></td></tr></tbody></table></figure>
<p><code>export</code>命令显示<strong>当前系统</strong>定义的所有环境变量。</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng fs]<span class="comment"># export</span></span><br><span class="line"><span class="built_in">declare</span> -x CLASSPATH=<span class="string">"/usr/local/java/jdk1.8.0_161/lib/"</span></span><br><span class="line"><span class="built_in">declare</span> -x HISTSIZE=<span class="string">"3000"</span></span><br><span class="line"><span class="built_in">declare</span> -x HISTTIMEFORMAT=<span class="string">"%F %T "</span></span><br><span class="line"><span class="built_in">declare</span> -x HOME=<span class="string">"/root"</span></span><br><span class="line"><span class="built_in">declare</span> -x HOSTNAME=<span class="string">"HongyiZeng"</span></span><br><span class="line"><span class="built_in">declare</span> -x JAVA_HOME=<span class="string">"/usr/local/java/jdk1.8.0_161"</span></span><br><span class="line"><span class="built_in">declare</span> -x LANG=<span class="string">"en_US.UTF-8"</span></span><br><span class="line"><span class="built_in">declare</span> -x LESSOPEN=<span class="string">"||/usr/bin/lesspipe.sh %s"</span></span><br><span class="line"><span class="built_in">declare</span> -x LOGNAME=<span class="string">"root"</span></span><br><span class="line"><span class="built_in">declare</span> -x MAIL=<span class="string">"/var/spool/mail/root"</span></span><br><span class="line"><span class="built_in">declare</span> -x NEXUS_HOME=<span class="string">"/usr/local/nexus/nexus-3.20.1-01"</span></span><br><span class="line"><span class="built_in">declare</span> -x OLDPWD=<span class="string">"/usr/local/linux_c"</span></span><br><span class="line"><span class="built_in">declare</span> -x PATH=<span class="string">"/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/usr/local/java/jdk1.8.0_161/bin:/root/bin:/root/bin"</span></span><br><span class="line"><span class="built_in">declare</span> -x PROMPT_COMMAND=<span class="string">"history -a; history -a; printf \"\\033]0;%s@%s:%s\\007\" \"\${USER}\" \"\${HOSTNAME%%.*}\" \"\${PWD/#\$HOME/~}\""</span></span><br><span class="line"><span class="built_in">declare</span> -x PWD=<span class="string">"/usr/local/linux_c/fs"</span></span><br><span class="line"><span class="built_in">declare</span> -x SHELL=<span class="string">"/bin/bash"</span></span><br><span class="line"><span class="built_in">declare</span> -x SHLVL=<span class="string">"1"</span></span><br><span class="line"><span class="built_in">declare</span> -x SSH_CLIENT=<span class="string">"81.69.102.136 35390 22"</span></span><br><span class="line"><span class="built_in">declare</span> -x SSH_CONNECTION=<span class="string">"81.69.102.136 35390 10.0.24.5 22"</span></span><br><span class="line"><span class="built_in">declare</span> -x SSH_TTY=<span class="string">"/dev/pts/0"</span></span><br><span class="line"><span class="built_in">declare</span> -x TERM=<span class="string">"xterm-256color"</span></span><br><span class="line"><span class="built_in">declare</span> -x USER=<span class="string">"root"</span></span><br><span class="line"><span class="built_in">declare</span> -x XDG_RUNTIME_DIR=<span class="string">"/run/user/0"</span></span><br><span class="line"><span class="built_in">declare</span> -x XDG_SESSION_ID=<span class="string">"139874"</span></span><br></pre></td></tr></tbody></table></figure>
<p>查看某个环境变量的值：</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$KEY</span></span><br></pre></td></tr></tbody></table></figure>
<p>例如，查看<code>PATH</code>的值：</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng fs]<span class="comment"># echo $PATH</span></span><br><span class="line">/usr/<span class="built_in">local</span>/sbin:/usr/<span class="built_in">local</span>/bin:/usr/sbin:/usr/bin:/usr/<span class="built_in">local</span>/java/jdk1.8.0_161/bin:/root/bin:/root/bin</span><br></pre></td></tr></tbody></table></figure>
<h4 id="5-4-3-设置环境变量"><a href="#5-4-3-设置环境变量" class="headerlink" title="5.4.3 设置环境变量"></a>5.4.3 设置环境变量</h4><p>在用户的家目录<code>/home/用户名</code>下，有几个特别的文件：</p>
<ul>
<li><code>.bash_profile</code>（推荐首选）：当用户登录时执行，每个用户都可以使用该文件来配置<strong>专属于自己的环境变量</strong>。</li>
<li><code>.bashrc</code>：当用户登录时以及每次打开新的Shell时该文件都将被读取，不推荐在里面配置用户专用的环境变量，因为每开一个Shell，该文件都会被读取一次，效率肯定受影响。</li>
<li><code>.bash_logout</code>：当每次退出系统（退出bash shell）时执行该文件。</li>
<li><code>.bash_history</code>：保存了当前用户使用过的历史命令</li>
</ul>
<h4 id="5-4-4-环境表"><a href="#5-4-4-环境表" class="headerlink" title="5.4.4 环境表"></a>5.4.4 环境表</h4><p>每个程序都接收到一张环境表。与参数表一样，环境表也是一个字符指针数组，其中每个指针包含一个以<code>null</code>结束的C字符串的地址。</p>
<p>全局变量<code>environ</code>则包含了该指针数组的地址∶</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> **environ;</span><br></pre></td></tr></tbody></table></figure>
<p>例如，如果该环境包含5个字符串，那么它看起来如图中所示。其中，每个字符串的结尾处都显式地有一个null字节。我们称 <code>environ</code> 为环境指针，指针数组为环境表，其中各指针指向的字符串为环境字符串。</p>
<p><a href="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221210163517747.png" data-fancybox="gallery" data-caption="image-20221210163517747" data-thumb="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221210163517747.png"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221210163517747.png" alt="image-20221210163517747"></a></p>
<blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用声明外部的变量</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> **environ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; environ[i] != <span class="literal">NULL</span>; i++) {</span><br><span class="line">        <span class="built_in">puts</span>(environ[i]);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>相关库函数：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据环境变量的键name来获取环境变量的值</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">getenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 键name，值value，overwrite是否覆盖</span></span><br><span class="line"><span class="comment">// 当name存在时，且overwrite为1，表示改变环境变量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> <span class="keyword">char</span> *value, <span class="keyword">int</span> overwrite)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据key删除环境变量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unsetenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>程序实例</p>
</blockquote>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    <span class="built_in">puts</span>(getenv(<span class="string">"PATH"</span>));</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="5-5-共享库"><a href="#5-5-共享库" class="headerlink" title="5.5 共享库"></a>5.5 共享库</h3><p>共享库使得可执行文件中不再需要包含公用的库函数，而只需在所有进程都可引用的存储区中保存这种库例程的一个副本。</p>
<p>程序第一次执行或者第一次调用某个库函数时，用动态链接方法将程序与共享库函数相链接。这减少了每个可执行文件的长度，但增加了一些运行时间开销。这种时间开销发生在该程序第一次被执行时，或者每个共享库函数第一次被调用时。</p>
<p>共享库的另一个优点是可以用库函数的新版本代替老版本而无需对使用该库的程序重新连接编辑（假定参数的数目和类型都没有发生改变）。</p>
<blockquote>
<p>动态库的相关库函数</p>
</blockquote>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dladdr,  dlclose,  dlerror,  dlopen,  dlsym, dlvsym - programming interface to dynamic linking loader</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="comment">// 该函数将打开一个新库，并把它装入内存。该函数主要用来加载库中的符号，这些符号在编译的时候是不知道的。这种机制使得在系统中添加或者删除一个模块时，都不需要重新进行编译</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">dlopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个描述最后一次调用dlopen、dlsym，或dlclose的错误信息的字符串</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">dlerror</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在打开的动态库中查找符号的值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">dlsym</span><span class="params">(<span class="keyword">void</span> *handle, <span class="keyword">const</span> <span class="keyword">char</span> *symbol)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭动态库</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dlclose</span><span class="params">(<span class="keyword">void</span> *handle)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<h3 id="5-6-函数间跳转"><a href="#5-6-函数间跳转" class="headerlink" title="5.6 函数间跳转"></a>5.6 函数间跳转</h3><blockquote>
<p>补充：goto语句</p>
</blockquote>
<p>C 语言中的 goto 语句允许把控制无条件转移到<strong>同一函数内</strong>的被标记的语句。</p>
<p>语法：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">goto</span> label;</span><br><span class="line">..</span><br><span class="line">.</span><br><span class="line">label: statement;</span><br></pre></td></tr></tbody></table></figure>
<p>在这里，label 可以是任何除 C 关键字以外的纯文本，它可以设置在 C 程序中 goto 语句的前面或者后面。</p>
<p><a href="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221211193000103.png" data-fancybox="gallery" data-caption="image-20221211193000103" data-thumb="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221211193000103.png"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221211193000103.png" alt="image-20221211193000103"></a></p>
<p>代码示例：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">   <span class="comment">/* 局部变量定义 */</span></span><br><span class="line">   <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* do 循环执行 */</span></span><br><span class="line">   LOOP:</span><br><span class="line">   <span class="keyword">do</span> {</span><br><span class="line">      <span class="keyword">if</span>( a == <span class="number">15</span>) {</span><br><span class="line">         <span class="comment">/* 跳过迭代 */</span></span><br><span class="line">         a = a + <span class="number">1</span>;</span><br><span class="line">         <span class="keyword">goto</span> LOOP;</span><br><span class="line">      }</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"a 的值： %d\n"</span>, a);</span><br><span class="line">      a++;</span><br><span class="line">   } <span class="keyword">while</span>(a &lt; <span class="number">20</span>);</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>执行结果：</p>
<figure class="highlight plaintext"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">plaintext</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a 的值： 10</span><br><span class="line">a 的值： 11</span><br><span class="line">a 的值： 12</span><br><span class="line">a 的值： 13</span><br><span class="line">a 的值： 14</span><br><span class="line">a 的值： 16</span><br><span class="line">a 的值： 17</span><br><span class="line">a 的值： 18</span><br><span class="line">a 的值： 19</span><br></pre></td></tr></tbody></table></figure>
<hr>
<p><code>setjmp</code>和<code>longjmp</code>可以实现非局部控制转移，即从一个函数到另外一个函数的跳转。</p>
<p>函数原型：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setjmp</span><span class="params">(jmp_buf buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">longjmp</span><span class="params">(jmp_buf env, <span class="keyword">int</span> val)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p><code>setjmp</code>函数用于记录当前位置，保存调用函数的栈环境在结构体<code>jmp_buf buf</code>（相当于保护现场）。函数输入参数为<code>jmp_buf</code>类型（这个结构体类似于goto的跳转标识），返回整型。当第一次调用时（设置跳转点），它的值为0；当第二次调用时（从别处跳转回来，即调用<code>longjmp</code>时）返回非零值；总之<strong>执行一次，返回两次</strong>，因此，<code>setjmp</code>函数后常常跟上分支语句。</p>
</li>
<li><p><code>longjmp</code>的作用是使用<code>setjmp</code>保存在<code>buf</code>中的栈环境信息返回到<code>setjmp</code>的位置，也就是当执行<code>longjmp</code>时程序又回到<code>setjmp</code>处（相当于恢复现场）。形参<code>val</code>是调用<code>longjmp</code>时<code>setjmp</code>函数返回的值，为非零值，如果故意设置为0，也会被修改为1；</p>
</li>
</ul>
<blockquote>
<p>程序实例</p>
</blockquote>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">d</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s():Begin.\n"</span>, __FUNCTION__);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s():End.\n"</span>, __FUNCTION__);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">c</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s():Begin.\n"</span>, __FUNCTION__);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s():Call d().\n"</span>, __FUNCTION__);</span><br><span class="line">    d();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s():d() returned.\n"</span>, __FUNCTION__);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s():End.\n"</span>, __FUNCTION__);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s():Begin.\n"</span>, __FUNCTION__);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s():Call c().\n"</span>, __FUNCTION__);</span><br><span class="line">    c();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s():c() returned.\n"</span>, __FUNCTION__);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s():End.\n"</span>, __FUNCTION__);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s():Begin.\n"</span>, __FUNCTION__);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s():Call b().\n"</span>, __FUNCTION__);</span><br><span class="line">    b();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s():b() returned.\n"</span>, __FUNCTION__);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s():End.\n"</span>, __FUNCTION__);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s():Begin.\n"</span>, __FUNCTION__);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s():Call a().\n"</span>, __FUNCTION__);</span><br><span class="line">    a();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s():a() returned.\n"</span>, __FUNCTION__);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s():End.\n"</span>, __FUNCTION__);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>执行结果：</p>
<figure class="highlight plaintext"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">plaintext</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">main():Begin.</span><br><span class="line">main():Call a().</span><br><span class="line">a():Begin.</span><br><span class="line">a():Call b().</span><br><span class="line">b():Begin.</span><br><span class="line">b():Call c().</span><br><span class="line">c():Begin.</span><br><span class="line">c():Call d().</span><br><span class="line">d():Begin.</span><br><span class="line">d():End.</span><br><span class="line">c():d() returned.</span><br><span class="line">c():End.</span><br><span class="line">b():c() returned.</span><br><span class="line">b():End.</span><br><span class="line">a():b() returned.</span><br><span class="line">a():End.</span><br><span class="line">main():a() returned.</span><br><span class="line">main():End.</span><br></pre></td></tr></tbody></table></figure>
<p>注：ANSI C 定义了许多宏。在编程中可以使用这些宏，但是不能直接修改这些预定义的宏。</p>
<p>例如：</p>
<figure class="highlight plaintext"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">plaintext</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__DATE__ 当前日期，一个以 “MMM DD YYYY” 格式表示的字符串常量。</span><br><span class="line">__TIME__ 当前时间，一个以 “HH:MM:SS” 格式表示的字符串常量。</span><br><span class="line">__FILE__ 这会包含当前文件名，一个字符串常量。</span><br><span class="line">__LINE__ 这会包含当前行号，一个十进制常量。</span><br><span class="line">__FUNCTION__ 程序预编译时预编译器将用所在的函数名，返回值是字符串;</span><br></pre></td></tr></tbody></table></figure>
<p>现在改写程序，在函数a进行<code>setjmp</code>，函数d进行<code>longjmp</code>：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 跳转点的现场环境</span></span><br><span class="line"><span class="keyword">static</span> jmp_buf save;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">d</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s():Begin.\n"</span>, __FUNCTION__);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s():Jump now!.\n"</span>, __FUNCTION__);</span><br><span class="line">    <span class="comment">// 向save跳转，并携带返回值为6</span></span><br><span class="line">    longjmp(save, <span class="number">6</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s():End.\n"</span>, __FUNCTION__);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">c</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s():Begin.\n"</span>, __FUNCTION__);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s():Call d().\n"</span>, __FUNCTION__);</span><br><span class="line">    d();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s():d() returned.\n"</span>, __FUNCTION__);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s():End.\n"</span>, __FUNCTION__);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s():Begin.\n"</span>, __FUNCTION__);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s():Call c().\n"</span>, __FUNCTION__);</span><br><span class="line">    c();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s():c() returned.\n"</span>, __FUNCTION__);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s():End.\n"</span>, __FUNCTION__);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    <span class="comment">// 返回值</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s():Begin.\n"</span>, __FUNCTION__);</span><br><span class="line">    <span class="comment">// 设置跳转点</span></span><br><span class="line">    <span class="comment">// setjmp一次调用，两次返回</span></span><br><span class="line">    ret = setjmp(save);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">0</span>) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s():Call b().\n"</span>, __FUNCTION__);</span><br><span class="line">        b();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s():b() returned.\n"</span>, __FUNCTION__);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s():Jumped back here with code %d.\n"</span>, __FUNCTION__, ret);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s():End.\n"</span>, __FUNCTION__);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s():Begin.\n"</span>, __FUNCTION__);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s():Call a().\n"</span>, __FUNCTION__);</span><br><span class="line">    a();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s():a() returned.\n"</span>, __FUNCTION__);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s():End.\n"</span>, __FUNCTION__);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>执行结果：</p>
<figure class="highlight plaintext"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">plaintext</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">main():Begin.</span><br><span class="line">main():Call a().</span><br><span class="line">a():Begin.</span><br><span class="line">a():Call b().</span><br><span class="line">b():Begin.</span><br><span class="line">b():Call c().</span><br><span class="line">c():Begin.</span><br><span class="line">c():Call d().</span><br><span class="line">d():Begin.</span><br><span class="line">d():Jump now!.</span><br><span class="line">a():Jumped back here with code 6.</span><br><span class="line">a():End.</span><br><span class="line">main():a() returned.</span><br><span class="line">main():End.</span><br></pre></td></tr></tbody></table></figure>
<h3 id="5-7-资源的获取和控制"><a href="#5-7-资源的获取和控制" class="headerlink" title="5.7 资源的获取和控制"></a>5.7 资源的获取和控制</h3><p>获取或设置资源使用限制：linux下每种资源都有相关的软硬限制，软限制是内核强加给相应资源的限制值，硬限制是软限制的最大值。</p>
<p>非授权调用的进程只能将其软限制指定为<code>0~硬限制范围中的某个值</code>，同时能不可逆转地降低其硬限制。</p>
<p>授权进程（root用户）可以任意改变其软硬限制。</p>
<p>函数原型：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getrlimit</span><span class="params">(<span class="keyword">int</span> resource, struct rlimit *rlim)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setrlimit</span><span class="params">(<span class="keyword">int</span> resource, <span class="keyword">const</span> struct rlimit *rlim)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p><code>rlimit</code>结构体定义如下：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> {</span></span><br><span class="line">　　<span class="keyword">rlim_t</span> rlim_cur; <span class="comment">// 软限制</span></span><br><span class="line">　　<span class="keyword">rlim_t</span> rlim_max; <span class="comment">// 硬限制</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p><code>resource</code>的选择有：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">RLIMIT_AS <span class="comment">//进程的最大虚内存空间，字节为单位。</span></span><br><span class="line">RLIMIT_CORE <span class="comment">//内核转存文件的最大长度。</span></span><br><span class="line">RLIMIT_CPU <span class="comment">//最大允许的CPU使用时间，秒为单位。当进程达到软限制，内核将给其发送SIGXCPU信号，这一信号的默认行为是终止进程的执行。然而，可以捕捉信号，处理句柄可将控制返回给主程序。如果进程继续耗费CPU时间，核心会以每秒一次的频率给其发送SIGXCPU信号，直到达到硬限制，那时将给进程发送 SIGKILL信号终止其执行。</span></span><br><span class="line">RLIMIT_DATA <span class="comment">//进程数据段的最大值。</span></span><br><span class="line">RLIMIT_FSIZE <span class="comment">//进程可建立的文件的最大长度。如果进程试图超出这一限制时，核心会给其发送SIGXFSZ信号，默认情况下将终止进程的执行。</span></span><br><span class="line">RLIMIT_LOCKS <span class="comment">//进程可建立的锁和租赁的最大值。</span></span><br><span class="line">RLIMIT_MEMLOCK <span class="comment">//进程可锁定在内存中的最大数据量，字节为单位。</span></span><br><span class="line">RLIMIT_MSGQUEUE <span class="comment">//进程可为POSIX消息队列分配的最大字节数。</span></span><br><span class="line">RLIMIT_NICE <span class="comment">//进程可通过setpriority() 或 nice()调用设置的最大完美值。</span></span><br><span class="line">RLIMIT_NOFILE <span class="comment">//指定比进程可打开的最大文件描述词大一的值，超出此值，将会产生EMFILE错误。</span></span><br><span class="line">RLIMIT_NPROC <span class="comment">//用户可拥有的最大进程数。</span></span><br><span class="line">RLIMIT_RTPRIO <span class="comment">//进程可通过sched_setscheduler 和 sched_setparam设置的最大实时优先级。</span></span><br><span class="line">RLIMIT_SIGPENDING <span class="comment">//用户可拥有的最大挂起信号数。</span></span><br><span class="line">RLIMIT_STACK <span class="comment">//最大的进程堆栈，以字节为单位。</span></span><br></pre></td></tr></tbody></table></figure>
<p>返回值：</p>
<ul>
<li>成功执行时，返回0。失败返回-1，errno被设为以下的某个值</li>
<li><code>EFAULT</code>：rlim指针指向的空间不可访问</li>
<li><code>EINVAL</code>：参数无效</li>
<li><code>EPERM</code>：增加资源限制值时，权能不允许</li>
</ul>
<h2 id="6-进程控制"><a href="#6-进程控制" class="headerlink" title="6 进程控制"></a>6 进程控制</h2><p>该节对应第八章——进程控制。</p>
<h3 id="6-1-进程标识"><a href="#6-1-进程标识" class="headerlink" title="6.1 进程标识"></a>6.1 进程标识</h3><p>每个进程都有一个<strong>非负整型</strong>表示的唯一进程ID。因为进程ID标识符总是唯一的，常将其用作其他标识符的一部分以保证其唯一性。例如，应用程序有时就把进程 ID 作为名字的一部分来创建一个唯一的文件名。</p>
<p>进程标识符的类型为<code>pid_t</code>，其本质上是一个<strong>无符号整型（unsigned int）</strong>的类型别名。</p>
<p>进程ID是可复用的。当一个进程终止后，其进程ID就成为复用的候选者。大多数 UNIX 系统实现<strong>延迟复用算法</strong>，使得赋予新建进程的 ID不同于最近终止进程所使用的ID。这防止了将新进程误认为是使用同一ID的某个已终止的先前进程。</p>
<hr>
<p>系统中有一些专用进程，但具体细节随实现而不同。</p>
<ul>
<li>ID为0的进程通常是<strong>调度进程</strong>，常常被称为交换进程（swapper）。该进程是内核的一部分，它并不执行任何硬盘上的程序，因此也被称为系统进程。</li>
<li>进程ID1通常是 <code>init</code> 进程，在自举过程结束时由内核调用。该进程的程序文件在UNIX的早期版本中是<code>/etc/init</code>，在较新版本中是<code>/sbin/init</code>。此进程负责在自举内核后启动一个UNIX系统。<code>init</code> 进程决不会终止。它是一个普通的用户进程（与交换进程不同，它不是内核中的系统进程），但是它以超级用户特权运行。</li>
</ul>
<blockquote>
<p>常用系统调用</p>
</blockquote>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回该函数进程的父进程标识符</span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getppid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回当前进程标识符</span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getpid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>补充：<code>ps</code>命令</p>
</blockquote>
<p>Linux 中的 ps 命令是 <code>Process Status</code> 的缩写。ps 命令用来列出系统中当前正在运行的那些进程，就是执行 ps 命令的那个时刻的那些进程的快照。</p>
<p>参数：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-e</code></td>
<td>显示所有进程</td>
</tr>
<tr>
<td><code>-f</code></td>
<td>全格式</td>
</tr>
<tr>
<td><code>-l</code></td>
<td>长格式</td>
</tr>
<tr>
<td><code>a</code></td>
<td>显示终端上的所有进程，包括其他用户的进程</td>
</tr>
<tr>
<td><code>r</code></td>
<td>只显示正在运行的进程</td>
</tr>
<tr>
<td><code>x</code></td>
<td>显示没有控制终端的进程</td>
</tr>
</tbody>
</table>
</div>
<p>常用组合：</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux <span class="comment"># 查看全部进程,以用户为主的格式显示进程情况</span></span><br></pre></td></tr></tbody></table></figure>
<p><a href="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20230227143730142.png" data-fancybox="gallery" data-caption="image-20230227143730142" data-thumb="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20230227143730142.png"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20230227143730142.png" alt="image-20230227143730142"></a></p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps ef <span class="comment"># 显示出linux机器所有详细的进程信息</span></span><br></pre></td></tr></tbody></table></figure>
<p><a href="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20230227143615045.png" data-fancybox="gallery" data-caption="image-20230227143615045" data-thumb="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20230227143615045.png"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20230227143615045.png" alt="image-20230227143615045"></a></p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux | grep bash</span><br></pre></td></tr></tbody></table></figure>
<p><a href="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20230227143926787.png" data-fancybox="gallery" data-caption="image-20230227143926787" data-thumb="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20230227143926787.png"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20230227143926787.png" alt="image-20230227143926787"></a></p>
<h3 id="6-2-进程产生"><a href="#6-2-进程产生" class="headerlink" title="6.2 进程产生"></a>6.2 进程产生</h3><h4 id="6-2-1-fork"><a href="#6-2-1-fork" class="headerlink" title="6.2.1 fork"></a>6.2.1 fork</h4><p><code>init</code>进程：pid为1，是所有进程的祖先进程，注意不是父进程。</p>
<p>一个现有的进程可以调用<code>fork</code>函数创建一个新进程：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">fork</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p>由fork创建的新进程被称为<strong>子进程</strong>（child process）。</p>
<p>返回值：<strong>fork函数被调用一次，但返回两次</strong>。子进程的返回值是<code>0</code>，父进程的返回值则是新建子进程的进程PID。如果失败则返回<code>-1</code>，并设置<code>errno</code>。和<code>setjmp</code>类似，fork语句后常常跟上分支语句进行判断。</p>
<p><strong>子进程和父进程继续执行fork调用之后的指令</strong>。子进程是父进程的副本。例如，子进程获得父进程数据空间、堆、栈和<strong>缓冲区</strong>和文件描述符的副本。注意，这是子进程所拥有的副本。父进程和子进程并不共享这些存储空间部分，除了读时共享的部分。</p>
<ul>
<li><p>fork后父子进程的区别</p>
<ul>
<li><p>fork返回值不同</p>
</li>
<li><p>两个进程的<code>pid</code>不同</p>
</li>
<li><p>两个进程的<code>ppid</code>也不同，父进程的ppid是它的父进程pid，而子进程的ppid是创建它的进程的pid</p>
</li>
<li><p>父进程的未决信号和文件锁不继承</p>
</li>
<li><p>子进程的资源利用量归零</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>程序实例1——<code>fork</code>的使用</p>
</blockquote>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[%d]:Begin!\n"</span>, getpid());</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="comment">// ---------------------------</span></span><br><span class="line">    <span class="comment">// 父进程调用fork后，父子进程都从这里开始执行</span></span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">"fork()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>) { <span class="comment">// 如果返回值pid为0，则为子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[%d]:Child is working!\n"</span>, getpid());</span><br><span class="line">    } <span class="keyword">else</span> { <span class="comment">// 如果返回值pid大于0，则为父进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[%d]:Parent is working!\n"</span>, getpid());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[%d]:End!\n"</span>, getpid());</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果：（可能形式）</p>
<figure class="highlight plaintext"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">plaintext</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng proc]# ./fork1 </span><br><span class="line">[16023]:Begin!</span><br><span class="line">[16023]:Parent is working!</span><br><span class="line">[16023]:End!</span><br><span class="line">[root@HongyiZeng proc]# [16024]:Child is working!</span><br><span class="line">[16024]:End!</span><br></pre></td></tr></tbody></table></figure>
<p>一般来说，在fork之后是父进程先执行还是子进程先执行是不确定的，这取决于内核所使用的<strong>调度算法</strong>。</p>
<p>如果在main程序返回前添加一行：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getchar();</span><br></pre></td></tr></tbody></table></figure>
<p>使得父子进程都暂停，再使用命令：</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps axf</span><br></pre></td></tr></tbody></table></figure>
<p>可以看到两个进程与bash的关系如下：</p>
<p><a href="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221212095917346.png" data-fancybox="gallery" data-caption="image-20221212095917346" data-thumb="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221212095917346.png"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221212095917346.png" alt="image-20221212095917346"></a></p>
<blockquote>
<p>程序实例2——<code>fflush</code>的重要性</p>
</blockquote>
<p>对于上述程序的结果，注意到<code>Begin</code>只打印了一次：</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng proc]<span class="comment"># ./fork1 </span></span><br><span class="line">[16023]:Begin!</span><br><span class="line">[16023]:Parent is working!</span><br><span class="line">[16023]:End!</span><br><span class="line">[16024]:Child is working!</span><br><span class="line">[16024]:End!</span><br></pre></td></tr></tbody></table></figure>
<p>如果将该打印信息重定向至某个文件：</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./fork1 &gt; /tmp/out</span><br></pre></td></tr></tbody></table></figure>
<p>再查看该文件的内容：</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng proc]<span class="comment"># cat /tmp/out</span></span><br><span class="line">[18060]:Begin!</span><br><span class="line">[18060]:Parent is working!</span><br><span class="line">[18060]:End!</span><br><span class="line">[18060]:Begin!</span><br><span class="line">[18061]:Child is working!</span><br><span class="line">[18061]:End!</span><br></pre></td></tr></tbody></table></figure>
<p>注意到<code>Begin</code>打印了两次。</p>
<p>原因：对于重定向至文件，采用的是全缓冲（除标准输出和标准错误输出），只有进程结束或者缓冲满的时候才刷新缓冲区（遇到换行符不刷新），将缓冲区的内容写入到文件。因此，父进程<code>fork</code>时，尚未刷新缓冲区，因此缓冲区的内容<code>[18060]:Begin!</code>（注意进程号已经固定了！）被复制到子进程的缓冲区中，当父子进程执行结束时，强制刷新，输出两次<code>[18060]:Begin!</code>。</p>
<p>为防止缓冲区内容被复制，父进程在<code>fork</code>之前需要强制刷新所有已经打开的流：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[%d]:Begin!\n"</span>, getpid());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 强制刷新所有打开的流!!!</span></span><br><span class="line">    fflush(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 再调用fork</span></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="comment">// ---------------------------</span></span><br><span class="line">    <span class="comment">// 父进程调用fork后，父子进程都从这里开始执行</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>此时，只打印了一句<code>Begin</code>：</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng proc]<span class="comment"># ./fork1 &gt; /tmp/out</span></span><br><span class="line">[root@HongyiZeng proc]<span class="comment"># cat /tmp/out</span></span><br><span class="line">[19853]:Begin!</span><br><span class="line">[19853]:Parent is working!</span><br><span class="line">[19853]:End!</span><br><span class="line">[19854]:Child is working!</span><br><span class="line">[19854]:End!</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>程序实例3——找质数</p>
</blockquote>
<p>需求：找出<code>30000000~30000200</code>的所有质数。</p>
<ul>
<li>单进程版：</li>
</ul>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEFT 30000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RIGHT 30000200</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> i, j, mark;</span><br><span class="line">    <span class="keyword">for</span>(i = LEFT; i &lt;= RIGHT; i++) {</span><br><span class="line">        mark = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">2</span>; j &lt; i/<span class="number">2</span>; j++) {</span><br><span class="line">            <span class="keyword">if</span>(i % j == <span class="number">0</span>) {</span><br><span class="line">                mark = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(mark)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d is a primer.\n"</span>, i);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>打印结果：</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng proc]<span class="comment"># time ./primer0 </span></span><br><span class="line">30000001 is a primer.</span><br><span class="line">30000023 is a primer.</span><br><span class="line">30000037 is a primer.</span><br><span class="line">30000041 is a primer.</span><br><span class="line">30000049 is a primer.</span><br><span class="line">30000059 is a primer.</span><br><span class="line">30000071 is a primer.</span><br><span class="line">30000079 is a primer.</span><br><span class="line">30000083 is a primer.</span><br><span class="line">30000109 is a primer.</span><br><span class="line">30000133 is a primer.</span><br><span class="line">30000137 is a primer.</span><br><span class="line">30000149 is a primer.</span><br><span class="line">30000163 is a primer.</span><br><span class="line">30000167 is a primer.</span><br><span class="line">30000169 is a primer.</span><br><span class="line">30000193 is a primer.</span><br><span class="line">30000199 is a primer.</span><br><span class="line"></span><br><span class="line">real    0m0.967s</span><br><span class="line">user    0m0.950s</span><br><span class="line">sys     0m0.001s</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>多进程协同：</li>
</ul>
<p>一个错误的程序：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEFT 30000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RIGHT 30000200</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> i, j, mark;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">for</span>(i = LEFT; i &lt;= RIGHT; i++) {</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid &lt; <span class="number">0</span>) {</span><br><span class="line">            perror(<span class="string">"fork()"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>) { <span class="comment">// child</span></span><br><span class="line">            mark = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">2</span>; j &lt; i/<span class="number">2</span>; j++) {</span><br><span class="line">                <span class="keyword">if</span>(i % j == <span class="number">0</span>) {</span><br><span class="line">                    mark = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(mark)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d is a primer.\n"</span>, i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>分析：子进程执行完<code>pid==0</code>的分支后，又会执行<code>for</code>循环的部分，此时会再次<code>fork</code>，导致进程数量指数式的增长，超出可用内存。</p>
<p>更正：在执行完<code>pid==0</code>的分支后面（完成了对某个数<code>i</code>的判断的任务），需要正常退出<code>exit(0)</code>：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEFT 30000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RIGHT 30000200</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> i, j, mark;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">for</span>(i = LEFT; i &lt;= RIGHT; i++) {</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid &lt; <span class="number">0</span>) {</span><br><span class="line">            perror(<span class="string">"fork()"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>) { <span class="comment">// child</span></span><br><span class="line">            mark = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">2</span>; j &lt; i/<span class="number">2</span>; j++) {</span><br><span class="line">                <span class="keyword">if</span>(i % j == <span class="number">0</span>) {</span><br><span class="line">                    mark = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(mark)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d is a primer.\n"</span>, i);</span><br><span class="line">            <span class="comment">// 子进程退出</span></span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>执行结果：</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng proc]<span class="comment"># time ./primer1</span></span><br><span class="line">30000037 is a primer.</span><br><span class="line">30000071 is a primer.</span><br><span class="line">30000059 is a primer.</span><br><span class="line">30000079 is a primer.</span><br><span class="line">30000083 is a primer.</span><br><span class="line">30000049 is a primer.</span><br><span class="line">30000023 is a primer.</span><br><span class="line">30000137 is a primer.</span><br><span class="line">30000149 is a primer.</span><br><span class="line">30000041 is a primer.</span><br><span class="line">30000167 is a primer.</span><br><span class="line">30000193 is a primer.</span><br><span class="line">30000109 is a primer.</span><br><span class="line">30000001 is a primer.</span><br><span class="line">30000199 is a primer.</span><br><span class="line">30000169 is a primer.</span><br><span class="line">30000163 is a primer.</span><br><span class="line">30000133 is a primer.</span><br><span class="line"></span><br><span class="line">real    0m0.048s</span><br><span class="line">user    0m0.001s</span><br><span class="line">sys     0m0.008s</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>程序实例4——孤儿进程和僵尸进程</p>
</blockquote>
<p>修改1：在子进程在退出前，先睡眠1000s，这样父进程会先执行完毕而退出。</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> i, j, mark;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">for</span>(i = LEFT; i &lt;= RIGHT; i++) {</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid &lt; <span class="number">0</span>) {</span><br><span class="line">            perror(<span class="string">"fork()"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>) {</span><br><span class="line">            mark = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">2</span>; j &lt; i/<span class="number">2</span>; j++) {</span><br><span class="line">                <span class="keyword">if</span>(i % j == <span class="number">0</span>) {</span><br><span class="line">                    mark = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(mark)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d is a primer.\n"</span>, i);</span><br><span class="line">            <span class="comment">// 子进程睡眠1000s</span></span><br><span class="line">            sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>再使用命令<code>ps axf</code>查看：</p>
<p><a href="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221212105453780.png" data-fancybox="gallery" data-caption="image-20221212105453780" data-thumb="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221212105453780.png"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221212105453780.png" alt="image-20221212105453780"></a></p>
<p>此时201个子进程的状态为<code>S</code>（可中断的睡眠状态），且父进程为<code>init</code>进程（每个进程以顶格形式出现）。这里的子进程在<code>init</code>进程接管之前就是孤儿进程。</p>
<p><strong>孤儿进程</strong>：一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。孤儿进程将被 <code>init</code> 进程所收养，并由 init 进程对它们完成状态收集工作，孤儿进程并不会有什么危害。</p>
<hr>
<p>修改2：在父进程退出之前，先休眠1000s，再查看进程状态。</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> i, j, mark;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">for</span>(i = LEFT; i &lt;= RIGHT; i++) {</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid &lt; <span class="number">0</span>) {</span><br><span class="line">            perror(<span class="string">"fork()"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>) {</span><br><span class="line">            mark = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">2</span>; j &lt; i/<span class="number">2</span>; j++) {</span><br><span class="line">                <span class="keyword">if</span>(i % j == <span class="number">0</span>) {</span><br><span class="line">                    mark = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(mark)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d is a primer.\n"</span>, i);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 父进程睡眠1000s再退出</span></span><br><span class="line">    sleep(<span class="number">1000</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>执行结果：</p>
<p><a href="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221212110215722.png" data-fancybox="gallery" data-caption="image-20221212110215722" data-thumb="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221212110215722.png"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221212110215722.png" alt="image-20221212110215722"></a></p>
<p>可以看到子进程状态为<code>Z</code>，即为僵尸状态。</p>
<p><strong>僵尸进程</strong>：一个进程使用 fork 创建子进程，如果子进程退出，而父进程并没有调用 wait 或 waitpid 获取子进程的状态信息（收尸），那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵尸进程。</p>
<p> 僵尸进程虽然<strong>不占有任何内存空间</strong>，但如果父进程不调用 wait() / waitpid() 的话，那么保留的信息就不会释放，<strong>其进程号就会一直被占用</strong>，而系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程，此即为僵尸进程的危害。</p>
<blockquote>
<p>避免产生僵尸进程的方式</p>
</blockquote>
<ul>
<li><p>僵尸进程和危害：当一个进程已经结束，但是系统没有把它的进程的数据结构完全释放，此时用 ps 察看它的状态是<code>defunt</code>。 僵尸进程占据进程表的空间，而且不能被kill掉因为它已经死了，所以在开发多进程尤其是守护进程时注意要避免产生僵尸进程。</p>
</li>
<li><p>产生原因：子进程先于父进程退出，且父进程没有给子进程收尸。</p>
</li>
<li>和孤儿进程的区别：就是爸爸（父进程）和儿子（子进程）谁先死的问题<ul>
<li>如果当儿子还在世的时候，爸爸去世了，那么儿子就成孤儿了，这个时候儿子就会被init收养，换句话说，init进程充当了儿子的爸爸，所以等到儿子去世的时候，就由init进程来为其收尸。</li>
<li>如果当爸爸还活着的时候，儿子死了，这个时候如果爸爸不给儿子收尸，那么儿子就会变成僵尸进程。</li>
</ul>
</li>
<li><p><code>SIGCHLD</code>信号：当子进程退出时发送给父进程，默认动作是忽略。</p>
</li>
<li><p>避免产生僵尸进程的方式：</p>
</li>
</ul>
<p>方式1：父进程调用wait/waitpid等函数等待子进程结束，如果尚无子进程退出wait会导致父进程阻塞。waitpid可以通过传递<code>WNOHANG</code>使父进程不阻塞立即返回。该方式详见<code>6.3节</code>。</p>
<p>方式2：通过两次调用fork。父进程首先调用fork创建一个子进程然后waitpid等待子进程退出，子进程再fork一个孙进程后退出。这样
子进程退出后会被父进程等待回收，而对于孙子进程其父进程已经退出所以孙进程成为一个孤儿进程，孤儿进程由init进程接管，孙进程结束后，init会等
待回收。</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">"fork"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>) { <span class="comment">// 子进程</span></span><br><span class="line">        <span class="keyword">pid_t</span> newpid;</span><br><span class="line">        newpid = fork();</span><br><span class="line">        <span class="comment">// 检错...</span></span><br><span class="line">        <span class="keyword">if</span>(newpid == <span class="number">0</span>) { <span class="comment">// 孙子进程</span></span><br><span class="line">            <span class="comment">// 做自己的事情</span></span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">// 子进程退出</span></span><br><span class="line">    } <span class="keyword">else</span> { <span class="comment">// 父进程</span></span><br><span class="line">        waitpid(pid, <span class="literal">NULL</span>, <span class="number">0</span>); <span class="comment">// 阻塞等待子进程退出</span></span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>方式3：通过<code>signal</code>通知内核表明父进程对子进程的结束不关心，由内核回收。如果不想让父进程挂起，可以在父进程中加入一条语句：<code>signal(SIGCHLD,SIG_IGN);</code>表示父进程忽略<code>SIGCHLD</code>信号，该信号是子进程退出的时候向父进程发送的。该方式不会阻塞父进程。</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{	</span><br><span class="line">   	<span class="keyword">int</span> i;</span><br><span class="line">  	<span class="keyword">pid_t</span> pid;</span><br><span class="line">	signal(SIGCHLD, SIG_IGN); <span class="comment">// 显式的忽略SIGCHLD信号</span></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) </span><br><span class="line">	{</span><br><span class="line">   		<span class="keyword">if</span> ((pid = fork()) == <span class="number">0</span>)</span><br><span class="line"> 			_exit(<span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">   	sleep(<span class="number">10</span>);</span><br><span class="line">   	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>方式4：对子进程进行wait，释放它们的资源，但是父进程一般没工夫在那里守着，等着子进程的退出，所以，一般使用信号的方式来处理，在收到<code>SIGCHLD</code>信号的时候，在信号处理函数中调用wait操作来释放他们的资源。</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">avoid_zombies_handler</span><span class="params">(<span class="keyword">int</span> signo)</span> </span>{</span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line">	<span class="keyword">int</span> exit_status;</span><br><span class="line">	<span class="keyword">int</span> saved_errno = errno;</span><br><span class="line">	<span class="keyword">while</span> ((pid = waitpid(<span class="number">-1</span>, &amp;exit_status, WNOHANG)) &gt; <span class="number">0</span>) {</span><br><span class="line">		<span class="comment">/* do nothing */</span></span><br><span class="line">	}</span><br><span class="line">	errno = saved_errno;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">child_act</span>;</span></span><br><span class="line">	<span class="built_in">memset</span>(&amp;child_act, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct sigaction));</span><br><span class="line">	</span><br><span class="line">	child_act.sa_handler = avoid_zombies_handler; <span class="comment">// 信号注册函数</span></span><br><span class="line">	child_act.sa_flags = SA_RESTART | SA_NOCLDSTOP;</span><br><span class="line">	sigemptyset(&amp;child_act.sa_mask);</span><br><span class="line">	<span class="keyword">if</span>(sigaction(SIGCHLD, &amp;child_act, <span class="literal">NULL</span>) == <span class="number">-1</span>) { <span class="comment">// 注册失败</span></span><br><span class="line">		perror(<span class="string">"sigaction error"</span>);</span><br><span class="line">		_exit(EXIT_FAILURE);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">		<span class="keyword">if</span> ((pid = fork()) == <span class="number">0</span>)  {<span class="comment">/* child process */</span></span><br><span class="line">			_exit(<span class="number">0</span>);</span><br><span class="line">		}<span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>); <span class="comment">/* parent process */</span></span><br><span class="line">	}</span><br><span class="line">	_exit(EXIT_SUCCESS);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>方式5：使用sigaction对<code>SIGCHLD</code>注册信号处理函数，并设置<code>sa_flags</code>标志位为<code>SA_NOCLDWAIT</code>，这样，当子进程终止时，子进程不会被设置为僵尸进程。</p>
<p><code>SA_NOCLDWAIT</code>在man手册中的描述：</p>
<figure class="highlight plaintext"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">plaintext</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">If signum is SIGCHLD, do not transform children into zombies when they terminate. See also waitpid(2).  This flag is meaningful only when establishing a  handler  for  SIGCHLD,  or when setting that signal's disposition to SIG_DFL.</span><br><span class="line">如果信号是SIGCHLD，不会在孩子终止时将他们变成僵尸。另请参见waitpid（2）。该标志仅在为SIGCHLD建立处理程序或将信号的处理设置为SIG_DFL时才有意义。</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父进程</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>, <span class="title">osa</span>;</span></span><br><span class="line">    <span class="keyword">sigset_t</span> <span class="built_in">set</span>, oset;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 避免子进程成为僵尸进程</span></span><br><span class="line">    sa.sa_handler = SIG_DFL; <span class="comment">// 或者自己定义的处理程序</span></span><br><span class="line">    sigemptyset(&amp;sa.sa_mask);</span><br><span class="line">    sa.sa_flags = SA_NOCLDWAIT;</span><br><span class="line">    sigaction(SIGCHLD, &amp;sa, &amp;osa);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>父子进程之间的文件共享</p>
</blockquote>
<p>fork的一个特性是父进程的所有打开文件描述符都被复制到子进程中。我们说“复制”是因为对每个文件描述符来说，就好像执行了dup函数。父进程和子进程每个相同的打开描述符<strong>共享一个文件表项</strong>。</p>
<p>考虑下述情况，一个进程具有3个不同的打开文件，它们是标准输入、标准输出和标准错误。在从fork返回时，我们有了如图8-2中所示的结构。</p>
<p><a href="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20230307120016882.png" data-fancybox="gallery" data-caption="image-20230307120016882" data-thumb="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20230307120016882.png"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20230307120016882.png" alt="image-20230307120016882"></a></p>
<p>重要的一点是，父进程和子进程共享同一个文件偏移量。</p>
<p>考虑下述情况：一个进程 fork 
了一个子进程，然后等待子进程终止。假定，作为普通处理的一部分，父进程和子进程都向标准输出进行写操作。如果父进程的标准输出已重定向（很可能是由 
shell 
实现的），那么子进程写到该标准输出时，它将更新与父进程共享的该文件的偏移量。在这个例子中，当父进程等待子进程时，子进程写到标准输出：而在子进程终
止后，父进程也写到标准输出上，并且知道其输出会追加在子进程所写数据之后。如果父进程和子进程不共享同一文件偏移量，要实现这种形式的交互就要困难得
多，可能需要父进程显式地动作。</p>
<p>如果父进程和子进程写同一描述符指向的文件，但又没有任何形式的同步（如使父进程等待子进程），那么它们的输出就会相互混合（假定所用的描述符是在fork之前打开的）。</p>
<p>在fork之后处理文件描述符有以下两种常见的情况：</p>
<ul>
<li>父进程等待子进程完成。在这种情况下，父进程无需对其描述符做任何处理。当子进程终止后，它曾进行过读、写操作的任一共享描述符的文件偏移量已做了相应更新。</li>
<li>父进程和子进程各自执行不同的程序段。在这种情况下，在fork之后，<strong>父进程和子进程各自关闭它们不需使用的文件描述符</strong>，这样就不会干扰对方使用的文件描述符。这种方法是网络服务进程经常使用的。</li>
</ul>
<h4 id="6-2-2-vfork"><a href="#6-2-2-vfork" class="headerlink" title="6.2.2 vfork"></a>6.2.2 vfork</h4><p>考虑这样一个场景，父进程使用了一个占用内存很大的数据，此时它fork了一个子进程，而子进程仅仅打印一个字符串就退出了，此时这块很大的数据复制到子进程的内存空间中，造成了很大的内存浪费。</p>
<p>为了解决这个问题，在<code>fork</code>实现中，增加了<strong>读时共享，写时复制（Copy-On-Write，COW）</strong>的机制。写时复制可以避免拷贝大量根本就不会使用的数据（地址空间包含的数据多达数十兆）。因此可以看出写时复制极大提升了Linux系统下fork函数运行的性能。</p>
<p>写时复制指的是子进程的页表项指向与父进程相同的物理页，这也只需要拷贝父进程的页表项就可以了，不会复制整个内存地址空间，同时把这些页表项标记为<strong>只读</strong>。</p>
<ul>
<li><p>读时共享：如果父子进行都不对页面进行操作或只读，那么便一直共享同一份物理页面。</p>
</li>
<li><p>写时复制：只要父子进程有一个尝试进行修改某一个页面（写时），那么就会发生缺页异常。那么内核便会为该页面创建一个新的物理页面，并将内容复制到新的物理页面中，让父子进程真正地各自拥有自己的物理内存页面，并将页表中相应地页表项标记为<strong>可写</strong>。</p>
</li>
</ul>
<p>写时复制父子进程修改某一个页面前后变化如下图所示：</p>
<p><a href="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221212114349322.png" data-fancybox="gallery" data-caption="image-20221212114349322" data-thumb="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221212114349322.png"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221212114349322.png" alt="image-20221212114349322"></a></p>
<p>在fork还没实现<code>copy on write</code>之前。Unix设计者很关心fork之后立刻执行exec所造成的地址空间浪费，所以引入了<code>vfork</code>系统调用。而现在<code>vfork</code>已经不常用了。</p>
<ul>
<li>vfork和fork的区别/联系：vfork函数和 fork函数一样都是在已有的进程中创建一个新的进程，但它们创建的子进程是有区别的。</li>
<li>父子进程的执行顺序<ul>
<li>fork： 父子进程的执行次序不确定。</li>
<li>vfork：保证子进程先运行，在它调用 <code>exec/exit</code>之后，父进程才执行</li>
</ul>
</li>
<li>是否拷贝父进程的地址空间<ul>
<li>fork： 子进程写时拷贝父进程的地址空间，子进程是父进程的一个复制</li>
<li>vfork：子进程共享父进程的地址空间</li>
</ul>
</li>
<li>调用vfork函数，是为了执行exec函数；如果子进程没有调用 exec/exit，程序会出错</li>
</ul>
<blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>{</span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line">	pid = vfork();	<span class="comment">// 创建进程</span></span><br><span class="line">	<span class="keyword">if</span>(pid &lt; <span class="number">0</span>){</span><br><span class="line">		perror(<span class="string">"vfork"</span>);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span>(<span class="number">0</span> == pid){  </span><br><span class="line">		sleep(<span class="number">3</span>); <span class="comment">// 延时 3 秒</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"i am son\n"</span>);</span><br><span class="line">		</span><br><span class="line">		_exit(<span class="number">0</span>); <span class="comment">// 退出子进程，必须</span></span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>){ <span class="comment">// 父进程</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"i am father\n"</span>);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>执行结果：已经让子进程延时 3 s，结果还是子进程运行结束后，父进程才执行</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>{</span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">	pid = vfork();</span><br><span class="line">	<span class="keyword">if</span>(pid &lt; <span class="number">0</span>){</span><br><span class="line">		perror(<span class="string">"vfork()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span>(<span class="number">0</span> == pid){</span><br><span class="line">		a = <span class="number">100</span>, b = <span class="number">200</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"son: a = %d, b = %d\n"</span>, a, b);</span><br><span class="line">		_exit(<span class="number">0</span>);  </span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>){ </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"father: a = %d, b = %d\n"</span>, a, b);	</span><br><span class="line">	}</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>执行结果：子进程先执行，修改完a，b的值后，由于父子进程共享内存空间，因此会影响父进程</p>
<figure class="highlight plaintext"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">plaintext</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">son: a = 100, b = 200</span><br><span class="line">father: a = 100, b = 200</span><br></pre></td></tr></tbody></table></figure>
<p>如果采用<code>fork</code>的话，会有写时复制，此时父子进程的变量无关：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">    fflush(<span class="literal">NULL</span>);</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">"fork()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>) {</span><br><span class="line">        a = <span class="number">100</span>;</span><br><span class="line">        b = <span class="number">200</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"son: a = %d, b = %d.\n"</span>, a, b);</span><br><span class="line">        _exit(<span class="number">0</span>);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"father: a = %d, b = %d.\n"</span>, a, b);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>执行结果：</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng proc]<span class="comment"># ./vfork </span></span><br><span class="line">father: a = 10, b = 20.</span><br><span class="line">son: a = 100, b = 200.</span><br></pre></td></tr></tbody></table></figure>
<h3 id="6-3-wait和waitpid"><a href="#6-3-wait和waitpid" class="headerlink" title="6.3 wait和waitpid"></a>6.3 wait和waitpid</h3><p><code>wait</code>系统调用：等待进程改变状态。</p>
<p>进程一旦调用了wait，就<strong>立即阻塞</strong>自己，由wait自动分析是否当前进程的某个子进程已经退出，如果让它找到了这样一个已经变成僵尸的子进程，wait就会收集这个子进程的信息，并把它彻底销毁后返回；如果没有找到这样一个子进程，wait就会一直阻塞在这里，直到有一个出现为止。</p>
<p><code>wait</code>函数原型如下：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">wait</span><span class="params">(<span class="keyword">int</span> *status)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>status</code>用来保存子进程退出时的一些状态。如果不在意子进程的退出状态，可以设定<code>status</code>为<code>NULL</code>。如果参数<code>status</code>的值不是<code>NULL</code>，<code>wait</code>就会把子进程退出时的状态取出，并存入其中。可以使用下列的宏函数来处理<code>status</code>：<ul>
<li><code>WIFEXITED(status)</code>：用来指出子进程是否为正常退出，如果是，则会返回一个非零值。</li>
<li><code>WEXITSTATUS(status)</code>：当<code>WIFEXITED</code>返回非零值时，可以用这个宏来提取子进程的返回值。</li>
</ul>
</li>
<li>如果执行成功，<code>wait</code>会返回子进程的<code>PID</code>；如果没有子进程，则<code>wait</code>返回<code>-1</code>。</li>
</ul>
<blockquote>
<p>代码示例1</p>
</blockquote>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    <span class="keyword">pid_t</span> pc, pr;</span><br><span class="line">    pc = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pc &lt; <span class="number">0</span>) {</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"error ocurred!\n"</span>);</span><br><span class="line">    }<span class="keyword">else</span> <span class="keyword">if</span> (pc == <span class="number">0</span>) { <span class="comment">/* 如果是子进程 */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"This is child process with pid of %d\n"</span>, getpid());</span><br><span class="line">        sleep (<span class="number">10</span>); <span class="comment">/* 睡眠10秒钟 */</span></span><br><span class="line">    }<span class="keyword">else</span> { <span class="comment">/* 如果是父进程 */</span></span><br><span class="line">        pr = wait(<span class="literal">NULL</span>); <span class="comment">/* 在这里阻塞，收尸 */</span></span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"I catched a child process with pid of %d\n"</span>, pr);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>打印结果：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">This is child process with pid of <span class="number">298</span></span><br><span class="line">等待<span class="number">10</span>秒</span><br><span class="line">I catched a child process with pid of <span class="number">298</span></span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>程序实例2</p>
</blockquote>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">pid_t</span> pc, pr;</span><br><span class="line">    pc = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pc &lt; <span class="number">0</span>) {</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">"error ocurred!\n"</span> );</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(pc == <span class="number">0</span>) { <span class="comment">/* 子进程 */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"This is child process with pid of %d\n"</span>, getpid());</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">3</span>); <span class="comment">/* 子进程返回3 */</span></span><br><span class="line">    <span class="keyword">if</span>(pc &gt; <span class="number">0</span>) { <span class="comment">/* 父进程 */</span></span><br><span class="line">        pr = wait(&amp;status);</span><br><span class="line">        <span class="keyword">if</span>(WIFEXITED(status)) { <span class="comment">/* 如果WIFEXITED返回非零值 */</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"the child process %d exit normally\n"</span>, pr);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"the return code is %d\n"</span>, WEXITSTATUS(status ));</span><br><span class="line">        } <span class="keyword">else</span> { <span class="comment">/* 如果WIFEXITED返回零 */</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"the child process %d exit abnormally\n"</span>, pr);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>打印结果：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">This is child process with pid of <span class="number">308</span></span><br><span class="line">the child process <span class="number">308</span> <span class="built_in">exit</span> normally</span><br><span class="line">the <span class="keyword">return</span> code is <span class="number">3</span></span><br></pre></td></tr></tbody></table></figure>
<hr>
<p><code>waitpid</code>函数原型如下：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">waitpid</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> *status, <span class="keyword">int</span> options)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面两者等价：</span></span><br><span class="line">wait(&amp;status);</span><br><span class="line">waitpid(<span class="number">-1</span>, &amp;status, <span class="number">0</span>);</span><br></pre></td></tr></tbody></table></figure>
<p>从本质上讲，<code>waitpid</code>和<code>wait</code>的作用是完全相同的，但<code>waitpid</code>多出了两个可以由用户控制的参数<code>pid</code>和<code>options</code>：</p>
<ul>
<li><code>pid</code>：当<code>pid</code>取不同的值时，在这里有不同的意义：</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>取值</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&gt; 0</code></td>
<td>只等待进程<code>ID</code>等于<code>pid</code>的子进程</td>
</tr>
<tr>
<td><code>=-1</code></td>
<td>等待任何一个子进程退出，此时<code>waitpid</code>和<code>wait</code>的作用一模一样</td>
</tr>
<tr>
<td><code>= 0</code></td>
<td>等待同一个进程组<code>process group id</code>中的任何子进程</td>
</tr>
<tr>
<td><code>&lt;-1</code></td>
<td>等待一个指定进程组中的任何子进程，这个进程组的<code>ID</code>等于<code>pid</code>的绝对值</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><code>options</code>：是一个位图，可以通过<strong>按位或</strong>来设置，如果不设置则置为0即可。最常用的选项是<code>WNOHANG</code>，作用是即使没有子进程退出，它也会立即返回，此时<code>waitpid</code>不同于<code>wait</code>，它变成了非阻塞的函数。</li>
<li><code>waitpid</code>的返回值有如下几种情况：<ul>
<li>当正常返回时，<code>waitpid</code>返回子进程的<code>PID</code>。</li>
<li>如果设置了<code>WNOHANG</code>，而<code>waitpid</code>没有发现已经退出的子进程，则返回<code>0</code>。</li>
<li>如果<code>waitpid</code>出错，则返回<code>-1</code>。例如参数<code>pid</code>指示的子进程不存在，或此进程存在，但不是调用进程的子进程。</li>
</ul>
</li>
</ul>
<blockquote>
<p>代码示例1</p>
</blockquote>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEFT 30000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RIGHT 30000200</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> i, j, mark;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">pid_t</span> pid_child;</span><br><span class="line">    <span class="keyword">for</span>(i = LEFT; i &lt;= RIGHT; i++) {</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid &lt; <span class="number">0</span>) {</span><br><span class="line">            perror(<span class="string">"fork()"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>) {</span><br><span class="line">            mark = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">2</span>; j &lt; i/<span class="number">2</span>; j++) {</span><br><span class="line">                <span class="keyword">if</span>(i % j == <span class="number">0</span>) {</span><br><span class="line">                    mark = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(mark)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"[%d]:%d is a primer.\n"</span>, getpid(), i);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 循环201次，给201个子进程收尸</span></span><br><span class="line">    <span class="keyword">for</span>(i = LEFT; i &lt;= RIGHT; i++) {</span><br><span class="line">        pid_child = wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Child process with pid: %d.\n"</span>, pid_child);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>执行结果：省略了没有打印质数的输出</p>
<figure class="highlight plaintext"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">plaintext</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">[32444]:30000023 is a primer.</span><br><span class="line">Child process with pid: 32444.</span><br><span class="line">[32462]:30000041 is a primer.</span><br><span class="line">Child process with pid: 32462.</span><br><span class="line">[32458]:30000037 is a primer.</span><br><span class="line">Child process with pid: 32458.</span><br><span class="line">[32422]:30000001 is a primer.</span><br><span class="line">Child process with pid: 32422.</span><br><span class="line">[32470]:30000049 is a primer.</span><br><span class="line">Child process with pid: 32470.</span><br><span class="line">[32480]:30000059 is a primer.</span><br><span class="line">Child process with pid: 32480.</span><br><span class="line">[32530]:30000109 is a primer.</span><br><span class="line">Child process with pid: 32530.</span><br><span class="line">[32504]:30000083 is a primer.</span><br><span class="line">Child process with pid: 32504.</span><br><span class="line">[32614]:30000193 is a primer.</span><br><span class="line">Child process with pid: 32614.</span><br><span class="line">[32590]:30000169 is a primer.</span><br><span class="line">Child process with pid: 32590.</span><br><span class="line">[32492]:30000071 is a primer.</span><br><span class="line">Child process with pid: 32492.</span><br><span class="line">[32620]:30000199 is a primer.</span><br><span class="line">Child process with pid: 32620.</span><br><span class="line">[32500]:30000079 is a primer.</span><br><span class="line">Child process with pid: 32500.</span><br><span class="line">[32588]:30000167 is a primer.</span><br><span class="line">Child process with pid: 32588.</span><br><span class="line">[32554]:30000133 is a primer.</span><br><span class="line">Child process with pid: 32554.</span><br><span class="line">[32558]:30000137 is a primer.</span><br><span class="line">Child process with pid: 32558.</span><br><span class="line">[32584]:30000163 is a primer.</span><br><span class="line">Child process with pid: 32584.</span><br><span class="line">[32570]:30000149 is a primer.</span><br><span class="line">Child process with pid: 32570.</span><br></pre></td></tr></tbody></table></figure>
<h3 id="6-4-exec函数族"><a href="#6-4-exec函数族" class="headerlink" title="6.4 exec函数族"></a>6.4 exec函数族</h3><h4 id="6-4-1-简介"><a href="#6-4-1-简介" class="headerlink" title="6.4.1 简介"></a>6.4.1 简介</h4><p>fork函数是用于创建一个子进程，该子进程几乎是父进程的副本，而有时我们希望子进程去执行另外的程序，exec函数族就提供了一个在进程中启动另一个程序执行的方法。它可以根据指定的文件名或目录名找到可执行文件，<strong>并用它来取代原调用进程的数据段、代码段和堆栈段</strong>，在执行完之后，原调用进程的内容<strong>除了进程号外，其他全部被新程序的内容替换了</strong>。这里的可执行文件既可以是二进制文件，也可以是Linux下任何可执行脚本文件。</p>
<p>当进程调用一种exec函数时，该进程执行的程序<strong>完全替换为新程序</strong>，而新程序则从其main函数开始执行。因为调用exec并不创建新进程，所以前后的进程ID并未改变。exec只是用磁盘上的一个新程序替换了当前进程的正文段、数据段、堆段和栈段。</p>
<blockquote>
<p>为什么需要<code>exec</code>函数</p>
</blockquote>
<ul>
<li>fork子进程是为了执行新程序（fork创建了子进程后，子进程和父进程同时被OS调度执行，因此子进程可以单独的执行一个程序，这个程序宏观上将会和父进程程序同时进行）；</li>
<li>可以直接在子进程的<code>if</code>中写入新程序的代码（参见<code>6.2.1节</code>的做法）。这样可以，但是不够灵活，因为我们只能把子进程程序的源代码贴过来执行（必须知道源代码，而且源代码太长了也不好控制），譬如说我们希望子进程来执行<code>ls -la</code>命令就不行了（没有源代码，只有编译好的可执行程序<code>/usr/bin/ls</code>）；</li>
<li>使用exec族运行新的可执行程序（exec族函数可以直接把一个编译好的可执行程序直接加载运行）；</li>
<li>我们有了exec族函数后，典型的父子进程程序是这样的：子进程需要运行的程序被单独编写、单独编译连接成一个可执行程序（叫<code>hello</code>），（项目是一个多进程项目）主程序为父进程，fork创建了子进程后在子进程中<code>exec</code>来执行hello，达到父子进程分别做不同程序同时（宏观上）运行的效果；</li>
</ul>
<h4 id="6-4-2-使用"><a href="#6-4-2-使用" class="headerlink" title="6.4.2 使用"></a>6.4.2 使用</h4><p>有多种不同的exec函数可供使用，它们常常被统称为exec函数。</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> **environ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直达</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ...)</span></span>;</span><br><span class="line"><span class="comment">// 从$PATH里找</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execlp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ...)</span></span>;</span><br><span class="line"><span class="comment">// 直达</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execle</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ..., <span class="keyword">char</span> * <span class="keyword">const</span> envp[])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直达</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>;</span><br><span class="line"><span class="comment">// 从$PATH里找</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execvp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>;</span><br><span class="line"><span class="comment">// 从$PATH里找</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execvpe</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">char</span> *<span class="keyword">const</span> argv[], <span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>以上函数成功执行时不返回，失败时返回<code>-1</code>并设值<code>errno</code></li>
<li><p>后缀含义</p>
<ul>
<li><code>l</code>：以<code>list</code>形式传入参数</li>
<li><code>v</code>：以<code>vector</code>形式传入参数</li>
<li><code>p</code>：在<code>$PATH</code>中查找可执行程序</li>
<li><code>e</code>：在<code>envp[]</code>中查找可执行程序</li>
</ul>
</li>
<li><p><code>execl</code>和<code>execv</code>：这两个函数是最基本的exec，都可以用来执行一个程序，区别是传参的格式不同：</p>
<ul>
<li>execl是把参数列表（本质上是多个字符串，必须以<code>NULL</code>结尾）依次排列而成</li>
<li>execv是把参数列表事先放入一个字符串数组中（必须以<code>NULL</code>结尾），再把这个字符串数组传给execv函数，类似于<code>char **argv</code></li>
<li><code>path</code>：完整的文件目录路径</li>
</ul>
</li>
<li><p><code>execlp</code>和<code>execvp</code>：这两个函数在上面2个基础上加了<code>p</code></p>
<ul>
<li><code>file</code>：文件名，系统就会自动从环境变量<code>$PATH</code>所指出的路径中进行查找该文件。如果包含<code>/</code>，则视为路径名<code>path</code>。</li>
</ul>
</li>
<li><p><code>execle</code>和<code>execvpe</code>：这两个函数较基本exec来说加了<code>e</code></p>
<ul>
<li><code>envp</code>：自己指定的环境变量。在<code>envp[]</code>中指定当前进程所使用的环境变量替换掉该进程继承的环境变量<code>$PATH</code>。</li>
</ul>
</li>
</ul>
<p><a href="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221215120515986.png" data-fancybox="gallery" data-caption="image-20221215120515986" data-thumb="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221215120515986.png"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221215120515986.png" alt="image-20221215120515986"></a></p>
<blockquote>
<p>代码示例——环境变量</p>
</blockquote>
<ul>
<li><code>myexec.c</code></li>
</ul>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">"fork()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) { <span class="comment">// 子进程</span></span><br><span class="line">        <span class="comment">// 参数</span></span><br><span class="line">        <span class="keyword">char</span> * <span class="keyword">const</span> param[] = {<span class="string">"myHello"</span>, <span class="string">"-a"</span>, <span class="string">"-l"</span>, <span class="literal">NULL</span>};</span><br><span class="line">        <span class="comment">// 自己设置的环境变量</span></span><br><span class="line">        <span class="keyword">char</span> * <span class="keyword">const</span> envp[] = {<span class="string">"AA=aaa"</span>, <span class="string">"BB=bbb"</span>, <span class="literal">NULL</span>};</span><br><span class="line">        <span class="comment">// 执行同目录下的hello</span></span><br><span class="line">        execvpe(<span class="string">"./hello"</span>, param, envp);</span><br><span class="line">        perror(<span class="string">"execvpe()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    } <span class="keyword">else</span> { <span class="comment">// 父进程</span></span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>hello.c</code></li>
</ul>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, <span class="keyword">char</span> **env)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"argc = %d\n"</span>, argc);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; argv[i] != <span class="literal">NULL</span>; i++) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"argv[%d]: %s\n"</span>, i, argv[i]);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; env[i] != <span class="literal">NULL</span>; i++) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"env[%d]: %s\n"</span>, i, env[i]);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>编译链接为<code>hello</code></p>
<p>执行结果：</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng proc]<span class="comment"># ./myexec </span></span><br><span class="line">argc = 3</span><br><span class="line">argv[0]: myHello</span><br><span class="line">argv[1]: -a</span><br><span class="line">argv[2]: -l</span><br><span class="line">env[0]: AA=aaa</span><br><span class="line">env[1]: BB=bbb</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>代码示例——程序名称</p>
</blockquote>
<p>补充：<code>argv</code>第一个参数为程序名称，后面的参数为命令行参数。程序名称可以任意设置，一般来说，如果一个源码文件的名称为<code>XXX.c</code>，则编译生成的可执行程序为<code>XXX</code>，此时运行，程序名称（<code>argv[0]</code>）就是<code>XXX</code></p>
<p>使用gcc默认编译链接得到的可执行文件名称为<code>a.out</code>，此时程序名称（<code>argv[0]</code>）就是<code>a.out</code>。</p>
<hr>
<p>使用<code>exec</code>族函数实现<code>date +%s</code>命令打印时间戳的功能。</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng proc]<span class="comment"># date +%s</span></span><br><span class="line">1670902531</span><br></pre></td></tr></tbody></table></figure>
<p>这里的参数依次是<code>程序名</code>，<code>+%s</code>，<code>NULL</code>，注意第一个参数代表的是程序的名称，可以任意设置，类似于<code>argv[0]</code>，之后的参数才是重要的<strong>命令行参数</strong>。</p>
<p>代码实现：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Begin!"</span>);</span><br><span class="line">	<span class="comment">// 注意这里的程序名称给了一个myDate</span></span><br><span class="line">    execl(<span class="string">"/bin/date"</span>, <span class="string">"myDate"</span>, <span class="string">"+%s"</span>, <span class="literal">NULL</span>);</span><br><span class="line">    perror(<span class="string">"execl()"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"End!"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>或者使用<code>execv</code>：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Begin!"</span>);</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">char</span> * <span class="keyword">const</span> param[] = {<span class="string">"myDate"</span>, <span class="string">"+%s"</span>, <span class="literal">NULL</span>};</span><br><span class="line">    execv(<span class="string">"/bin/date"</span>, param);</span><br><span class="line">    perror(<span class="string">"execl()"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"End!"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>执行结果：</p>
<figure class="highlight plaintext"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">plaintext</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng proc]# ./ex </span><br><span class="line">Begin!</span><br><span class="line">1670902607</span><br></pre></td></tr></tbody></table></figure>
<p>为什么不打印<code>End!</code>：执行<code>exec</code>后，原进程映像被替换成新的进程映像（即<code>/bin/date</code>程序），从main函数开始执行<code>/bin/date</code>的代码了。</p>
<p><strong>我不再是我，我已成新的我</strong>。</p>
<hr>
<p>让子进程睡眠1000s：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[%d]Begin!\n"</span>, getpid());</span><br><span class="line">    fflush(<span class="literal">NULL</span>);</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">"fork()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// 注意这里的程序名称给了一个httpd</span></span><br><span class="line">        execl(<span class="string">"/bin/sleep"</span>, <span class="string">"httpd"</span>, <span class="string">"1000"</span>, <span class="literal">NULL</span>);</span><br><span class="line">        perror(<span class="string">"execl()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    wait(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[%d]End!\n"</span>, getpid());</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>执行后查看：</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps axf</span><br></pre></td></tr></tbody></table></figure>
<p><a href="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221215122921045.png" data-fancybox="gallery" data-caption="image-20221215122921045" data-thumb="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221215122921045.png"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221215122921045.png" alt="image-20221215122921045"></a></p>
<p>这里子进程运行时执行的是<code>sleep</code>程序，但是程序名称却被设置成了<code>httpd</code>，这实际上是一种低级的木马程序隐藏的办法。</p>
<blockquote>
<p>代码示例——刷新缓冲区的重要性</p>
</blockquote>
<p>在讲<code>fork</code>的时候提到过，在<code>fork</code>之前，最好将强制刷新所有已经打开的流，这里的<code>exec</code>也不例外，例如使用上面的程序，将结果重定向到<code>/tmp/out</code>中：</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng proc]<span class="comment"># ./ex &gt; /tmp/out</span></span><br><span class="line">[root@HongyiZeng proc]<span class="comment"># cat /tmp/out</span></span><br><span class="line">1670902720</span><br></pre></td></tr></tbody></table></figure>
<p>发现<code>Begin!</code>不见了，原因就在于重定向是全缓冲，当执行完<code>puts("Begin!")</code>后，该进程的缓冲区内容为<code>Begin!\n</code>，并不刷新到文件中，此时执行<code>exec</code>后，进程映像被替换成新的进程映像（即<code>/bin/date</code>程序），除了原进程的进程号外，其他全部（包括缓冲区）被新程序的内容替换了，之后新程序的缓冲区内容为时间戳，程序结束后，强制刷新到文件。</p>
<p>因此需要在执行<code>exec</code>之前强制刷新所有打开的流：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Begin!"</span>);</span><br><span class="line">	</span><br><span class="line">    fflush(<span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    execl(<span class="string">"/bin/date"</span>, <span class="string">"date"</span>, <span class="string">"+%s"</span>, <span class="literal">NULL</span>);</span><br><span class="line">    perror(<span class="string">"execl()"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"End!"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>再次执行：</p>
<figure class="highlight plaintext"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">plaintext</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng proc]# ./ex &gt; /tmp/out</span><br><span class="line">[root@HongyiZeng proc]# cat /tmp/out</span><br><span class="line">Begin!</span><br><span class="line">1670903209</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>代码示例——fork，exec和wait结合使用</p>
</blockquote>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[%d]Begin!\n"</span>, getpid());</span><br><span class="line">    fflush(<span class="literal">NULL</span>);</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">"fork()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>) { <span class="comment">// 子进程</span></span><br><span class="line">        execl(<span class="string">"/bin/date"</span>, <span class="string">"date"</span>, <span class="string">"+%s"</span>, <span class="literal">NULL</span>);</span><br><span class="line">        perror(<span class="string">"execl()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 等待子进程结束，收尸</span></span><br><span class="line">    wait(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[%d]End!\n"</span>, getpid());</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>执行结果：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">17301</span>]Begin! <span class="comment">// 父进程打印</span></span><br><span class="line"><span class="number">1670903917</span> <span class="comment">// 子进程打印，子进程和父进程完全是不同的程序了</span></span><br><span class="line">[<span class="number">17301</span>]End! <span class="comment">// 父进程打印</span></span><br></pre></td></tr></tbody></table></figure>
<p>至此，UNIX系统进程控制原语更加完善。用fork可以创建新进程，用exec可以初始执行新的程序。exit函数和wait函数处理终止和等待终止。这些是我们需要的基本的进程控制原语。</p>
<h3 id="6-5-shell外部命令实现"><a href="#6-5-shell外部命令实现" class="headerlink" title="6.5 shell外部命令实现"></a>6.5 shell外部命令实现</h3><blockquote>
<p>内部命令和外部命令</p>
</blockquote>
<ul>
<li>内部命令指的是集成在Shell里面的命令，属于Shell的一部分。这些命令由shell程序识别并在shell程序内部完成运行，通常在linux系统加载运行时shell就被<strong>加载并驻留在系统内存中</strong>，比如cd命令等，这些命令在磁盘上看不见。</li>
<li>外部命令是linux系统中的实用程序部分，因为实用程序的功能通常都比较强大，所以其包含的程序量也会很大，在系统加载时并不随系统一起被加载
到内存中，而是在需要时才将其调用内存。通常外部命令的实体并不包含在shell中，但是其命令执行过程是由shell程序控制的。shell程序管理外
部命令执行的路径查找（PATH环境变量中）、加载存放，并控制命令的执行。这些命令的二进制可执行文件在磁盘上可见。</li>
</ul>
<p>外部命令执行流程：</p>
<ol>
<li>shell建立（<code>fork</code>）一个新的子进程，此进程即为Shell的一个副本</li>
<li>在子进程里，在PATH变量内所列出的目录中，寻找特定的命令。<br>  <code>/bin:/usr/bin:/usr/X11R6/bin:/usr/local/bin</code>为PATH变量典型的默认值。 当命令名称包含有斜杠（<code>/</code>）符号时，将略过路径查找步骤。</li>
<li>在子进程里，以所找到的新程序取代（<code>exec</code>）子程序并执行。</li>
<li>父进程shell等待（<code>wait</code>）程序完成后（子进程<code>exit</code>），父进程Shell会接着从终端读取下一条命令或执行脚本里的下一条命令</li>
</ol>
<p>相关命令：</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span> <span class="comment"># 判断是外部命令还是内部命令</span></span><br><span class="line"><span class="built_in">which</span> <span class="comment"># 查看命令所在的文件路径</span></span><br></pre></td></tr></tbody></table></figure>
<p>示例：</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng ~]<span class="comment"># type cd</span></span><br><span class="line"><span class="built_in">cd</span> is a shell <span class="built_in">builtin</span></span><br><span class="line">[root@HongyiZeng ~]<span class="comment"># type mkdir</span></span><br><span class="line">mkdir is /usr/bin/mkdir</span><br><span class="line">[root@HongyiZeng ~]<span class="comment"># which ls</span></span><br><span class="line"><span class="built_in">alias</span> ls=<span class="string">'ls --color=auto'</span></span><br><span class="line">        /usr/bin/ls</span><br></pre></td></tr></tbody></table></figure>
<hr>
<p>之前在终端上执行<code>primer1.c</code>时，出现下列情况：</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng proc]<span class="comment"># ./primer1</span></span><br><span class="line">[root@HongyiZeng proc]<span class="comment"># 30000037 is a primer.</span></span><br><span class="line">30000001 is a primer.</span><br><span class="line">30000041 is a primer.</span><br><span class="line">30000023 is a primer.</span><br><span class="line">30000079 is a primer.</span><br><span class="line">30000133 is a primer.</span><br><span class="line">30000137 is a primer.</span><br><span class="line">30000049 is a primer.</span><br><span class="line">30000109 is a primer.</span><br><span class="line">30000083 is a primer.</span><br><span class="line">30000071 is a primer.</span><br><span class="line">30000059 is a primer.</span><br><span class="line">30000193 is a primer.</span><br><span class="line">30000169 is a primer.</span><br><span class="line">30000167 is a primer.</span><br><span class="line">30000199 is a primer.</span><br><span class="line">30000163 is a primer.</span><br><span class="line">30000149 is a primer.</span><br></pre></td></tr></tbody></table></figure>
<p>发现终端先于子程序打印。</p>
<p>原因：在终端上执行<code>primer1</code>时，父进程（终端，即shell）fork了一个子进程，然后exec了<code>primer1</code>程序，并且<code>wait</code>到<code>primer1</code>退出，所以当<code>primer1</code>退出时，就立刻出现了终端，此时<code>primer1</code>fork的子进程还在运行打印结果，所以出现了终端先于子进程的结果出现。</p>
<p>重要！！！（外部命令执行流程）：一般的，当shell执行某个程序时，首先<code>fork</code>一个子进程，然后该子进程<code>exec</code>那个执行程序，shell此时<code>wait</code>该程序退出<code>exit</code>。</p>
<blockquote>
<p>shell伪代码示例</p>
</blockquote>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    <span class="comment">// 死循环，shell不断接收用户命令</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">        <span class="comment">// 终端提示符</span></span><br><span class="line">        prompt();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取命令</span></span><br><span class="line">        getline();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 解析命令</span></span><br><span class="line">        parse();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(内部命令) {</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        } <span class="keyword">else</span> { <span class="comment">// 外部命令</span></span><br><span class="line">            fork();</span><br><span class="line">            <span class="keyword">if</span>(pid &lt; <span class="number">0</span>) {</span><br><span class="line">                <span class="comment">// 异常处理...</span></span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(pid == <span class="number">0</span>) { <span class="comment">// 子进程</span></span><br><span class="line">                exec(); <span class="comment">// 将子进程替换为待执行程序</span></span><br><span class="line">                <span class="comment">// 异常处理...</span></span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) { <span class="comment">// shell父进程</span></span><br><span class="line">                wait(<span class="literal">NULL</span>); <span class="comment">// 等待子进程结束</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>代码实现</p>
</blockquote>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glob.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分隔符：空 制表符 换行符</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DELIMS <span class="meta-string">" \t\n"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmd_st</span> {</span></span><br><span class="line">    <span class="keyword">glob_t</span> globres;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prompt</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"mysh-0.1$ "</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">(<span class="keyword">char</span> *line, struct cmd_st *res)</span> </span>{</span><br><span class="line">    <span class="keyword">char</span> *tok;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">        tok = strsep(&amp;line, DELIMS);</span><br><span class="line">        <span class="comment">// 分割完毕</span></span><br><span class="line">        <span class="keyword">if</span>(tok == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(tok[<span class="number">0</span>] == <span class="string">'\0'</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">       	<span class="comment">// 选项解释</span></span><br><span class="line">        <span class="comment">// NOCHECK：不对pattern进行解析，直接返回pattern（这里是tok），相当于存储了命令行参数tok在glob_t中</span></span><br><span class="line">        <span class="comment">// APPEND：以追加形式将tok存放在glob_t中，第一次时不追加，因为globres尚未初始化，需要系统来自己分配内存，因此乘上i（乘法优先于按位或）</span></span><br><span class="line">        glob(tok, GLOB_NOCHECK|GLOB_APPEND*i, <span class="literal">NULL</span>, &amp;res-&gt;globres);</span><br><span class="line">        <span class="comment">// 置为1，使得追加永远成立</span></span><br><span class="line">        i = <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    <span class="comment">// getline的参数要初始化</span></span><br><span class="line">    <span class="keyword">char</span> *linebuf = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">size_t</span> linebuf_size = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cmd_st</span> <span class="title">cmd</span>;</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">        prompt();</span><br><span class="line">        <span class="comment">// getline函数参见2.10节</span></span><br><span class="line">        <span class="keyword">if</span>(getline(&amp;linebuf, &amp;linebuf_size, <span class="built_in">stdin</span>) &lt; <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 解析命令</span></span><br><span class="line">        parse(linebuf, &amp;cmd);</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span>) { <span class="comment">// 内部命令，暂不做实现</span></span><br><span class="line"></span><br><span class="line">        } <span class="keyword">else</span> { <span class="comment">// 外部命令</span></span><br><span class="line">            pid = fork();</span><br><span class="line">            <span class="keyword">if</span>(pid &lt; <span class="number">0</span>) {</span><br><span class="line">                perror(<span class="string">"fork()"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(pid == <span class="number">0</span>) {</span><br><span class="line">                execvp(cmd.globres.gl_pathv[<span class="number">0</span>], cmd.globres.gl_pathv);</span><br><span class="line">                perror(<span class="string">"execvp()"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                wait(<span class="literal">NULL</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>程序分析：</p>
<p><code>strsep</code>函数原型：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">strsep</span><span class="params">(<span class="keyword">char</span> **stringp, <span class="keyword">const</span> <span class="keyword">char</span> *delim)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p><code>strsep</code>实现字符串的分割，把<code>stringp</code>里面出现的<code>delim</code>替换成<code>'\0'</code>，后将 <code>stringp</code> 更新指向到<code>'\0'</code>符号的下一个字符地址，函数的返回值指向原来的 <code>stringp</code> 位置。直到分割完毕返回<code>NULL</code>。</p>
<hr>
<p>代码执行流程分析：</p>
<p>例如：</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng proc]<span class="comment"># ./mysh </span></span><br><span class="line">mysh-0.1$ ls -l</span><br><span class="line">total 144</span><br><span class="line">-rwxr-xr-x 1 root root 8600 Dec 13 11:46 ex</span><br><span class="line">-rw-r--r-- 1 root root  213 Dec 13 11:46 ex.c</span><br><span class="line">-rwxr-xr-x 1 root root 8552 Dec 13 12:52 exv</span><br><span class="line">-rw-r--r-- 1 root root  232 Dec 13 12:52 exv.c</span><br><span class="line">-rwxr-xr-x 1 root root 8752 Dec 13 11:58 few</span><br><span class="line">-rw-r--r-- 1 root root  361 Dec 13 11:58 few.c</span><br><span class="line">-rwxr-xr-x 1 root root 8656 Dec 12 10:19 fork1</span><br><span class="line">-rw-r--r-- 1 root root  402 Dec 12 10:19 fork1.c</span><br><span class="line">-rwxr-xr-x 1 root root 8912 Dec 14 12:06 mysh</span><br><span class="line">-rw-r--r-- 1 root root  953 Dec 14 12:06 mysh.c</span><br><span class="line">-rwxr-xr-x 1 root root 8448 Dec 12 10:28 primer0</span><br><span class="line">-rw-r--r-- 1 root root  313 Dec 12 10:28 primer0.c</span><br><span class="line">-rwxr-xr-x 1 root root 8552 Dec 14 11:05 primer1</span><br><span class="line">-rw-r--r-- 1 root root  437 Dec 14 11:04 primer1.c</span><br><span class="line">-rwxr-xr-x 1 root root 8656 Dec 13 10:02 primer2</span><br><span class="line">-rw-r--r-- 1 root root  652 Dec 13 10:02 primer2.c</span><br><span class="line">-rwxr-xr-x 1 root root 8672 Dec 12 11:56 vfork</span><br><span class="line">-rw-r--r-- 1 root root  372 Dec 12 11:56 vfork.c</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p><code>getline</code>得到字符串<code>ls -l</code></p>
</li>
<li><p><code>parse</code>解析该字符串，将分割结果存在<code>globres</code>中，其中：</p>
  <figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">globres.gl_pathv[<span class="number">0</span>] = <span class="string">"ls"</span>;</span><br><span class="line">globres.gl_pathv[<span class="number">1</span>] = <span class="string">"-l"</span>;</span><br><span class="line">globres.gl_pathv[<span class="number">2</span>] = <span class="literal">NULL</span>;</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>子进程<code>execvp(cmd.globres.gl_pathv[0], cmd.globres.gl_pathv);</code></p>
<ul>
<li>第一个参数为要执行的可执行程序的名字，为<code>ls</code>，从环境变量<code>PATH</code>中找到<code>/usr/bin/</code>路径下的<code>ls</code>程序</li>
<li>第二个参数为指针数组，为<code>ls</code>和<code>-l</code>，第一个为程序名，任意，第二个和后面的为命令的参数，重要，这里的参数为<code>-l</code></li>
</ul>
</li>
</ul>
<h3 id="6-6-用户权限和组权限"><a href="#6-6-用户权限和组权限" class="headerlink" title="6.6 用户权限和组权限"></a>6.6 用户权限和组权限</h3><p>在
UNIX系统中，特权（如能改变当前日期的表示法）以及访问控制（如能否读、写一个特定文件），是基于用户ID和组ID的。当程序需要增加特权，或需要访
问当前并不允许访问的资源时，我们需要更换自己的用户ID或组ID，使得新ID具有合适的特权或访问权限。与此类似，当程序需要降低其特权或阻止对某些资
源的访问时，也需要更换用户ID或组ID，新ID不具有相应特权或访问这些资源的能力。</p>
<h4 id="6-6-1-UID和GID"><a href="#6-6-1-UID和GID" class="headerlink" title="6.6.1 UID和GID"></a>6.6.1 UID和GID</h4><p>Linux采用一个32位的整数记录和区分不同的用户。这个区分不同用户的数字被称为User ID，简称<code>UID</code>。Linux系统中用户分为3类，即普通用户、根用户root、系统用户。</p>
<ul>
<li>普通用户是指所有使用Linux系统的真实用户，通常<code>UID&gt;500</code>；</li>
<li>根用户即root用户，UID为0。</li>
<li>系统用户是指系统运行必须有的用户，但并不是真实使用者。UID为<code>1~499</code>。对于系统用户，可能还不能理解是什么。比如，在Redhat或CentOS下运行网站服务时，需要使用系统用户Apache来运行httpd，而运行MySQL数据库服务时，需要使用系统用户mysql来运行mysqld进程。这就是系统用户。</li>
</ul>
<p>可以使用<code>id [用户名]</code>命令查看uid，gid和组名：</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng proc]<span class="comment"># id</span></span><br><span class="line">uid=0(root) gid=0(root) groups=0(root)</span><br><span class="line">[root@HongyiZeng proc]<span class="comment"># id lighthouse</span></span><br><span class="line">uid=1000(lighthouse) gid=1000(lighthouse) groups=1000(lighthouse),991(docker)</span><br></pre></td></tr></tbody></table></figure>
<p>要确认自己所属的用户组，可以使用<code>groups</code>命令：</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng proc]<span class="comment"># groups</span></span><br><span class="line">root</span><br></pre></td></tr></tbody></table></figure>
<p>系统用来记录用户名、密码的最重要两个文件是<code>/etc/passwd</code>和<code>/etc/shadow</code>，详见<code>4.1.2节</code>。</p>
<h4 id="6-6-2-SUID和SGID"><a href="#6-6-2-SUID和SGID" class="headerlink" title="6.6.2 SUID和SGID"></a>6.6.2 SUID和SGID</h4><p>内核为每个进程维护的三个UID值（和三个GID值，是对应关系，略），这三个UID分别是：</p>
<ul>
<li><code>RUID</code>：(Real UID，实际用户ID)，我们当前以哪个用户登录，我们运行程序产生进程的RUID就是这个用户的UID。</li>
<li><code>EUID</code>：(Effective UID，有效用户ID)，指当前进程实际以哪个UID来运行。一般情况下EUID等于RUID；但如果进程对应的可执行文件具有SUID权限（也就是rws的<code>s</code>），那么<strong>进程的EUID是该文件属主的UID</strong>，鉴权看的就是这个ID。</li>
<li><code>SUID</code>：(Saved Set-user-ID，保存的设置用户ID)，EUID的一个副本，与SUID权限有关。</li>
</ul>
<blockquote>
<p>特殊权限</p>
</blockquote>
<p>文件和目录权限除了普通权限<code>rwx</code>外，还有三个特殊权限：</p>
<ul>
<li><code>SUID</code>：在属主的<code>x</code>位以<code>s</code>标识，全称<code>SetUID</code></li>
<li><code>SGID</code>：在属组的<code>x</code>位以<code>s</code>标识，全称<code>SetGID</code></li>
<li><code>STIKCY</code>：黏着位，详见<code>4.2.4.③节</code></li>
</ul>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng proc]<span class="comment"># ll /usr/bin/passwd </span></span><br><span class="line">-rwsr-xr-x 1 root root 27856 Apr  1  2020 /usr/bin/passwd</span><br></pre></td></tr></tbody></table></figure>
<p>上面第4位的<code>s</code>就是特殊权限<code>SUID</code>，属主为root，其uid为0。当普通用户执行该命令时，会以root的身份去执行该命令。</p>
<p>下面将由五个问题来说明什么是<code>SUID</code>：</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.普通用户可不可以修改密码？</span></span><br><span class="line">可以，修改自己的密码</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2./etc/shadow文件的作用？</span></span><br><span class="line">存储用户密码的文件</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3./etc/shadow文件的权限？</span></span><br><span class="line">[root@localhost ~]<span class="comment"># ll /etc/shadow</span></span><br><span class="line">----------1 root root 16404 Apr  8 11:41 /etc/shadow</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.普通用户，是否可以修改/etc/shadow文件？</span></span><br><span class="line">不可以，/etc/shadow文件，对于普通用户没有任何权限，所以不能读取，也不能写入内容。</span><br><span class="line"></span><br><span class="line">普通用户的信息保存在 /etc/passwd文件中，与用户的密码在 /etc/shadow 文件中，也就是说，普通用户在更改自己密码时，修改了 /etc/shadow 文件中的加密密码，但是文件权限显示，普通用户对这两个文件都没有写权限。</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.那么普通用户，为什么可以修改密码？</span></span><br><span class="line">1）因为使用了passwd这个命令</span><br><span class="line">2）passwd命令在属主权限位上，原本是x权限，变成了s权限</span><br><span class="line">3）s权限在属主权限位，又叫做SetUID权限，SUID</span><br><span class="line">4）作用：普通用户在使用有SUID权限的文件或命令时，会以该文件的属主身份去执行该命令，换句话说，普通用户在执行passwd命令时，切换成了passwd属主即root的身份去执行passwd命令。</span><br></pre></td></tr></tbody></table></figure>
<p>从进程控制的角度来说，当非root用户执行passwd这个可执行文件的时候，<strong>产生的进程的EUID</strong>，就是<strong>root用户的UID</strong>。换言之，这种情况下，产生的进程，实际以root用户的ID来运行二进制文件。</p>
<blockquote>
<p>相关命令</p>
</blockquote>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod u+s 文件名/目录名 <span class="comment"># 对文件给予用户s权限，则此用户暂时获得这个文件的属主权限</span></span><br><span class="line">chmod g+s 文件名/目录名 <span class="comment"># 对文件给予用户组s权限，则此用户暂时获得这个文件的属组权限</span></span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>从进程控制的角度看命令的执行</p>
</blockquote>
<ul>
<li>UNIX系统产生的第一个进程是<code>init</code>进程，其三个uid为root的uid，即<code>res</code>为<code>0 0 0</code>，以<code>init(0 0 0)</code>表示；</li>
<li><code>init</code>进程fork和exec产生<code>getty(0 0 0)</code>进程，此进程等待用户输入用户名；</li>
<li>用户回车输入了用户名后，<code>getty</code>进程存储用户名，exec产生<code>login(0 0 0)</code>进程，等待用户输入密码并验证口令（查找用户名和密码<code>/etc/passwd</code>）；<ul>
<li>如果验证成功，<code>login</code>进程则fork并exec产生<code>shell(r e s)</code>进程，即终端，此时的<code>res</code>就是登录用户的UID，即固定了用户产生的进程的身份；</li>
<li>如果验证失败，则返回继续验证；</li>
</ul>
</li>
<li>当用户执行某个命令时，<code>shell</code>进程fork并exec该命令对应的程序，例如<code>ls(r e s)</code>，并wait该程序，<code>ls</code>进程退出时，又返回到<code>shell(r e s)</code>终端（因为shell是一个死循环，参见<code>6.5节</code>）；</li>
<li>可以看出，整个UNIX的世界就是由fork，exec，wait和exit的进程控制原语搭建起来的</li>
</ul>
<p>整个过程的图示如下：</p>
<p><a href="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221216121452262.png" data-fancybox="gallery" data-caption="image-20221216121452262" data-thumb="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221216121452262.png"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221216121452262.png" alt="image-20221216121452262"></a></p>
<p>又如执行<code>passwd</code>命令时图如下，变化的只有<code>EUID</code>和<code>SUID</code>：</p>
<p><a href="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221216121641906.png" data-fancybox="gallery" data-caption="image-20221216121641906" data-thumb="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221216121641906.png"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221216121641906.png" alt="image-20221216121641906"></a></p>
<h4 id="6-6-3-相关系统调用"><a href="#6-6-3-相关系统调用" class="headerlink" title="6.6.3 相关系统调用"></a>6.6.3 相关系统调用</h4><p>下面的系统调用是特殊权限实现所需的函数。</p>
<ul>
<li>获取：</li>
</ul>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回当前进程的ruid</span></span><br><span class="line"><span class="function"><span class="keyword">uid_t</span> <span class="title">getuid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回当前进程的euid</span></span><br><span class="line"><span class="function"><span class="keyword">uid_t</span> <span class="title">geteuid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">gid_t</span> <span class="title">getgid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">gid_t</span> <span class="title">getegid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>设置：</li>
</ul>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置当前进程的euid</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setuid</span><span class="params">(<span class="keyword">uid_t</span> uid)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置当前进程的egid</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setgid</span><span class="params">(<span class="keyword">gid_t</span> gid)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>交换：</li>
</ul>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换当前进程的ruid和euid</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setreuid</span><span class="params">(<span class="keyword">uid_t</span> ruid, <span class="keyword">uid_t</span> euid)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setregid</span><span class="params">(<span class="keyword">gid_t</span> rgid, <span class="keyword">gid_t</span> egid)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>代码示例</p>
</blockquote>
<p>实现任意用户用<code>0号用户</code>（即root）的身份查看<code>/etc/shadow</code>文件的功能：</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./mysu 0 cat /etc/shadow</span><br></pre></td></tr></tbody></table></figure>
<p>exec参数：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat -&gt; main的argv[<span class="number">2</span>]：所需要执行的程序;</span><br><span class="line">cat /etc/shadow -&gt; main的argv[<span class="number">2</span>]之后：程序名cat 命令行参数/etc/shadow</span><br></pre></td></tr></tbody></table></figure>
<p>代码实现：（以普通用户<code>lighthouse</code>编译链接）</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>{</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">3</span>) {</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Usage...\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">"fork()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>) {</span><br><span class="line">        setuid(atoi(argv[<span class="number">1</span>])); <span class="comment">// 将字符串转成int</span></span><br><span class="line">        execvp(argv[<span class="number">2</span>], argv + <span class="number">2</span>);</span><br><span class="line">        perror(<span class="string">"execvp()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    wait(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>查看该文件的属性：</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[lighthouse@HongyiZeng proc]$ ll mysu</span><br><span class="line">-rwxr-xr-x 1 lighthouse lighthouse 8800 Dec 16 12:32 mysu</span><br></pre></td></tr></tbody></table></figure>
<p>直接运行，权限不够：</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[lighthouse@HongyiZeng proc]$ ./mysu 0 cat /etc/shadow</span><br><span class="line">cat: /etc/shadow: Permission denied</span><br></pre></td></tr></tbody></table></figure>
<p>切换到<code>root</code>用户，将<code>mysu</code>属主更改为<code>root</code>，并给予该文件<code>s</code>权限：</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng proc]<span class="comment"># chown root mysu</span></span><br><span class="line">[root@HongyiZeng proc]<span class="comment"># chmod u+s mysu</span></span><br><span class="line">[root@HongyiZeng proc]<span class="comment"># ll mysu</span></span><br><span class="line">-rwsr-xr-x 1 root lighthouse 8800 Dec 16 12:32 mysu</span><br></pre></td></tr></tbody></table></figure>
<p>然后切换到<code>lighthouse</code>，再执行即可：</p>
<p><a href="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221216141111786.png" data-fancybox="gallery" data-caption="image-20221216141111786" data-thumb="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221216141111786.png"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221216141111786.png" alt="image-20221216141111786"></a></p>
<h3 id="6-7-解释器文件"><a href="#6-7-解释器文件" class="headerlink" title="6.7 解释器文件"></a>6.7 解释器文件</h3><p>解释器文件也叫脚本文件。脚本文件包括：shell脚本，python脚本等；</p>
<p>脚本文件的后缀可自定义，一般来说shell脚本的后缀名为<code>.sh</code>，python脚本的后缀名为<code>.py</code>。</p>
<p>解释器文件的执行过程：当在linux系统的shell命令行上执行一个可执行文件时，系统会<code>fork</code>一个子进程，在子进程中内核会首先将该文件当做是二进制机器文件来执行，但是内核发现该文件不是机器文件（看到第一行为<code>#!</code>）后就会返回一个错误信息，收到错误信息后进程会将该文件看做是一个解释器文件，然后扫描该文件的第一行，获取<strong>解释器程序</strong>（本质上就是可执行文件）的名字，然后执行<code>exec</code>该解释器，并将该解释器文件当做解释器的一个参数，然后开始由解释器程序从头扫描整个解释器文件，执行每条语句（如果指定解释器为<code>shell</code>，会跳过第一条语句，因为<code>#</code>是注释）。如果其中某条命令执行失败了也不会影响后续命令的执行。</p>
<p>解释器文件的格式：</p>
<figure class="highlight shell"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">shell</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!pathname [optional-argument]</span></span><br><span class="line"></span><br><span class="line">内容...</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>pathname</code>：一般是绝对路径（它不会使用<code>$PATH</code>做路径搜索），对这个文件识别是由内核做为<code>exec</code>系统调用处理的。</li>
<li><code>optional-argument</code>：相当于提供给<code>exec</code>的参数</li>
</ul>
<p>内核exec执行的并不是解释器文件，而是第一行pathname指定的文件。一定要将解释器文件（本质是一个文本文件，以    <code>#!</code>开头）和解释器（由pathname指定）区分开。</p>
<blockquote>
<p>代码示例1</p>
</blockquote>
<p>以普通用户创建脚本<code>test.sh</code>：</p>
<figure class="highlight shell"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">shell</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">ls</span><br><span class="line">whoami</span><br><span class="line">cat /etc/shadow</span><br><span class="line">ps</span><br></pre></td></tr></tbody></table></figure>
<p>这个文件没有执行权限，需要添加：</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[lighthouse@HongyiZeng proc]$ ll test.sh</span><br><span class="line">-rw-r--r-- 1 lighthouse lighthouse 46 Dec 16 15:09 test.sh</span><br><span class="line">[lighthouse@HongyiZeng proc]$ chmod u+x test.sh </span><br><span class="line">[lighthouse@HongyiZeng proc]$ ./test.sh</span><br><span class="line">ex    exv.c  fork1    hello.c   mysh    mysu.c     primer1    primer2.c  test.sh</span><br><span class="line">ex.c  few    fork1.c  myexec    mysh.c  primer0    primer1.c  sleep      vfork</span><br><span class="line">exv   few.c  hello    myexec.c  mysu    primer0.c  primer2    sleep.c    vfork.c</span><br><span class="line">lighthouse</span><br><span class="line">cat: /etc/shadow: Permission denied</span><br><span class="line">  PID TTY          TIME CMD</span><br><span class="line">14857 pts/3    00:00:00 bash</span><br><span class="line">19087 pts/3    00:00:00 test.sh</span><br><span class="line">19091 pts/3    00:00:00 ps</span><br></pre></td></tr></tbody></table></figure>
<p>shell执行<code>./test.sh</code>时，fork了一个子进程，该进程看到该文件为解释器文件，于是读取第一行，得到解释器程序的PATH，并<code>exec</code>该解释器程序（<code>/bin/bash</code>），然后重新执行这个解释器文件。</p>
<p>可以看出<code>bash</code>跳过了第一句，因为<code>#</code>在bash程序中被看成了注释，<code>cat</code>命令没有权限，但后面的<code>ps</code>命令仍然继续执行。</p>
<blockquote>
<p>代码示例2</p>
</blockquote>
<figure class="highlight shell"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">shell</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/cat</span></span><br><span class="line">ls</span><br><span class="line">whoami</span><br><span class="line">cat /etc/shadow</span><br><span class="line">ps</span><br></pre></td></tr></tbody></table></figure>
<p>执行该脚本：</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng proc]<span class="comment"># ./test.sh </span></span><br><span class="line"><span class="comment">#!/bin/cat</span></span><br><span class="line">ls</span><br><span class="line">whoami</span><br><span class="line">cat /etc/shadow</span><br><span class="line">ps</span><br></pre></td></tr></tbody></table></figure>
<p>发现这次是打印了该脚本文件的所有内容。过程同上，只是这次子进程<code>exec</code>的程序为<code>/bin/cat</code>程序。</p>
<blockquote>
<p>代码示例3——自定义解释器程序</p>
</blockquote>
<p>解释器程序（或解释器）本质上就是一个可执行文件。解释器文件是一个文本文件。</p>
<ul>
<li><code>echoarg.c</code></li>
</ul>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>{</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; argc; i++) {</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"argv[%d]: %s \n"</span>, i, argv[i]);</span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>编译为<code>echoarg</code>，并存放在<code>/usr/local/linux_c/proc/</code>下。</p>
<ul>
<li><code>echoarg.sh</code></li>
</ul>
<figure class="highlight shell"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">shell</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/usr/<span class="built_in">local</span>/linux_c/proc/echoarg foo1 foo2 foo3</span></span><br></pre></td></tr></tbody></table></figure>
<p>执行结果：</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng proc]<span class="comment"># ./echoarg.sh</span></span><br><span class="line">argv[0]: /usr/<span class="built_in">local</span>/linux_c/proc/echoarg</span><br><span class="line">argv[1]: foo1 foo2 foo3</span><br><span class="line">argv[2]: ./echoarg.sh</span><br></pre></td></tr></tbody></table></figure>
<h3 id="6-8-system函数"><a href="#6-8-system函数" class="headerlink" title="6.8 system函数"></a>6.8 system函数</h3><p>函数原型：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">system</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *command)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p>作用：该函数实际上调用的是<code>/bin/sh -c command</code>，实质上是对<code>fork+exec+wait</code>的封装。</p>
<blockquote>
<p>程序实例</p>
</blockquote>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    </span><br><span class="line">    system(<span class="string">"date +%s &gt; /tmp/out"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>该程序实质上执行的命令为：</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/sh -c date +%s &gt; /tmp/out</span><br></pre></td></tr></tbody></table></figure>
<p>在执行该命令的时候，system函数代码类似于：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    </span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">"fork()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// 实际上在 exec /bin/sh程序</span></span><br><span class="line">        execl(<span class="string">"/bin/sh"</span>, <span class="string">"sh"</span>, <span class="string">"-c"</span>, <span class="string">"date +%s &gt; /tmp/out"</span>, <span class="literal">NULL</span>);</span><br><span class="line">        perror(<span class="string">"execl()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    wait(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="6-9-守护进程"><a href="#6-9-守护进程" class="headerlink" title="6.9 守护进程"></a>6.9 守护进程</h3><h4 id="6-9-1-简介"><a href="#6-9-1-简介" class="headerlink" title="6.9.1 简介"></a>6.9.1 简介</h4><p>守护进程也叫做精灵进程（Daemon），是运行在后台的一种特殊进程，它独立于控制终端并且可以周期性的执行某种任务或者等待处理某些发生的事件。</p>
<p>守护进程常常在系统引导装入时启动，在系统关闭时终止。</p>
<p>守护进程是非常有用的进程，在Linux当中大多数服务器用的就是守护进程。比如Web服务器<code>httpd</code>等，同时守护进程完成很多系统的任务。当Linux系统启动的时候，会启动很多系统服务，这些进程服务是没有终端的，也就是说把终端关闭了，这些系统服务是不会停止的。</p>
<blockquote>
<p>特点</p>
</blockquote>
<ul>
<li>生存周期长[不是必须]：一般是操作系统启动的时候他启动，操作系统关闭的时候他才关闭</li>
<li>守护进程和终端没有关联，也就是说他们没有控制终端，所以控制终端退出也不会导致守护进程退出</li>
<li>守护进程是在后台运行不会占着终端，终端可以执行其它命令</li>
</ul>
<h4 id="6-9-2-进程组与会话"><a href="#6-9-2-进程组与会话" class="headerlink" title="6.9.2 进程组与会话"></a>6.9.2 进程组与会话</h4><ul>
<li>进程组：进程除了有PID之外还有一个进程组id，进程组是由一个进程或者多个进程组成。<ul>
<li>通常进程组与同一作业相关联，可以收到同一终端的信号：这个信号可以使同一个进程组中的所有进程终止，停止或者继续运行</li>
<li>进程组id就是组长进程的pid，只要在某个进程组中还有一个进程存在，则该进程组就存在</li>
</ul>
</li>
<li>会话：会话是有一个或者多个进程组组成的集合<ul>
<li>每打开一个控制中断，或者在用户登录时，系统就会创建新会话</li>
<li>在该会话中允许的第一个进程称作会话首进程，通常这个首进程就是shell</li>
<li>通常，一个会话开始于用户登录，终止于用户退出，<strong>在此期间该用户运行的所有进程都属于这个会话</strong></li>
</ul>
</li>
</ul>
<p><a href="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20230306142137699.png" data-fancybox="gallery" data-caption="image-20230306142137699" data-thumb="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20230306142137699.png"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20230306142137699.png" alt="image-20230306142137699"></a></p>
<p>字段含义：</p>
<ul>
<li><code>PPID</code>：父进程pid</li>
<li><code>PID</code>：当前进程pid</li>
<li><code>PGID</code>：进程组id</li>
<li><code>SID TTY</code>：当前进程的会话id</li>
<li><code>TPGID</code>：进程组和终端的关系，<code>-1</code>表示没有关系</li>
<li><code>STAT</code>：进程状态</li>
<li><code>UID</code>：启动（exec）该进程的用户的id</li>
<li><code>TIME</code>：进程执行到目前为止经历的时间</li>
<li><code>COMMAND</code>：启动该进程时的命令</li>
</ul>
<h4 id="6-9-3-创建守护进程"><a href="#6-9-3-创建守护进程" class="headerlink" title="6.9.3 创建守护进程"></a>6.9.3 创建守护进程</h4><p>相关系统调用：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">// creates a session and sets the process group ID 错误返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">setsid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p>作用：创建一个新的会话，并让执行的进程称为该会话组的组长</p>
<hr>
<p>创建流程：</p>
<ul>
<li>创建自己并被<code>init</code>进程接管：在父进程中执行fork并exit退出，让子进程被init进程接管，从而脱离终端进程shell的控制；</li>
<li>创建新进程组和新会话：在子进程中调用<code>setsid</code>函数创建新的会话和进程组；</li>
<li>修改子进程的工作目录：在子进程中调用<code>chdir</code>函数，让根目录 <code>/</code> 成为子进程的工作目录；</li>
<li>修改子进程<code>umask</code>：在子进程中调用umask函数，设置进程的umask为0；</li>
<li>在子进程中关闭任何不需要的文件描述符</li>
<li>由于守护进程和终端没有关系，所以需要将子进程的标准输入和标准输出重定向到<code>dev/null</code>（空设备当中去）</li>
</ul>
<blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    </span><br><span class="line">    pid = fork();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>) { <span class="comment">// 出错</span></span><br><span class="line">        perror(<span class="string">"fork()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) { <span class="comment">// 子进程</span></span><br><span class="line">        <span class="comment">//只有子进程才会走到这里</span></span><br><span class="line">        <span class="keyword">if</span>(setsid() == <span class="number">-1</span>) {</span><br><span class="line">            perror(<span class="string">"setsid()"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        umask(<span class="number">0</span>); <span class="comment">//设置权限掩码</span></span><br><span class="line">        fd = open(<span class="string">"/dev/null"</span>,O_RDWR); <span class="comment">//打开黑洞设备以读写方式打开</span></span><br><span class="line">        <span class="keyword">if</span>(fd == <span class="number">-1</span>) {</span><br><span class="line">             perror(<span class="string">"open"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(fd &gt; <span class="number">3</span>) { <span class="comment">// 关闭继承的文件描述符</span></span><br><span class="line">            <span class="keyword">if</span>(close(fd) == <span class="number">-1</span>) {</span><br><span class="line">                perror(<span class="string">"close()"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 重定向...</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(;;) {</span><br><span class="line">            <span class="comment">// 守护进程要完成的任务...</span></span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">// 父进程退出</span></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// nerver reach...</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>执行结果：</p>
<p><a href="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20230306145823922.png" data-fancybox="gallery" data-caption="image-20230306145823922" data-thumb="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20230306145823922.png"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20230306145823922.png" alt="image-20230306145823922"></a></p>
<p>注意：进程守护化以后，只能使用kill命令杀掉该进程</p>
<h4 id="6-9-4-后台进程和守护化"><a href="#6-9-4-后台进程和守护化" class="headerlink" title="6.9.4 后台进程和守护化"></a>6.9.4 后台进程和守护化</h4><p>使用<code>&amp;</code> ，可以将程序执行在后台：</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./<span class="built_in">test</span> &gt;&gt; out.txt 2&gt;&amp;1 &amp;</span><br></pre></td></tr></tbody></table></figure>
<p>在命令的末尾加个<code>&amp;</code>符号后，程序可以在后台运行，但是一旦当前终端关闭，该程序就会停止运行，这就是后台进程。</p>
<blockquote>
<p>后台进程和守护进程的区别</p>
</blockquote>
<ol>
<li>守护进程与终端无关，是被init进程收养的孤儿进程；而后台进程的父进程是终端，仍然可以在终端打印</li>
<li>守护进程在关闭终端时依然存在；而后台进程会随用户退出而停止</li>
<li>守护进程改变了会话、进程组、工作目录和文件描述符，<strong>后台进程直接继承父进程（shell）的</strong></li>
</ol>
<blockquote>
<p>将进程守护化</p>
</blockquote>
<p>可以使用<code>nohup(no hang up)</code>命令结合<code>&amp;</code>将进程守护化：</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup [进程名] [参数] 可执行文件 [重定向] &amp;</span><br></pre></td></tr></tbody></table></figure>
<p>例如：</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup ./<span class="built_in">test</span> &gt;&gt; out.txt &amp;</span><br></pre></td></tr></tbody></table></figure>
<p>将<code>./test</code>守护化，并将缓冲区的内容重定向至<code>out.txt</code></p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup python -u test.py &gt; nohup.out 2&gt;&amp;1 &amp;</span><br></pre></td></tr></tbody></table></figure>
<p>执行python程序，<code>-u</code>为python的参数，意为不启用缓冲，将内存中的内容直接写入到磁盘文件中。</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup java -jar demo.jar</span><br></pre></td></tr></tbody></table></figure>
<p>执行java程序。</p>
<h3 id="6-10-系统日志"><a href="#6-10-系统日志" class="headerlink" title="6.10 系统日志"></a>6.10 系统日志</h3><p>暂略</p>
<h2 id="7-信号"><a href="#7-信号" class="headerlink" title="7 信号"></a>7 信号</h2><p>该节对应第十章——信号。</p>
<h3 id="7-1-前置概念"><a href="#7-1-前置概念" class="headerlink" title="7.1 前置概念"></a>7.1 前置概念</h3><blockquote>
<p>并发和并行</p>
</blockquote>
<ul>
<li>并发（<code>concurrency</code>）：把任务在不同的时间点交给处理器进行处理。在同一时间点，任务并不会同时运行。</li>
<li>并行（<code>parallelism</code>）：把每一个任务分配给每一个处理器独立完成。在同一时间点，任务一定是同时运行。</li>
</ul>
<p><a href="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221217114203844.png" data-fancybox="gallery" data-caption="image-20221217114203844" data-thumb="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221217114203844.png"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221217114203844.png" alt="image-20221217114203844"></a></p>
<blockquote>
<p>同步和异步</p>
</blockquote>
<ul>
<li>进程同步：按照一定的顺序协同进行（有序进行），而不是同时。即一组进程为了协调其推进速度，在某些地方需要相互等待或者唤醒，这种进程间的相互制约就被称作是进程同步。这种合作现象在操作系统和并发式编程中属于经常性事件。<ul>
<li>例如，在主线程中，开启另一个线程。另一个线程去读取文件，主线程等待该线程读取完毕，那么主线程与该线程就有了同步关系。</li>
</ul>
</li>
<li>进程异步：当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。</li>
</ul>
<p>异步事件的处理：查询法（发生频率高）和通知法（发生频率低）</p>
<h3 id="7-1-信号的概念"><a href="#7-1-信号的概念" class="headerlink" title="7.1 信号的概念"></a>7.1 信号的概念</h3><p><strong>信号是软件层面的中断</strong>，是进程之间相互传递消息的一种方法，信号全称为软中断信号，也有人称作软中断，从它的命名可以看出，它的实质和使用很像中断。</p>
<p>进程之间可以通过调用<code>kill</code>库函数发送软中断信号。Linux内核也可能给进程发送信号，通知进程发生了某个事件（例如内存越界）。</p>
<p>每个信号都有一个名字。这些名字都以3个字符<code>SIG</code>开头。头文件<code>&lt;signal.h&gt;</code>中，信号名都被定义为正整数常量（信号编号）。</p>
<p>通过命令<code>kill -l</code>可以列出所有可用信号：</p>
<p>信号值 1 ~ 31  为不可靠信号（标准信号），信号会丢失；信号值 34 ~ 64 为可靠信号（实时信号），信号不会丢失。</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng signal]<span class="comment"># kill -l</span></span><br><span class="line"> 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP</span><br><span class="line"> 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1</span><br><span class="line">11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM</span><br><span class="line">16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP</span><br><span class="line">21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ</span><br><span class="line">26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR</span><br><span class="line">31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3</span><br><span class="line">38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8</span><br><span class="line">43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13</span><br><span class="line">48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12</span><br><span class="line">53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7</span><br><span class="line">58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2</span><br><span class="line">63) SIGRTMAX-1  64) SIGRTMAX</span><br></pre></td></tr></tbody></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th>信号名</th>
<th>信号值</th>
<th>发出信号的原因</th>
</tr>
</thead>
<tbody>
<tr>
<td>SIGHUP</td>
<td>1</td>
<td>终端挂起或者控制进程终止</td>
</tr>
<tr>
<td><strong>SIGINT</strong></td>
<td><strong>2</strong></td>
<td><strong>键盘中断Ctrl+c</strong></td>
</tr>
<tr>
<td>SIGQUIT</td>
<td>3</td>
<td>键盘的退出键被按下</td>
</tr>
<tr>
<td>SIGILL</td>
<td>4</td>
<td>非法指令</td>
</tr>
<tr>
<td>SIGABRT</td>
<td>6</td>
<td>由abort(3)发出的退出指令</td>
</tr>
<tr>
<td>SIGFPE</td>
<td>8</td>
<td>浮点异常</td>
</tr>
<tr>
<td><strong>SIGKILL</strong></td>
<td><strong>9</strong></td>
<td><strong>采用kill  -9 进程编号 强制杀死程序。</strong></td>
</tr>
<tr>
<td><strong>SIGSEGV</strong></td>
<td><strong>11</strong></td>
<td><strong>无效的内存引用</strong></td>
</tr>
<tr>
<td>SIGPIPE</td>
<td>13</td>
<td>管道破裂:写一个没有读端口的管道</td>
</tr>
<tr>
<td>SIGALRM</td>
<td>14</td>
<td>由alarm(2)发出的信号</td>
</tr>
<tr>
<td><strong>SIGTERM</strong></td>
<td><strong>15</strong></td>
<td><strong>采用“kill  进程编号”或“killall 程序名”通知程序。</strong></td>
</tr>
<tr>
<td>SIGUSR1</td>
<td>30,10,16</td>
<td>用户自定义信号1</td>
</tr>
<tr>
<td>SIGUSR2</td>
<td>31,12,17</td>
<td>用户自定义信号2</td>
</tr>
<tr>
<td><strong>SIGCHLD</strong></td>
<td><strong>20,17,18</strong></td>
<td><strong>子进程结束信号</strong></td>
</tr>
<tr>
<td>SIGCONT</td>
<td>19,18,25</td>
<td>进程继续（曾被停止的进程）</td>
</tr>
<tr>
<td>SIGSTOP</td>
<td>17,19,23</td>
<td>终止进程</td>
</tr>
<tr>
<td>SIGTSTP</td>
<td>18,20,24</td>
<td>控制终端（tty）上按下停止键</td>
</tr>
<tr>
<td>SIGTTIN</td>
<td>21,21,26</td>
<td>后台进程企图从控制终端读</td>
</tr>
<tr>
<td>SIGTTOU</td>
<td>22,22,27</td>
<td>后台进程企图从控制终端写</td>
</tr>
</tbody>
</table>
</div>
<p><strong>信号是异步事件的经典实例</strong>。产生信号的事件对进程而言是<strong>随机</strong>出现的。进程不能简单地测试一个变量（如 errno）来判断是否发生了一个信号，而是必须告诉内核”在此信号发生时，请执行下列操作”。</p>
<p>当某个信号出现时，可以告诉内核按下列三种方式之一进行处理，称之为信号的处理或与信号相关的工作：</p>
<ul>
<li>忽略此信号</li>
<li>捕捉信号</li>
<li>执行系统默认工作</li>
</ul>
<p>下图列出了所有信号的名字，说明了哪些系统支持此信号和信号对应的系统默认工作。可以看出C标准库支持的信号是最少的。<strong>大部分的信号的默认操作是终止进程</strong>。</p>
<p><a href="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221217131449456.png" data-fancybox="gallery" data-caption="image-20221217131449456" data-thumb="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221217131449456.png"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221217131449456.png" alt="image-20221217131449456"></a></p>
<p><code>core</code>是在进程当前工作目录的core文件中复制了该进程的内存映像，core文件记录了进程终止时的错误报告，大多数UNIX系统调试程序都使用core文件检查进程终止时的状态。</p>
<blockquote>
<p>补充：kill命令</p>
</blockquote>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> [参数] [进程号]</span><br></pre></td></tr></tbody></table></figure>
<p>常用参数：</p>
<ul>
<li><code>-l</code>：信号编号<ul>
<li>如果是<code>kill -l</code>，则列出全部的信号名称</li>
<li>如果是<code>kill -信号编号 pid</code>，则将该编号对应的信号发送给指定pid的进程</li>
<li>默认为15，对应发出终止信号，例如<code>kill 23007</code></li>
</ul>
</li>
</ul>
<p>其他常用编号：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>信号编号</th>
<th>信号名</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>EXIT</td>
<td>程序退出时收到该信息。</td>
</tr>
<tr>
<td>1</td>
<td>HUP</td>
<td>挂掉电话线或终端连接的挂起信号，这个信号也会造成某些进程在没有终止的情况下重新初始化。</td>
</tr>
<tr>
<td>2</td>
<td>INT</td>
<td>表示结束进程，但并不是强制性的，常用的 “Ctrl+C” 组合键发出就是一个 kill -2 的信号。</td>
</tr>
<tr>
<td>3</td>
<td>QUIT</td>
<td>退出。</td>
</tr>
<tr>
<td>9</td>
<td>KILL</td>
<td>杀死进程，即强制结束进程。</td>
</tr>
<tr>
<td>11</td>
<td>SEGV</td>
<td>段错误。</td>
</tr>
<tr>
<td>15</td>
<td>TERM</td>
<td>正常结束进程，是 kill 命令的<strong>默认信号</strong>。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="7-3-signal函数"><a href="#7-3-signal函数" class="headerlink" title="7.3 signal函数"></a>7.3 signal函数</h3><blockquote>
<p>补充：<code>typedef</code>的用法总结</p>
</blockquote>
<ul>
<li>定义一种类型的别名：基本用法</li>
</ul>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span>* PCHAR;</span><br><span class="line">PCHAR pa, pb;</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagPOINT</span> {</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">}POINT;</span><br><span class="line"></span><br><span class="line">POINT p1, p2;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>定义与平台无关的类型：当跨平台时，只要改下 typedef 本身就行，不用对其他源码做任何修改。标准库就广泛使用了这个技巧，比如<code>size_t</code>，<code>pid_t</code>。另外，因为typedef是定义了一种类型的新别名，不是简单的字符串替换，所以它比宏更稳健。</li>
</ul>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">double</span> REAL; <span class="comment">// 平台1</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> REAL; <span class="comment">// 平台2</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>为<strong>复杂声明</strong>定义一个新的简单的别名。</li>
</ul>
<p>例如：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 相当于给返回值为int，形参为int的这一类函数起了一个别名FUNC</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">int</span> <span class="title">FUNC</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义了返回值为int，形参为int的函数f</span></span><br><span class="line">FUNC f;  <span class="comment">// 相当于：int f(int);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = f(<span class="number">1</span>); <span class="comment">// 使用</span></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给返回值为int*，形参为int的指针函数（指针函数：返回指针的函数，本质是函数；函数指针：指向函数的指针，本质是指针）起了一个别名FUNCP，本质是一个函数</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">int</span>* <span class="title">FUNCP</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">FUNCP p; <span class="comment">// 相当于 int* p(int);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>* a = p(<span class="number">1</span>); <span class="comment">// 使用</span></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给指向返回值为int*，形参为int的指针函数的指针其一个别名FUNCP，本质是一个指针</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span>* (*FUNCP)(<span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line">FUNCP p; <span class="comment">// 相当于 int* (*p)(int);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>* a = (*p)(<span class="number">1</span>); <span class="comment">// 使用</span></span><br></pre></td></tr></tbody></table></figure>
<p>又如：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原始声明，该声明本质上是一个函数指针</span></span><br><span class="line"><span class="keyword">void</span> (* signal(<span class="keyword">int</span> signum, <span class="keyword">void</span> (*func)(<span class="keyword">int</span>)))(<span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最外层是一个函数指针，形式为：</span></span><br><span class="line"><span class="keyword">void</span> (*)(<span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内层是一个返回指针，形参为int，函数指针的函数signal</span></span><br><span class="line"><span class="comment">// 注意到signal的形参也有一个函数指针void (*func)(int)，这两个函数指针指向的都是同一种函数，即返回值为void，形参为int</span></span><br><span class="line"><span class="keyword">void</span> (*)(<span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因此给公共部分起一个别名sighandler_t，sighandler_t本质上是一个指针</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">sighandler_t</span>)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简化后的形式：</span></span><br><span class="line"><span class="function"><span class="keyword">sighandler_t</span> <span class="title">signal</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">sighandler_t</span> func)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<hr>
<p>UNIX系统信号机制最简单的接口是<code>signal</code>函数，函数原型如下：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CONFORMING TO C89, C99, POSIX.1-2001.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">sighandler_t</span>)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">sighandler_t</span> <span class="title">signal</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">sighandler_t</span> handler)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意，typedef没有定义在头文件中，因此必须要写出，否则按照下面的形式给出signal函数，APUE上的就是这种形式：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> (* signal(<span class="keyword">int</span> signum, <span class="keyword">void</span> (*func)(<span class="keyword">int</span>)))(<span class="keyword">int</span>);</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>signum</code>参数是上图中的信号名，常用宏名来表示，例如<code>SIGINT</code></li>
<li><code>func</code>参数是下面的一种：<ul>
<li><code>SIG_IGN</code>：向内核忽略此信号，除了<code>SIGKILL</code>和<code>SIGSTOP</code></li>
<li><code>SIG_DFL</code>：执行系统默认动作</li>
<li>当接到此信号后要调用的函数的地址：在信号发生时，调用该函数；称这种处理为捕捉该信号，称此函数为<strong>信号处理程序</strong>或信号捕捉函数</li>
</ul>
</li>
<li>作用：<code>signal</code>函数为<code>signum</code>所代表的信号设置一个信号处理程序<code>func</code>，换句话说，<code>signal</code>就是一个<strong>注册函数</strong>。</li>
</ul>
<blockquote>
<p>代码示例1</p>
</blockquote>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">// 忽略SIGINT信号</span></span><br><span class="line">    signal(SIGINT, SIG_IGN);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">        <span class="comment">// 每1s向终端打印1个*</span></span><br><span class="line">        write(<span class="number">1</span>, <span class="string">"*"</span>, <span class="number">1</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>信号<code>SIGINT</code>产生的方式就是快捷键<code>CTRL + C</code>。</p>
<blockquote>
<p>代码示例2</p>
</blockquote>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">int_handler</span><span class="params">(<span class="keyword">int</span> s)</span> </span>{</span><br><span class="line">    <span class="comment">// 向终端打印!</span></span><br><span class="line">    write(<span class="number">1</span>, <span class="string">"!"</span>, <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">// 函数名就是函数的地址</span></span><br><span class="line">    signal(SIGINT, int_handler);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">        write(<span class="number">1</span>, <span class="string">"*"</span>, <span class="number">1</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>每按1次<code>CTRL + C</code>，终端就打印1个<code>!</code></p>
<blockquote>
<p>代码示例3——阻塞和非阻塞</p>
</blockquote>
<p>上述程序，如果一直按着<code>CTRL + C</code>，程序会小于10S就会结束。</p>
<p>原因在于：<strong>信号会打断阻塞的系统调用</strong>。这里的阻塞是<code>write</code>和<code>sleep</code>函数。</p>
<p>分析：进程运行到<code>sleep(1)</code>的时候，由运行态进入阻塞态，此时如果有信号到来，例如<code>SIGINT</code>，会打断阻塞（唤醒进程），让进程进入就绪态，获得时间片进入运行态，此时进程还没阻塞到1s，就进入了就绪态，即信号会打断阻塞的系统调用。</p>
<ul>
<li>阻塞：为了完成一个功能，发起一个调用，<strong>如果不具备条件的话则一直等待，直到具备条件则完成</strong></li>
<li>非阻塞：为了完成一个功能，发起一个调用，<strong>具备条件直接输出，不具备条件直接报错返回</strong></li>
</ul>
<p>此前学习过的所有IO函数，都是阻塞IO，即阻塞的系统调用。</p>
<p>以<code>open</code>为例，进程调用<code>open</code>时，进入阻塞态，等待IO设备打开，如果IO设备打开时间过长，此时有一个信号到来，就会打断<code>open</code>调用，使其打开设备失败。</p>
<p>因此，在设备打开失败的时候，需要判断是因为<code>open</code>自身引发的错误，还是因为信号打断而没有打开，对于前者，以以往的方式处理错误，而对于后者应该尝试再次打开设备，而不是报错后退出程序。</p>
<p>注意：对于所有的阻塞系统调用，都要处理是因为自身调用出现的真错，还是因为信号中断导致的假错。</p>
<p>在宏中，有一个名为<code>EINTR</code>的<code>errno</code>，即为被信号中断而引发的错误。当进程在执行一个阻塞的系统调用时捕捉到一个信号，则被中断不再执行该系统调用，该系统调用返回错误，<code>errno</code>就会被设置为<code>EINTR</code>。</p>
<p><a href="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221217170001027.png" data-fancybox="gallery" data-caption="image-20221217170001027" data-thumb="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221217170001027.png"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221217170001027.png" alt="image-20221217170001027"></a></p>
<p>以前面的一个程序为例，修改后的代码为：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFSIZE 1024 <span class="comment">// 缓冲区大小</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> sfd, dfd;</span><br><span class="line">    <span class="keyword">char</span> buf[BUFSIZE];</span><br><span class="line">    <span class="keyword">int</span> len, ret, pos;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">3</span>) {</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Usage...\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">do</span> {</span><br><span class="line">        <span class="keyword">if</span>((sfd = open(argv[<span class="number">1</span>], O_RDONLY)) &lt; <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">if</span>(errno != EINTR) {</span><br><span class="line">                <span class="comment">// 不是信号导致的错误，就退出</span></span><br><span class="line">                perror(<span class="string">"open()"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">while</span>(sfd &lt; <span class="number">0</span>)</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">do</span> {</span><br><span class="line">        <span class="keyword">if</span>((dfd = open(argv[<span class="number">2</span>], O_WRONLY|O_CREAT|O_TRUNC, <span class="number">0600</span>)) &lt; <span class="number">0</span>) {			</span><br><span class="line">            <span class="keyword">if</span>(errno != EINTR) {</span><br><span class="line">                close(sfd);</span><br><span class="line">                perror(<span class="string">"open()"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">    	}</span><br><span class="line">    }<span class="keyword">while</span>(dfd &lt; <span class="number">0</span>)</span><br><span class="line">    	</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">if</span>((len = read(sfd, buf, BUFSIZE)) &lt; <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">if</span>(errno == EINTR)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            perror(<span class="string">"read()"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">		</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(len &gt; <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">if</span>((ret = write(dfd, buf + pos, len)) &lt; <span class="number">0</span>) {</span><br><span class="line">                <span class="keyword">if</span>(errno == EINTR)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                perror(<span class="string">"write()"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">            pos += ret;</span><br><span class="line">            len -= ret;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    close(dfd);</span><br><span class="line">    close(sfd);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="7-4-不可靠的信号"><a href="#7-4-不可靠的信号" class="headerlink" title="7.4 不可靠的信号"></a>7.4 不可靠的信号</h3><p>信号处理程序由内核调用，在执行该程序时，内核为该处理程序布置现场，此时如果又来一个信号，内核再次调用信号处理程序，可能会冲掉第一次调用布置的现场。</p>
<h3 id="7-5-可重入函数"><a href="#7-5-可重入函数" class="headerlink" title="7.5 可重入函数"></a>7.5 可重入函数</h3><p>可重入函数（即可以被中断的函数）可以被一个以上的任务调用，而不担心数据破坏。可重入函数在任何时候都可以被中断，而一段时间之后又可以恢复运行，而相应的数据不会破坏或者丢失。</p>
<p>不可重入的函数由于使用了一些系统资源，比如全局变量区，中断向量表等，所以它如果被中断的话，可能会出现问题，这类函数是不能运行在多任务环境下的。I/O代码通常不是可重入的，因为它们依赖于像磁盘这样共享的，单独的资源。</p>
<p>所有的系统调用都是可重入的，一部分库函数也是可重入的，例如<code>memcpy</code>。</p>
<blockquote>
<p>函数不可重入的条件</p>
</blockquote>
<ul>
<li>函数内使用了静态的数据。</li>
<li>函数内使用了malloc或者free函数</li>
<li>函数内调用了标准的I/O函数</li>
</ul>
<p>例如：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *ex1, <span class="keyword">int</span> *ex2)</span> </span>{</span><br><span class="line">    temp = *ex1; <span class="comment">//(1)</span></span><br><span class="line">    *ex1 = *ex2;</span><br><span class="line">    *ex2 = temp;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>分析：该函数中的全局变量temp是的函数变成了一个不可重入的函数，因为在多任务系统中，假如在任务1中调用swap函数，而程序执行到（1）处
时被中断，进而执行其它的任务2，而刚好任务2也调用了swap函数，则temp里存的值则会被任务2改变。从而回到任务1被中断处继续执行的时
候，temp里存的值已经不再是原来存的temp值了，进而产生了错误。</p>
<blockquote>
<p>使得函数可重入的方法</p>
</blockquote>
<ul>
<li>不要使用全局变量，防止别的代码覆盖这些变量的值。</li>
<li>调用这类函数之前先关掉中断，调用完之后马上打开中断。防止函数执行期间被中断进入别的任务执行。</li>
<li>使用信号量（互斥条件）</li>
</ul>
<h3 id="7-6-信号的响应过程"><a href="#7-6-信号的响应过程" class="headerlink" title="7.6 信号的响应过程"></a>7.6 信号的响应过程</h3><blockquote>
<p>补充：用户态和内核态的切换</p>
</blockquote>
<p>Linux系统中的内核态本质是内核，是一种特殊的软件程序，用于控制计算机的硬件资源，例如协调CPU资源，分配内存资源，并且提供稳定的环境供应用程序运行。0-4G范围的虚拟空间地址都可以操作，尤其是对3-4G范围的高位虚拟空间地址必须由内核态去操作。</p>
<p>用户态提供应用程序运行的空间，为了使应用程序访问到内核管理的资源，例如CPU，内存，I/O等。用户态只能受限的访问内存，且不允许访问外设(硬盘、网卡等);内核态CPU可以访问内存所有数据，包括外设，且可以将自己从一个程序切换到另一个程序。</p>
<p>用户态切换到内核态的三种方式：</p>
<ul>
<li>发生系统调用时：（主动）这是处于用户态的进程主动请求切换到内核态的一种方式。用户态的进程通过系统调用申请使用操作系统提供的系统调用服务例程来处理任务。而系统调用的机制，其核心仍是使用了操作系统为用户特别开发的一个中断机制来实现的，即<strong>软中断</strong>。</li>
<li>产生异常时：（被动）当CPU执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行的进程切换到处理此异常的内核相关的程序中，也就是转到了内核态，如缺页异常。</li>
<li>外设产生中断时：（被动）当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执
行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作的完成，
系统会切换到硬盘读写的中断处理程序中执行后续操作等。  </li>
</ul>
<blockquote>
<p>信号在内核中的表示</p>
</blockquote>
<ul>
<li><strong>信号递达</strong>（<code>Delivery</code>）：实际执行信号处理的动作。</li>
<li><strong>信号未决</strong>（<code>Pending</code>）：信号从产生到递达之间的状态。 </li>
<li><strong>信号阻塞</strong>（<code>Block</code>）：被阻塞的信号产生时将保持在未决状态，直到进程解除对此信号的阻塞，才执行递达的动作。</li>
</ul>
<p>有如下结论：</p>
<ul>
<li>信号从收到到响应有一个不可避免的延迟。</li>
<li>标准信号的响应没有严格顺序。</li>
</ul>
<p>内核为<strong>每个进程</strong>都维护了两个位图，一般为32位，两个位图进行<strong>与操作</strong>：</p>
<ul>
<li><strong>信号屏蔽字 mask</strong> ：用来屏蔽信号，mask初始值一般全部都是1，表示不屏蔽全部信号</li>
<li><strong>位图 pending</strong>： 用来记录当前进程收到哪些信号，一般初始值全部都是0，表示没有收到信号，未决信号集。</li>
</ul>
<blockquote>
<p>信号响应过程</p>
</blockquote>
<p>以打印<code>*</code>和<code>!</code>的程序为例。</p>
<ul>
<li>在没有其他中断的情况下，当时间片耗尽时，进程被计时器中断，使得该进程被切换至内核态，在内核态中运行计时器中断的处理函数（<code>handler</code>），进程调度算法就发生在计时器中断的处理函数中（在这个处理函数中，系统会根据任务调度算法，从就绪队列里选择下一个运行的进程）。该进程等待调度。<ul>
<li>进程当前的状态和信息被压入到内核栈中，其中包括程序的返回地址。</li>
<li>进程被内核调度时，进程从内核态切换至用户态，从内核栈中保存的返回地址继续运行</li>
<li>进程从内核态切换至用户态时（也只有在这个时刻），会执行<code>mask &amp; pending</code>，确认自己是否收到信号。对于这种情况，按位与结果为每位都为0，表示进程没有收到信号。</li>
</ul>
</li>
<li>当进程在某一刻收到<code>SIGINT</code>信号，此时将<code>pending</code>第2位置为1，表示收到<code>SIGINT</code>信号，但此时进程并不会被该信号中断（即响应该信号）。当时间片耗尽，一直到被调度，进程从内核态切换至用户态，执行<code>mask &amp; pending</code>时，发现只有第2位结果为1，此时进程才响应该信号。因此说，信号从收到到响应有一个不可避免的延迟。<ul>
<li>响应信号时的操作：内核将该位的<code>mask</code>和<code>pending</code>都置为0，并将程序返回地址修改为<code>int_handler</code>，即信号响应程序的地址，此时在用户态执行信号响应程序。换句话说，<strong>信号的收到的时刻是随机的，而信号的响应总是在从内核态切换到用户态时进行的</strong>；</li>
<li>信号响应程序执行完毕后，从用户态切换至内核态，内核将返回地址修改为程序的返回地址，并将<code>mask</code>的该位置为1；</li>
<li>再次被调度到时，切换至用户态，执行<code>mask &amp; pending</code>，发现均为0，说明刚才的信号已经被响应了，则继续向下执行程序；</li>
</ul>
</li>
</ul>
<blockquote>
<p>如何忽略一个信号？</p>
</blockquote>
<p>注意到<code>func</code>（信号处理程序）可以为宏<code>SIG_ING</code>，实质上是将<code>mask</code>的位置为0，表示屏蔽该信号。</p>
<p>注意：我们能做的是不响应信号，即不对信号做处理（屏蔽），而不是阻止信号产生和到来。信号的随时都会到来，将<code>pending</code>置为1。</p>
<blockquote>
<p><strong>标准信号</strong>为什么不可靠，或者说标准信号为什么会丢失？</p>
</blockquote>
<p>信号响应时，位图为<code>(m0 p0)</code>，此时又来<strong>多个</strong>信号，则<code>p</code>被反复置为1，即结果总是为<code>(m0 p1)</code>；信号响应完毕时，将<code>m</code>置为1，此时为<code>(m1 p1)</code>；返回用户态时，发现该位仍然为1，说明又来<strong>一个</strong>信号（注意不是多个），则继续响应…所以多个信号到来时，只有最后一个信号能够被响应，前面的信号都被丢失了。</p>
<blockquote>
<p>总结：mask和pending的变化情况</p>
</blockquote>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mask pending</span><br><span class="line"><span class="number">1</span>		<span class="number">0</span>	<span class="comment">// 初始化</span></span><br><span class="line">			<span class="comment">// 进程处理自己的任务...</span></span><br><span class="line"><span class="number">1</span>		<span class="number">1</span>	<span class="comment">// 某一时刻信号到来</span></span><br><span class="line">            <span class="comment">// 进程处理自己的任务...,直到重新被调度时</span></span><br><span class="line"><span class="number">0</span>		<span class="number">0</span>	<span class="comment">// 信号响应 内核态-&gt;用户态时</span></span><br><span class="line">    		<span class="comment">// 进入到信号处理函数中执行</span></span><br><span class="line"><span class="number">1</span>		<span class="number">0</span>	<span class="comment">// 信号响应完毕</span></span><br><span class="line">     		<span class="comment">// 进程继续处理自己的任务</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="7-7-常用函数Ⅰ"><a href="#7-7-常用函数Ⅰ" class="headerlink" title="7.7 常用函数Ⅰ"></a>7.7 常用函数Ⅰ</h3><h4 id="7-7-1-kill"><a href="#7-7-1-kill" class="headerlink" title="7.7.1 kill"></a>7.7.1 kill</h4><p>kill函数用于向进程发送信号，注意不是杀死进程。</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kill</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> sig)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p>参数：</p>
<ul>
<li>pid：向哪个进程发送信号<ul>
<li><code>pid &gt; 0</code>：发送信号给指定进程</li>
<li><code>pid = 0</code>：发送信号给跟调用kill函数的那个进程处于同一进程组的进程，相当于组内广播。</li>
<li><code>pid &lt; -1</code>：发送信号给该绝对值所对应的进程组id的所有组员，相当于组内广播。</li>
<li><code>pid = -1</code>：发送信号给所有权限发送的所有进程。</li>
</ul>
</li>
<li><code>sig</code>：待发送的信号<ul>
<li><code>sig = 0</code>：没有信号发送，但会返回-1并设置<code>errno</code>，用来检测某个进程id或进程组id是否存在。注意返回-1时并不能表明该id不存在，而是要根据<code>errno</code>来判断，详见下面的返回值。</li>
</ul>
</li>
</ul>
<p>返回值：</p>
<ul>
<li>成功返回0</li>
<li>失败返回-1，并设值errno<ul>
<li><code>EINVAL</code>：无效的信号<code>sig</code></li>
<li><code>EPERM</code>：调用进程没有权限给<code>pid</code>的进程发送信号</li>
<li><code>ESRCH</code>：进程或进程组不存在</li>
</ul>
</li>
</ul>
<h4 id="7-7-2-raise"><a href="#7-7-2-raise" class="headerlink" title="7.7.2 raise"></a>7.7.2 raise</h4><p>raise函数用于向调用进程发送信号，即自己给自己发送信号。</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">raise</span><span class="params">(<span class="keyword">int</span> sig)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line">kill(getpid(), sig);</span><br></pre></td></tr></tbody></table></figure>
<h4 id="7-7-3-alarm"><a href="#7-7-3-alarm" class="headerlink" title="7.7.3 alarm"></a>7.7.3 alarm</h4><p>alarm函数</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">alarm</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seconds)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p>作用：设置定时器。在指定seconds后，内核会给当前进程发送<code>SIGALRM</code>信号（定时器超时）。进程收到该信号，默认动作终止。每个进程都有且只有唯一的一个定时器，所以多个alarm函数共同调用时，后面设置的时钟会覆盖掉前面的时钟。</p>
<p>返回值：返回0或剩余的秒数，无失败。</p>
<blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    alarm(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>执行结果：</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng signal]<span class="comment"># ./alarm </span></span><br><span class="line">Alarm clock</span><br></pre></td></tr></tbody></table></figure>
<h4 id="7-7-4-pause"><a href="#7-7-4-pause" class="headerlink" title="7.7.4 pause"></a>7.7.4 pause</h4><p>pause函数用于等待信号。</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pause</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p>进程调用pause函数时，会造成进程主动挂起（处于阻塞状态，并主动放弃CPU），并且等待信号将其唤醒。</p>
<blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    alarm(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        pause();</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>当调用到<code>pause()</code>时，该进程挂起，此时不再占用CPU，5s过后，接收到<code>SIGALRM</code>信号，采取默认动作终止。</p>
<p>信号的处理方式有三种：</p>
<ul>
<li>默认动作</li>
<li>忽略处理</li>
<li>捕捉</li>
</ul>
<p>进程收到一个信号后，会先处理响应信号，再唤醒pause函数。于是有下面几种情况：</p>
<ul>
<li>如果信号的默认处理动作是终止进程，则进程将被终止，也就是说一收到信号进程就终止了，pause函数根本就没有机会返回，例如上面的例子</li>
<li>如果信号的默认处理动作是忽略，则进程将直接忽略该信号，相当于没收到这个信号，进程继续处于挂起状态，pause函数不返回</li>
<li>如果信号的处理动作是捕捉，则进程调用完信号处理函数之后，pause返回-1，errno设置为EINTR，表示“被信号中断”</li>
<li>pause收到的信号不能被屏蔽，如果被屏蔽，那么pause就不能被唤醒</li>
</ul>
<p><code>sleep = alarm + pause</code></p>
<blockquote>
<p>代码示例</p>
</blockquote>
<p>需求：让程序等待5s</p>
<ul>
<li>使用<code>time</code></li>
</ul>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    <span class="keyword">time_t</span> end;</span><br><span class="line">    <span class="keyword">int64_t</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    end = time(<span class="literal">NULL</span>) + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(time(<span class="literal">NULL</span>) &lt;= end) {</span><br><span class="line">        count++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, count);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>执行结果：</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng signal]<span class="comment"># time ./pause &gt; /tmp/out</span></span><br><span class="line">real    0m5.142s</span><br><span class="line">user    0m4.950s</span><br><span class="line">sys     0m0.005s</span><br><span class="line">[root@HongyiZeng signal]<span class="comment"># time ./pause &gt; /tmp/out</span></span><br><span class="line">real    0m5.181s</span><br><span class="line">user    0m5.045s</span><br><span class="line">sys     0m0.008s</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>使用<code>alarm</code></li>
</ul>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环跳出的标志</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> loop = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alrm_handler</span><span class="params">(<span class="keyword">int</span> s)</span> </span>{</span><br><span class="line">    loop = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    <span class="keyword">int64_t</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 对信号SIGALRM注册信号处理函数</span></span><br><span class="line">    signal(SIGALRM, alrm_handler);</span><br><span class="line">    alarm(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">while</span>(loop)</span><br><span class="line">        count++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, count);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果：</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng signal]<span class="comment"># time ./5sec_sig &gt; /tmp/out</span></span><br><span class="line">real    0m5.029s</span><br><span class="line">user    0m4.821s</span><br><span class="line">sys     0m0.012s</span><br><span class="line">[root@HongyiZeng signal]<span class="comment"># time ./5sec_sig &gt; /tmp/out</span></span><br><span class="line">real    0m5.017s</span><br><span class="line">user    0m4.864s</span><br><span class="line">sys     0m0.006s</span><br></pre></td></tr></tbody></table></figure>
<hr>
<p>当对上述程序进行编译优化时：</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc 5sec_sig.c -O1</span><br></pre></td></tr></tbody></table></figure>
<p>再次执行，发现程序一直在运行。</p>
<p>原因：编译优化时，gcc看到下面的循环体中没有出现<code>loop</code>，所以gcc认为loop是不变的，将loop的值存储在高速缓存（CPU的寄存器）中，每次读取loop的值时，从高速缓存中读取，而不是在loop实际存放的内存地址中读取，因此一直在此处循环。</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(loop)</span><br><span class="line">    count++;</span><br></pre></td></tr></tbody></table></figure>
<p>解决方法：用<code>volatile</code>修饰<code>loop</code>，此时编译器认为该变量易变，每次读取时从实际内存地址中读取：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> loop = <span class="number">1</span>;</span><br></pre></td></tr></tbody></table></figure>
<hr>
<p>从汇编的角度来看：</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -S 5sec_sig.c -O1</span><br></pre></td></tr></tbody></table></figure>
<p>未加易变修饰前：（省略不重要的代码）</p>
<figure class="highlight plaintext"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">plaintext</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">main:</span><br><span class="line">.LFB24:</span><br><span class="line">        .cfi_startproc</span><br><span class="line">        subq    $8, %rsp</span><br><span class="line">        .cfi_def_cfa_offset 16</span><br><span class="line">        movl    $5, %edi</span><br><span class="line">        movl    $0, %eax</span><br><span class="line">        call    alarm</span><br><span class="line">        movl    $alrm_handler, %esi</span><br><span class="line">        movl    $14, %edi</span><br><span class="line">        call    signal</span><br><span class="line">        cmpl    $0, loop(%rip) # 判断loop</span><br><span class="line">        jne     .L5 # 跳转到循环体中</span><br><span class="line">        movl    $0, %esi</span><br><span class="line">        movl    $.LC0, %edi</span><br><span class="line">        movl    $0, %eax</span><br><span class="line">        call    printf</span><br><span class="line">        movl    $0, %edi</span><br><span class="line">        call    exit</span><br><span class="line">.L5:</span><br><span class="line">        jmp     .L5 # 死循环</span><br><span class="line">        .cfi_endproc</span><br></pre></td></tr></tbody></table></figure>
<p>加上易变修饰后：</p>
<figure class="highlight plaintext"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">plaintext</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">main:</span><br><span class="line">.LFB24:</span><br><span class="line">        .cfi_startproc</span><br><span class="line">        subq    $8, %rsp</span><br><span class="line">        .cfi_def_cfa_offset 16</span><br><span class="line">        movl    $5, %edi</span><br><span class="line">        movl    $0, %eax</span><br><span class="line">        call    alarm</span><br><span class="line">        movl    $alrm_handler, %esi</span><br><span class="line">        movl    $14, %edi</span><br><span class="line">        call    signal</span><br><span class="line">        movl    loop(%rip), %eax</span><br><span class="line">        testl   %eax, %eax # 判断loop</span><br><span class="line">        je      .L5 # 跳入循环</span><br><span class="line">        movl    $0, %esi</span><br><span class="line">.L4:</span><br><span class="line">        addq    $1, %rsi</span><br><span class="line">        movl    loop(%rip), %eax</span><br><span class="line">        testl   %eax, %eax</span><br><span class="line">        jne     .L4</span><br><span class="line">        jmp     .L3</span><br><span class="line">.L5:</span><br><span class="line">        movl    $0, %esi</span><br><span class="line">.L3:</span><br><span class="line">        movl    $.LC0, %edi</span><br><span class="line">        movl    $0, %eax</span><br><span class="line">        call    printf</span><br><span class="line">        movl    $0, %edi</span><br><span class="line">        call    exit</span><br><span class="line">        .cfi_endproc</span><br></pre></td></tr></tbody></table></figure>
<h4 id="7-7-5-漏桶"><a href="#7-7-5-漏桶" class="headerlink" title="7.7.5 漏桶"></a>7.7.5 漏桶</h4><p><code>leaky bucket</code>也叫漏桶，就是将请求先放到一个桶中进行排队，然后按一个固定的速率来处理请求，即所谓的漏出。</p>
<p>桶具有一定的容量，即最大容量的请求数，当排队请求的数量超过桶的容量时，再进来的请求就直接过滤掉，不再被处理。换句话说就是请求先在桶中排队，
系统或服务只以一个恒定的速度从桶中将请求取出进行处理。如果排队的请求数量超过桶能够容纳的最大数量，即桶装满了，则直接丢弃。</p>
<p>漏桶算法(Leaky Bucket)是网络世界中流量整形（Traffic Shaping）或速率限制（Rate Limiting）时经常使用的一种算法，它的主要目的是控制数据注入到网络的速率，平滑网络上的突发流量。</p>
<p>需求：实现一个复制文本到标准输出的程序，要求10字符10字符的复制，且不能让CPU空转。</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CPS     10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFSIZE CPS</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> loop = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alrm_handler</span><span class="params">(<span class="keyword">int</span> s)</span> </span>{</span><br><span class="line">    alarm(<span class="number">1</span>);</span><br><span class="line">    loop = <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> sfd, dfd = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[BUFSIZE];</span><br><span class="line">    <span class="keyword">int</span> len, ret, pos;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>) {</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Usage...\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    signal(SIGALRM, alrm_handler);</span><br><span class="line">    alarm(<span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">do</span> {</span><br><span class="line">        <span class="keyword">if</span>((sfd = open(argv[<span class="number">1</span>], O_RDONLY)) &lt; <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">if</span>(errno != EINTR) {</span><br><span class="line">                perror(<span class="string">"open()"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">while</span>(sfd &lt; <span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!loop)</span><br><span class="line">            <span class="comment">// 防止CPU空转</span></span><br><span class="line">            pause();</span><br><span class="line">        loop = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((len = read(sfd, buf, BUFSIZE)) &lt; <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">if</span>(errno == EINTR)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            perror(<span class="string">"read()"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">		</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(len &gt; <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">if</span>((ret = write(dfd, buf + pos, len)) &lt; <span class="number">0</span>) {</span><br><span class="line">                <span class="keyword">if</span>(errno == EINTR)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                perror(<span class="string">"write()"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">            pos += ret;</span><br><span class="line">            len -= ret;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    close(sfd);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="7-7-6-令牌桶"><a href="#7-7-6-令牌桶" class="headerlink" title="7.7.6 令牌桶"></a>7.7.6 令牌桶</h4><p>系统会以一个恒定的速度往桶里放入令牌，而如果请求需要被处理，则需要先从桶里获取一个令牌，当桶里没有令牌可取时，则拒绝服务。 当桶满时，新添加的令牌被丢弃或拒绝。</p>
<p>令牌桶算法是一个存放固定容量令牌（token）的桶，按照固定速率往桶里添加令牌。令牌桶算法基本可以用下面的几个概念来描述：</p>
<ul>
<li>令牌将按照固定的速率被放入令牌桶中。比如每秒放10个。</li>
<li>桶中最多存放b个令牌，当桶满时，新添加的令牌被丢弃或拒绝。</li>
<li>当一个n个字节大小的数据包到达，将从桶中删除n个令牌，接着数据包被发送到网络上。</li>
<li>如果桶中的令牌不足n个，则不会删除令牌，且该数据包将被限流（要么丢弃，要么缓冲区等待）。</li>
</ul>
<blockquote>
<p>令牌桶和漏桶的区别</p>
</blockquote>
<p>主要区别在于漏桶算法能够强行限制数据的传输速率，而令牌桶算法在能够限制数据的平均传输速率外，还允许某种程度的突发传输。在令牌桶算法中，只要令牌桶中存在令牌，那么就允许突发地传输数据直到达到用户配置的门限，因此它<strong>适合于具有突发特性的流量</strong>。</p>
<blockquote>
<p>代码示例</p>
</blockquote>
<p>暂略</p>
<h3 id="7-8-信号集"><a href="#7-8-信号集" class="headerlink" title="7.8 信号集"></a>7.8 信号集</h3><p>信号集是一个能够表示多个信号的数据类型。</p>
<p><code>POSIX.1</code>定义数据类型<code>sigset_t</code>来表示一个信号集（本质为整型），并且定义了下列5个处理信号集的函数：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 置空一个信号集</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigemptyset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 填充满一个信号集</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigfillset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将一个信号加入信号集</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaddset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signum)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将一个信号从信号集删除</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigdelset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signum)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上述函数成功返回0，失败返回-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查一个信号集中是否有这个信号，存在返回1，不存在返回0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigismember</span><span class="params">(<span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signum)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<h3 id="7-9-sigprocmask函数"><a href="#7-9-sigprocmask函数" class="headerlink" title="7.9 sigprocmask函数"></a>7.9 sigprocmask函数</h3><p><code>sigprocmask</code>函数可以检测或更改，或同时进行检测和更改进程的信号屏蔽字（阻塞信号集）。注：对信号来说，阻塞和屏蔽是一个意思。</p>
<p>函数原型：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="comment">// 成功返回0，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigprocmask</span><span class="params">(<span class="keyword">int</span> how, <span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">sigset_t</span> *oldset)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>how</code>：用于指定信号修改的方式，有三种选择：<ul>
<li><code>SIG_BLOCK</code>：该进程新的信号屏蔽字是其当前信号屏蔽字和set指向信号集的并集。即set包含了<strong>希望阻塞</strong>的附加信号；</li>
<li><code>SIG_UNBLOCK</code>：该进程新的信号屏蔽字是其当前信号屏蔽字和set所指向信号集补集的交集。即set包含了<strong>希望解除阻塞</strong>的信号；</li>
<li><code>SIG_SETMASK</code>：该进程新的信号屏蔽是set指向的值；</li>
</ul>
</li>
<li><code>*set</code>：和how结合使用</li>
<li><code>*oldset</code>：进程的当前信号屏蔽字通过<code>oset</code>返回（<code>oldset</code>），如果不关心旧的信号集设置，可设置为<code>NULL</code></li>
</ul>
<blockquote>
<p>代码示例1</p>
</blockquote>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">int_handler</span><span class="params">(<span class="keyword">int</span> s)</span> </span>{</span><br><span class="line">	write(<span class="number">1</span>, <span class="string">"!"</span>, <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">sigset_t</span> <span class="built_in">set</span>;</span><br><span class="line"></span><br><span class="line">	signal(SIGINT, int_handler);</span><br><span class="line">    <span class="comment">// 置空一个信号集set</span></span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">    <span class="comment">// 将SIGINT加入到信号集set中</span></span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>, SIGINT);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">        <span class="comment">// 设置信号屏蔽字</span></span><br><span class="line">        <span class="comment">// 将SIGINT屏蔽</span></span><br><span class="line">        sigprocmask(SIG_BLOCK, &amp;<span class="built_in">set</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) {</span><br><span class="line">            write(<span class="number">1</span>, <span class="string">"*"</span>, <span class="number">1</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">	    }</span><br><span class="line">        write(<span class="number">1</span>, <span class="string">"\n"</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 打印5个*后，将SIGINT解除屏蔽</span></span><br><span class="line">        sigprocmask(SIG_UNBLOCK, &amp;<span class="built_in">set</span>, <span class="literal">NULL</span>);</span><br><span class="line">    }</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>执行结果：</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng signal]<span class="comment"># ./block</span></span><br><span class="line">*****</span><br><span class="line">*^C****</span><br><span class="line">!*^C^C^C^C*^C^C^C^C^C^C^C^C^C***</span><br><span class="line">!***^C^C^C**</span><br><span class="line">!****^\Quit</span><br></pre></td></tr></tbody></table></figure>
<p>解析：第三行发送SIGINT信号时，SIGINT的屏蔽字位为0，pending位置为1，当打印完成后，解除屏蔽，进程响应该信号，在第四行打印了<code>!</code>；第四行多次发送SIGINT信号，也只是对pending位反复置为1，在第五行也只打印一次<code>!</code>；</p>
<blockquote>
<p>代码示例2</p>
</blockquote>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">sigset_t</span> <span class="built_in">set</span>, oset;</span><br><span class="line">	signal(SIGINT, int_handler);</span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>, SIGINT);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">        <span class="comment">// 将SIGINT阻塞，并将原始的屏蔽字存储在oset中，且原始屏蔽字都是1</span></span><br><span class="line">        sigprocmask(SIG_BLOCK, &amp;<span class="built_in">set</span>, &amp;oset);</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) {</span><br><span class="line">            write(<span class="number">1</span>, <span class="string">"*"</span>, <span class="number">1</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">	    }</span><br><span class="line">        write(<span class="number">1</span>, <span class="string">"\n"</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 将屏蔽字设置为oset信号集的值，即全1，没有屏蔽</span></span><br><span class="line">        sigprocmask(SIG_SETMASK, &amp;oset, <span class="literal">NULL</span>);</span><br><span class="line">    }</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>功能和代码示例1相同。</p>
<blockquote>
<p>代码示例3</p>
</blockquote>
<p>为了保证在进入模块和退出模块时进程的信号屏蔽字是一致的，需要修改代码为：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">sigset_t</span> <span class="built_in">set</span>, oset, saveset;</span><br><span class="line">	signal(SIGINT, int_handler);</span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>, SIGINT);</span><br><span class="line">    <span class="comment">// 将进程起始的信号屏蔽字保存在saveset中</span></span><br><span class="line">    sigprocmask(SIG_UNBLOCK, &amp;<span class="built_in">set</span>, &amp;saveset);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">        sigprocmask(SIG_BLOCK, &amp;<span class="built_in">set</span>, &amp;oset);</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) {</span><br><span class="line">            write(<span class="number">1</span>, <span class="string">"*"</span>, <span class="number">1</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">	    }</span><br><span class="line">        write(<span class="number">1</span>, <span class="string">"\n"</span>, <span class="number">1</span>);</span><br><span class="line">        sigprocmask(SIG_SETMASK, &amp;oset, <span class="literal">NULL</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 退出时，还原信号屏蔽字</span></span><br><span class="line">    sigprocmask(SIG_SETMASK, &amp;saveset, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="7-10-sigpending函数"><a href="#7-10-sigpending函数" class="headerlink" title="7.10 sigpending函数"></a>7.10 sigpending函数</h3><p>略</p>
<h3 id="7-11-常用函数Ⅱ"><a href="#7-11-常用函数Ⅱ" class="headerlink" title="7.11 常用函数Ⅱ"></a>7.11 常用函数Ⅱ</h3><h4 id="7-11-1-sigsuspend函数"><a href="#7-11-1-sigsuspend函数" class="headerlink" title="7.11.1 sigsuspend函数"></a>7.11.1 sigsuspend函数</h4><p>该函数通过将进程的屏蔽字替换为由参数<code>mask</code>给出的信号集，然后将进程挂起（阻塞）。</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigsuspend</span><span class="params">(<span class="keyword">const</span> <span class="keyword">sigset_t</span> *mask)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p>功能描述上和<code>pause</code>函数相同，即在等待信号的时候让进程挂起。</p>
<p>区别：sigsuspend实际是将sigprocmask和pause结合起来原子操作。</p>
<blockquote>
<p>代码示例</p>
</blockquote>
<p>需求：先打印一排<code>*</code>，等待信号，然后打印一排<code>*</code>，以此类推。</p>
<ul>
<li>使用<code>pause</code></li>
</ul>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">int_handler</span><span class="params">(<span class="keyword">int</span> s)</span> </span>{</span><br><span class="line">	write(<span class="number">1</span>, <span class="string">"!"</span>, <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">sigset_t</span> <span class="built_in">set</span>, oset, saveset;</span><br><span class="line">	signal(SIGINT, int_handler);</span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>, SIGINT);</span><br><span class="line">    sigprocmask(SIG_UNBLOCK, &amp;<span class="built_in">set</span>, &amp;saveset);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">        sigprocmask(SIG_BLOCK, &amp;<span class="built_in">set</span>, &amp;oset);</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) {</span><br><span class="line">            write(<span class="number">1</span>, <span class="string">"*"</span>, <span class="number">1</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">	    }</span><br><span class="line">        write(<span class="number">1</span>, <span class="string">"\n"</span>, <span class="number">1</span>);</span><br><span class="line">        sigprocmask(SIG_SETMASK, &amp;oset, <span class="literal">NULL</span>);</span><br><span class="line">        pause();</span><br><span class="line">    }</span><br><span class="line">    sigprocmask(SIG_SETMASK, &amp;saveset, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>执行结果：</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng signal]<span class="comment"># ./susp </span></span><br><span class="line">*****</span><br><span class="line">^C!*****</span><br><span class="line">^C!**^C^C^C***</span><br><span class="line">!</span><br></pre></td></tr></tbody></table></figure>
<p>第二行开始处：当内层循环执行完毕后，到pause处挂起，此时SIGINT到来，首先处理信号，然后唤醒进程，继续执行内层循环打印。</p>
<p>注意第四行，当在内层循环执行时，有多个SIGINT信号到来，由于被屏蔽，所以不打印叹号，打印星号结束后，代码第十九行解除屏蔽（注意，代码第
十九行和第二十行之间也会存在多个中断），响应信号（第五行的第一个叹号），再执行到代码第二十行处时，此时没有信号到来，所以一直挂起。</p>
<ul>
<li>使用<code>sigsuspend</code></li>
</ul>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">int_handler</span><span class="params">(<span class="keyword">int</span> s)</span> </span>{</span><br><span class="line">	write(<span class="number">1</span>, <span class="string">"!"</span>, <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">sigset_t</span> <span class="built_in">set</span>, oset, saveset;</span><br><span class="line">	signal(SIGINT, int_handler);</span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>, SIGINT);</span><br><span class="line">    <span class="comment">// 保存初始屏蔽字</span></span><br><span class="line">    sigprocmask(SIG_UNBLOCK, &amp;<span class="built_in">set</span>, &amp;saveset);</span><br><span class="line">    <span class="comment">// 设置阻塞</span></span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;<span class="built_in">set</span>, &amp;oset);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) {</span><br><span class="line">            write(<span class="number">1</span>, <span class="string">"*"</span>, <span class="number">1</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">	    }</span><br><span class="line">        write(<span class="number">1</span>, <span class="string">"\n"</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 挂起</span></span><br><span class="line">        sigsuspend(&amp;oset);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        sigset_t tmpset;</span></span><br><span class="line"><span class="comment">        sigprocmask(SIG_SETMASK, &amp;oset, &amp;tmpset);</span></span><br><span class="line"><span class="comment">        pause();</span></span><br><span class="line"><span class="comment">        sigprocmask(SIG_SETMASK, &amp;tmpset, NULL);</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    }</span><br><span class="line">    sigprocmask(SIG_SETMASK, &amp;saveset, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="7-11-2-sigaction函数"><a href="#7-11-2-sigaction函数" class="headerlink" title="7.11.2 sigaction函数"></a>7.11.2 sigaction函数</h4><p>sigaction函数是升级版的signal函数。</p>
<p>sigaction函数的功能是检查或修改与指定信号相关联的处理动作（可同时两种操作）。</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaction</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">const</span> struct sigaction *act, struct sigaction *oldact)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>signum</code>参数指出要捕获的信号类型</li>
<li><code>act</code>参数指定新的信号处理方式</li>
<li><code>oldact</code>参数输出先前信号的处理方式（如果不为NULL的话）</li>
</ul>
<p><code>struct sigaction</code>结构体定义如下：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> {</span></span><br><span class="line">    <span class="keyword">void</span> (*sa_handler)(<span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">void</span> (*sa_sigaction)(<span class="keyword">int</span>, <span class="keyword">siginfo_t</span> *, <span class="keyword">void</span> *);</span><br><span class="line">    <span class="keyword">sigset_t</span> sa_mask;</span><br><span class="line">    <span class="keyword">int</span> sa_flags;</span><br><span class="line">    <span class="keyword">void</span> (*sa_restorer)(<span class="keyword">void</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>sa_handler</code>：此参数和signal()的参数handler相同，代表新的信号处理函数</li>
<li><code>sa_mask</code>：用来设置在处理该信号时暂时将 sa_mask 指定的信号集屏蔽</li>
<li><code>sa_flags</code>：用来设置信号处理的其他相关操作，下列的数值可用。 <ul>
<li><code>SA_RESETHAND</code>：当调用信号处理函数时，将信号的处理函数重置为缺省值SIG_DFL</li>
<li><code>SA_RESTART</code>：如果信号中断了进程的某个系统调用，则系统自动启动该系统调用</li>
<li><code>SA_NODEFER</code> ：一般情况下， 当信号处理函数运行时，内核将阻塞该给定信号。但是如果设置了SA_NODEFER标记， 那么在该信号处理函数运行时，内核将不会阻塞该信号</li>
<li><code>SA_SIGINFO</code>：调用信号处理器程序时携带了额外参数，其中提供了关于信号的深入信息</li>
</ul>
</li>
<li><code>sa_sigaction</code>：这是一个三个参数的<code>sa_handler</code>函数版本。如果设置了<code>SA_SIGINFO</code>标志位，则会使用<code>sa_sigaction</code>处理函数，否则使用<code>sa_handler</code>处理函数。其中参数<code>siginfo_t</code>是一个结构体类型</li>
</ul>
<blockquote>
<p>代码示例1</p>
</blockquote>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需求：三种信号SIGQUIT，SIGTERM，SIGINT共用一个信号处理函数，且该函数中释放了重要的资源，因此不可重入。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">daemon_exit</span><span class="params">(<span class="keyword">int</span> s)</span> </span>{</span><br><span class="line">    <span class="comment">// 释放相关资源</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line">    <span class="comment">// 设置信号处理函数</span></span><br><span class="line">    sa.sa_handler = daemon_exit;</span><br><span class="line">    sigemptyset(&amp;sa.sa_mask);</span><br><span class="line">    <span class="comment">// 将SIGQUIT，SIGTERM，SIGINT信号阻塞，防止重入</span></span><br><span class="line">    sigaddset(&amp;sa.sa_mask, SIGQUIT);</span><br><span class="line">    sigaddset(&amp;sa.sa_mask, SIGTERM);</span><br><span class="line">    sigaddset(&amp;sa.sa_mask, SIGINT);</span><br><span class="line">    sa.sa_flags = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 要捕获SIGQUIT，SIGTERM，SIGINT三种信号</span></span><br><span class="line">    sigaction(SIGINT, &amp;sa, <span class="literal">NULL</span>);</span><br><span class="line">    sigaction(SIGTERM, &amp;sa, <span class="literal">NULL</span>);</span><br><span class="line">    sigaction(SIGQUIT, &amp;sa, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>代码示例2</p>
</blockquote>
<p>暂略</p>
<h3 id="7-12-实时信号"><a href="#7-12-实时信号" class="headerlink" title="7.12 实时信号"></a>7.12 实时信号</h3><p>暂略</p>
<h3 id="7-13-信号实现原理"><a href="#7-13-信号实现原理" class="headerlink" title="7.13 信号实现原理"></a>7.13 信号实现原理</h3><p>该节是对<code>7.6节信号的响应过程</code>的补充扩展。</p>
<h4 id="7-13-1-未决和阻塞信号集"><a href="#7-13-1-未决和阻塞信号集" class="headerlink" title="7.13.1 未决和阻塞信号集"></a>7.13.1 未决和阻塞信号集</h4><p>在 PCB 中有两个非常重要的信号集。一个称之为 <code>阻塞信号集 mask</code>，另一个称之为 <code>未决信号集 pending</code>。这两个信号集体现在内核中就是两张表。</p>
<p>但是操作系统不允许我们直接对这两个信号集进行任何操作，而是需要自定义另外一个集合，借助<strong>信号集操作函数</strong>（详见<code>7.8-7.10节</code>）来对 PCB 中的这两个信号集进行修改。</p>
<ul>
<li>信号的 “未决（<code>pending</code>）” 是一种状态，指的是从信号的产生到信号被处理前的这一段时间。</li>
<li>信号的 “阻塞（<code>mask</code>）” 是一个开关动作，指的是阻止信号被处理，但不是阻止信号产生。</li>
</ul>
<p>阻塞信号集和未决信号集在内核中的结构是相同的，它们都是一个整形数组 (被封装过的)，一共 <code>128</code> 字节 （<code>int [32] == 1024 bit</code>），1024 个标志位，其中前 31 个标志位，每一个都对应一个 Linux 中的标准信号，通过标志位的值来标记当前信号在信号集中的状态。</p>
<h4 id="7-13-2-原理介绍"><a href="#7-13-2-原理介绍" class="headerlink" title="7.13.2 原理介绍"></a>7.13.2 原理介绍</h4><h5 id="①-信号处理相关的数据结构"><a href="#①-信号处理相关的数据结构" class="headerlink" title="① 信号处理相关的数据结构"></a>① 信号处理相关的数据结构</h5><p>在进程管理结构 <code>task_struct</code>（详见<code>8.1.2.①节</code>） 中有几个与信号处理相关的字段，如下：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> {</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">int</span> sigpending; <span class="comment">// </span></span><br><span class="line">    ...</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">signal_struct</span> *<span class="title">sig</span>;</span> <span class="comment">// 信号的处理方法</span></span><br><span class="line">    <span class="keyword">sigset_t</span> blocked; <span class="comment">// 阻塞信号集</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigpending</span> <span class="title">pending</span>;</span> <span class="comment">// 未决信号集</span></span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>sigpending</code>：表示进程是否有信号需要处理（1表示有，0表示没有）</li>
<li><code>blocked</code>：表示被屏蔽的信息，每个位代表一个被屏蔽的信号</li>
<li><code>sig</code>：表示信号相应的处理方法，其类型是 <code>struct signal_struct</code>，定义如下：</li>
</ul>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  _NSIG  64</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">signal_struct</span> {</span></span><br><span class="line">	<span class="keyword">atomic_t</span>		count;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">k_sigaction</span>	<span class="title">action</span>[_<span class="title">NSIG</span>];</span></span><br><span class="line">	<span class="keyword">spinlock_t</span>		siglock;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">__sighandler_t</span>)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sigaction详见7.11.2节</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> {</span></span><br><span class="line">	<span class="keyword">__sighandler_t</span> sa_handler;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> sa_flags;</span><br><span class="line">	<span class="keyword">void</span> (*sa_restorer)(<span class="keyword">void</span>);</span><br><span class="line">	<span class="keyword">sigset_t</span> sa_mask;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">k_sigaction</span> {</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>pending</code>：其类型为 <code>struct sigpending</code>，存储着进程接收到的信号<strong>队列</strong>，定义如下：</li>
</ul>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigqueue</span> {</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sigqueue</span> *<span class="title">next</span>;</span></span><br><span class="line">	<span class="keyword">siginfo_t</span> info;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigpending</span> {</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sigqueue</span> *<span class="title">head</span>, **<span class="title">tail</span>;</span></span><br><span class="line">	<span class="keyword">sigset_t</span> signal;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>当进程接收到一个信号时，就需要把接收到的信号添加 <code>pending</code> 这个队列中。</p>
<h5 id="②-发送信号"><a href="#②-发送信号" class="headerlink" title="② 发送信号"></a>② 发送信号</h5><p>暂略</p>
<h2 id="8-线程"><a href="#8-线程" class="headerlink" title="8 线程"></a>8 线程</h2><p>本节对应APUE第十一、十二章内容</p>
<h3 id="8-1-线程概念"><a href="#8-1-线程概念" class="headerlink" title="8.1 线程概念"></a>8.1 线程概念</h3><p>线程本质：一个正在运行的函数。</p>
<p>进程本质：加载到内存的程序。</p>
<p>进程是操作系统分配资源的单位，线程是调度的基本单位，线程之间共享进程资源。</p>
<p>典型的UNIX进程可以看成只有一个控制线程：一个进程在某一时刻只能做一件事情。有了多个控制线程以后，在程序设计时就可以把进程设计成在某一时刻能够做不止一件事，每个线程处理各自独立的任务。</p>
<p>每个线程都包含有表示执行环境所必需的信息，其中包括进程中标识线程的线程ID、一组寄存器值、栈、调度优先级和策略、信号屏蔽字、errno变量以及线程私有数据。</p>
<p>一个进程的所有信息对该进程的所有线程都是共享的，包括可执行程序的代码、程序的全局内存和堆内存、栈以及文件描述符。</p>
<h4 id="8-1-1-POSIX线程接口"><a href="#8-1-1-POSIX线程接口" class="headerlink" title="8.1.1 POSIX线程接口"></a>8.1.1 POSIX线程接口</h4><p>POSIX线程（英语：POSIX Threads，常被缩写为<code>Pthreads</code>）是POSIX的<strong>线程标准</strong>，定义了创建和操纵线程的一套API。</p>
<p>Pthreads定义了一套C语言的类型、函数与常量，它以<code>pthread.h</code>头文件和一个线程库实现。Pthreads API中大致共有100个函数调用，全都以<code>pthread_</code>开头，并可以分为四类：</p>
<ul>
<li>线程管理，例如创建线程，等待(join)线程，查询线程状态等。</li>
<li>互斥锁（Mutex）：创建、摧毁、锁定、解锁、设置属性等操作</li>
<li>条件变量（Condition Variable）：创建、摧毁、等待、通知、设置与查询属性等操作</li>
<li>使用了互斥锁的线程间的同步管理</li>
</ul>
<p>因此在编译时需要makefile的编译和链接选项：</p>
<figure class="highlight makefile"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">makefile</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CFLAGS+=-pthread <span class="comment"># 编译选项</span></span><br><span class="line">LDFLAGS+=-pthread <span class="comment"># 链接选项</span></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cc -pthread  -pthread  create.c   -o create</span><br></pre></td></tr></tbody></table></figure>
<h4 id="8-1-2-进程和线程"><a href="#8-1-2-进程和线程" class="headerlink" title="8.1.2 进程和线程"></a>8.1.2 进程和线程</h4><h5 id="①-进程控制块"><a href="#①-进程控制块" class="headerlink" title="① 进程控制块"></a>① 进程控制块</h5><p>进程控制块是用于保存一个进程信息的结构体，称之为PCB（<code>process control block</code>），相当于进程的身份证；<strong>PCB是进程存在的唯一标识</strong>。</p>
<p>在Linux中PCB的信息存放在<code>task_struct</code>结构体中。结构体的主要成员如下：</p>
<ul>
<li>进程状态</li>
</ul>
<p>进程执行时，它会根据具体情况改变状态。进程状态是调度和对换的依据。Linux中的进程主要有如下状态：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字段名</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>TASK_RUNNING</code></td>
<td>可运行</td>
</tr>
<tr>
<td><code>TASK_INTERRUPTIBLE</code></td>
<td>可中断的等待状态</td>
</tr>
<tr>
<td><code>TASK_UNINTERRUPTIBLE</code></td>
<td>不可中断的等待状态</td>
</tr>
<tr>
<td><code>TASK_ZOMBIE</code></td>
<td>僵死</td>
</tr>
<tr>
<td><code>TASK_STOPPED</code></td>
<td>暂停</td>
</tr>
<tr>
<td><code>TASK_SWAPPING</code></td>
<td>换入/换出</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>进程调度信息</li>
</ul>
<p>调度程序利用这部分信息决定系统中哪个进程最应该运行，并结合进程的状态信息保证系统运转的公平和高效。这一部分信息通常包括进程的类别（普通进程还是实时进程）、进程的优先级等等。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字段名</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>need_resched</td>
<td>调度标志</td>
</tr>
<tr>
<td>Nice</td>
<td>静态优先级</td>
</tr>
<tr>
<td>Counter</td>
<td>动态优先级</td>
</tr>
<tr>
<td>Policy</td>
<td>调度策略</td>
</tr>
<tr>
<td>rt_priority</td>
<td>实时优先级</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>标识符</li>
</ul>
<p>每个进程有进程标识符、用户标识符、组标识符。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>域名</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>Pid</td>
<td>进程标识符</td>
</tr>
<tr>
<td>Uid、gid</td>
<td>用户标识符、组标识符</td>
</tr>
<tr>
<td>Euid、egid</td>
<td>有效用户标识符、有效组标识符</td>
</tr>
<tr>
<td>Suid、sgid</td>
<td>备份用户标识符、备份组标识符</td>
</tr>
<tr>
<td>Fsuid、fsgid</td>
<td>文件系统用户标识符、文件系统组标识符</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>进程通信有关信息</li>
</ul>
<p>为了使进程能在同一项任务上协调工作，进程之间必须能进行通信即交流数据。</p>
<p>Linux支持多种不同形式的通信机制。它支持典型的Unix通信机制（IPC Mechanisms）：<strong>信号</strong>（Signals）、<strong>管道</strong>（Pipes），也支持System V通信机制：<strong>共享内存（Shared Memory）、信号量和消息队列（Message Queues）</strong></p>
<ul>
<li>进程链接信息</li>
</ul>
<p>程序创建的进程具有父/子关系。因为一个进程能创建几个子进程，而子进程之间有兄弟关系，在task_struct结构中有几个成员来表示这种关系。</p>
<ul>
<li>时间和定时器信息</li>
</ul>
<p>一个进程从创建到终止叫做该进程的生存期（lifetime）。进程在其生存期内使用CPU的时间，内核都要进行记录，以便进行统计、计费等有关操作。</p>
<p>进程耗费CPU的时间由两部分组成：一是在用户模式（或称为用户态）下耗费的时间，一是在系统模式（或称为系统态）下耗费的时间。每个时钟滴答，也就是每个时钟中断，内核都要更新当前进程耗费CPU的时间信息，例如将进程的时间片减一。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>域名</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>Start_time</td>
<td>进程创建时间</td>
</tr>
<tr>
<td>Per_cpu_utime</td>
<td>进程在某个CPU上运行时在用户态下耗费的时间</td>
</tr>
<tr>
<td>Per_cpu_stime</td>
<td>进程在某个CPU上运行时在系统态下耗费的时间</td>
</tr>
<tr>
<td>Counter</td>
<td><strong>进程剩余的时间片</strong></td>
</tr>
</tbody>
</table>
</div>
<p>进程中的定时器如下图所示：</p>
<p><a href="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221227214742773.png" data-fancybox="gallery" data-caption="image-20221227214742773" data-thumb="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221227214742773.png"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221227214742773.png" alt="image-20221227214742773"></a></p>
<p>其余略</p>
<h5 id="②-线程共享和私有内容"><a href="#②-线程共享和私有内容" class="headerlink" title="② 线程共享和私有内容"></a>② 线程共享和私有内容</h5><p>私有资源：所属线程的栈区、程序计数器、栈指针以及函数运行使用的寄存器是线程私有的。这些资源又称为线程上下文。</p>
<p>除此之外的所有资源均由线程共享。</p>
<h3 id="8-2-线程标识"><a href="#8-2-线程标识" class="headerlink" title="8.2 线程标识"></a>8.2 线程标识</h3><p>就像每个进程有一个进程ID一样，每个线程也有一个线程ID。进程ID在整个系统中是唯一的，但线程ID不同，线程ID只有在它所属的进程上下文中才有意义。</p>
<p>进程ID是用<code>pid_t</code>数据类型来表示的，是一个非负整数。线程ID是用<code>pthread_t</code> 数据类型来表示的，实现的时候可以用一个<strong>结构</strong>来代表pthread_t数据类型，所以可移植的操作系统实现不能把它作为整数处理。</p>
<p>因此需要一个函数来对两个线程ID进行比较：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 相等返回非零，不等返回0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_equal</span><span class="params">(<span class="keyword">pthread_t</span> t1, <span class="keyword">pthread_t</span> t2)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p>获取自身的线程id：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">pthread_t</span> <span class="title">pthread_self</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<h3 id="8-3-线程创建"><a href="#8-3-线程创建" class="headerlink" title="8.3 线程创建"></a>8.3 线程创建</h3><p>在
传统 
UNIX进程模型中，每个进程只有一个控制线程。从概念上讲，这与基于线程的模型中每个进程只包含一个线程是相同的。在POSIX线程（pthread）
的情况下，程序开始运行时，它也是以单进程中的单个控制线程启动的。在创建多个控制线程以前，程序的行为与传统的进程并没有什么区别。</p>
<p>新增的线程可以通过调用<code>pthread_create</code>函数创建。</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="comment">// 成功返回0，失败返回errno</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(<span class="keyword">pthread_t</span> *thread, <span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">void</span> *(*start_routine) (<span class="keyword">void</span> *), <span class="keyword">void</span> *arg)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>thread</code>：事先创建好的<code>pthread_t</code>类型的参数。成功时thread指向的内存单元被设置为新创建线程的线程ID。</li>
<li><code>attr</code>：用于定制各种不同的线程属性。APUE的12.3节讨论了线程属性。通常直接设为NULL。</li>
<li><code>start_routine</code>：新创建线程从此函数开始运行，无参数时<code>arg</code>设为NULL即可。形参是函数指针（该函数返回值和形参均为<code>void*</code>），因此需要传入函数地址。</li>
<li><code>arg</code>：start_rtn函数的参数。无参数时设为NULL即可。有参数时输入参数的地址。当多于一个参数时应当使用结构体传入。</li>
</ul>
<blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程执行的函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">func</span><span class="params">(<span class="keyword">void</span>* p)</span> </span>{</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Thread is working!"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Begin!"</span>);</span><br><span class="line"></span><br><span class="line">    err = pthread_create(&amp;tid, <span class="literal">NULL</span>, func, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(err) {</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"pthread_create():%s\n"</span>, strerror(err));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"End!"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>打印结果：</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng pthread]<span class="comment"># ./create </span></span><br><span class="line">Begin!</span><br><span class="line">End!</span><br></pre></td></tr></tbody></table></figure>
<p>分析：线程的调度取决于调度器策略。创建线程后，新的线程还没来得及被调度，main线程就执行了<code>exit(0)</code>使得进程退出，所以新的线程并没有被执行就退出了。</p>
<h3 id="8-4-线程终止"><a href="#8-4-线程终止" class="headerlink" title="8.4 线程终止"></a>8.4 线程终止</h3><h4 id="8-4-1-终止方式"><a href="#8-4-1-终止方式" class="headerlink" title="8.4.1 终止方式"></a>8.4.1 终止方式</h4><p>如果进程中的任意线程调用了 <code>exit</code>、<code>_Exit</code> 或者 <code>_exit</code>，那么<strong>整个进程</strong>就会终止。与此相类似，如果默认的动作是终止进程，那么，发送到线程的信号就会终止整个进程。</p>
<p>单个线程可以通过3种方式退出，因此可以在不终止整个进程的情况下，停止它的控制流：</p>
<ul>
<li>线程可以简单地从启动例程中返回，返回值是线程的退出码</li>
<li>线程可以被同一进程中的其他线程取消</li>
<li>线程调用<code>pthread_exit</code></li>
</ul>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_exit</span><span class="params">(<span class="keyword">void</span> *rval_ptr)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p>例如：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">func</span><span class="params">(<span class="keyword">void</span> *p)</span> </span>{</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Thread is working!"</span>);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// return NULL;</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
<p>函数<code>pthread_join</code>用来等待一个线程的结束。相当于进程控制中的<code>wait</code>。</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> thread, <span class="keyword">void</span> **retval)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>thread</code>：为被等待的线程标识符</li>
<li><code>retval</code>：为用户定义的指针，它可以用来存储被等待线程的返回值，即<code>pthread_exit</code>的参数。这是一个二级指针，因此传入的参数为一级指针的地址，如果不关心返回值则用NULL</li>
</ul>
<blockquote>
<p>代码示例1</p>
</blockquote>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">func</span><span class="params">(<span class="keyword">void</span> *p)</span> </span>{</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Thread is working!"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Begin!"</span>);</span><br><span class="line"></span><br><span class="line">    err = pthread_create(&amp;tid, <span class="literal">NULL</span>, func, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(err) {</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"pthread_create():%s\n"</span>, strerror(err));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// join</span></span><br><span class="line">    pthread_join(tid, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"End!"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>执行结果：</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng pthread]<span class="comment"># ./create </span></span><br><span class="line">Begin!</span><br><span class="line">Thread is working!</span><br><span class="line">End!</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>代码示例2</p>
</blockquote>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">thr_fn1</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"thread1 is working!\n"</span>);</span><br><span class="line">    pthread_exit((<span class="keyword">void</span> *)<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">thr_fn2</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"thread2 is working!\n"</span>);</span><br><span class="line">    pthread_exit((<span class="keyword">void</span> *)<span class="number">2</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"main thread is working!\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid1, tid2;</span><br><span class="line">    <span class="keyword">void</span> *tret;</span><br><span class="line"></span><br><span class="line">    err = pthread_create(&amp;tid1, <span class="literal">NULL</span>, thr_fn1, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(err) {</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"pthread_create():%s\n"</span>, strerror(err));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    err = pthread_create(&amp;tid2, <span class="literal">NULL</span>, thr_fn2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(err) {</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"pthread_create():%s\n"</span>, strerror(err));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    pthread_join(tid1, &amp;tret);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"thread1 exit code %ld\n"</span>, (<span class="keyword">long</span>)tret);</span><br><span class="line"></span><br><span class="line">    pthread_join(tid2, &amp;tret);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"thread2 exit code %ld\n"</span>, (<span class="keyword">long</span>)tret);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"main thread exit!\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>执行结果：</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng pthread]<span class="comment"># ./test</span></span><br><span class="line">main thread is working!</span><br><span class="line">thread1 is working!</span><br><span class="line">thread1 <span class="built_in">exit</span> code 1</span><br><span class="line">thread2 is working!</span><br><span class="line">thread2 <span class="built_in">exit</span> code 2</span><br><span class="line">main thread <span class="built_in">exit</span>!</span><br></pre></td></tr></tbody></table></figure>
<hr>
<p>补充：<code>void*</code></p>
<p><code>void*</code>是一个未指定跳跃力的指针。</p>
<ul>
<li><code>void*</code>可以指向任何类型的地址。</li>
</ul>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> f = <span class="number">5.5</span>;</span><br><span class="line"><span class="keyword">float</span>* pf = &amp;f; <span class="comment">// pf是指向float的指针</span></span><br><span class="line"><span class="keyword">void</span>* pv = pf; <span class="comment">// pv可以指向float类型的地址</span></span><br><span class="line"><span class="keyword">float</span>* pf2 = pv; <span class="comment">//编译错误，有类型的指针变量不能指向void*变量</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>void*</code>指针只有强制类型转换以后才可以解引用</li>
</ul>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">float</span> f = <span class="number">5.5</span>;</span><br><span class="line">    <span class="keyword">float</span>* pf = &amp;f;</span><br><span class="line">    <span class="keyword">void</span>* pv;</span><br><span class="line">    </span><br><span class="line">    pv = pf; <span class="comment">//这句是可以的</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;*pv&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">//编译错误，这样直接对pv取值是错误的</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;*(<span class="keyword">float</span>*)pv&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">//强制类型转换后可以取值</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>void*</code>指针变量和普通指针一样可以通过等于0或者NULL来初始化，表示一个空指针</li>
</ul>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>* pv = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">void</span>* pv2 = <span class="literal">NULL</span>; <span class="comment">// 指针保存的地址为空或0</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>当<code>void*</code>指针作为函数的输入和输出时，表示可以接受任意类型的输入指针和输出任意类型的指针</li>
</ul>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">test</span><span class="params">(<span class="keyword">void</span>* a)</span> </span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"test: %d\n"</span>, *(<span class="keyword">int</span> *)a);</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span>* pi = &amp;a;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, pi);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, test(pi));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"main: %d\n"</span>, *(<span class="keyword">int</span> *)test(pi));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>执行结果：</p>
<figure class="highlight plaintext"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">plaintext</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0x7ffcd39fa0d4</span><br><span class="line">test: 5</span><br><span class="line">0x7ffcd39fa0d4</span><br><span class="line">test: 5</span><br><span class="line">main: 5</span><br></pre></td></tr></tbody></table></figure>
<h4 id="8-4-2-栈的清理"><a href="#8-4-2-栈的清理" class="headerlink" title="8.4.2 栈的清理"></a>8.4.2 栈的清理</h4><p>线程可以安排它退出时需要调用的函数，这与进程在退出时可以用atexit函数安排退出是类似的。这样的函数称为<strong>线程清理处理程序</strong>（thread cleanup handler）。一个线程可以建立多个清理处理程序。处理程序记录在栈中，也就是说，它们的执行顺序与它们注册时相反。</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_cleanup_push</span><span class="params">(<span class="keyword">void</span> (*routine)(<span class="keyword">void</span> *), <span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_cleanup_pop</span><span class="params">(<span class="keyword">int</span> execute)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p>当线程执行以下动作时，清理函数<code>routine</code>是由<code>pthread_cleanup_push</code>函数调度的，调用时只有一个参数<code>arg</code>：</p>
<ul>
<li>调用pthread_exit时；</li>
<li>响应取消请求时；</li>
<li>用非零execute参数调用pthread_cleanup_pop 时。如果 execute 
参数设置为0，清理函数将不被调用。不管发生上述哪种情况，pthread_cleanup_pop都将删除上次 
pthread_cleanup_push调用建立的清理处理程序。</li>
</ul>
<p>注意：这些函数有一个限制，由于它们可以实现为宏，所以必须在与线程相同的作用域中以<strong>匹配对</strong>的形式使用。pthread_cleanup_push 的宏定义可以包含字符<code>{</code>，这种情况下，在 pthread cleanup_pop 的定义中要有对应的匹配字符<code>}</code>。</p>
<blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cleanup_func</span><span class="params">(<span class="keyword">void</span> *p)</span> </span>{</span><br><span class="line">    <span class="built_in">puts</span>(p);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">func</span><span class="params">(<span class="keyword">void</span> *p)</span> </span>{</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Thread is working!"</span>);</span><br><span class="line">    pthread_cleanup_push(cleanup_func, <span class="string">"cleanup:1"</span>);</span><br><span class="line">    pthread_cleanup_push(cleanup_func, <span class="string">"cleanup:2"</span>);</span><br><span class="line">    pthread_cleanup_push(cleanup_func, <span class="string">"cleanup:3"</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"push over!"</span>);</span><br><span class="line">    <span class="comment">// 成对出现</span></span><br><span class="line">    pthread_cleanup_pop(<span class="number">1</span>);</span><br><span class="line">    pthread_cleanup_pop(<span class="number">0</span>);</span><br><span class="line">    pthread_cleanup_pop(<span class="number">0</span>);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Begin!"</span>);</span><br><span class="line"></span><br><span class="line">    err = pthread_create(&amp;tid, <span class="literal">NULL</span>, func, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(err) {</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"pthread_create(): %s\n"</span>, strerror(err));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    pthread_join(tid, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"End!"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>执行结果：</p>
<figure class="highlight plaintext"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">plaintext</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Begin!</span><br><span class="line">Thread is working!</span><br><span class="line">push over!</span><br><span class="line">cleanup:3</span><br><span class="line">End!</span><br></pre></td></tr></tbody></table></figure>
<h4 id="8-4-3-线程的取消"><a href="#8-4-3-线程的取消" class="headerlink" title="8.4.3 线程的取消"></a>8.4.3 线程的取消</h4><p>多线程程序中，一个线程可以借助 <code>pthread_cancel()</code> 函数向另一个线程发送“终止执行”的信号，从而令目标线程结束执行。</p>
<p><code>pthread_cancel</code>调用并不等待线程终止，它只提出请求。线程在取消请求发出后会继续运行，直到到达某个取消点<code>(CancellationPoint)</code>。取消点是线程检查是否被取消并按照请求进行动作的一个位置。</p>
<p>与线程取消相关的函数有：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送终止信号给thread线程，如果成功则返回0，否则为非0值。发送成功并不意味着thread会终止。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cancel</span><span class="params">(<span class="keyword">pthread_t</span> thread)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置本线程取消动作的执行时机</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_setcanceltype</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">int</span> *oldtype)</span>  </span></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在不包含取消点，但是又需要取消点的地方创建一个取消点，以便在一个没有包含取消点的执行代码线程中响应取消请求</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_testcancel</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程执行的函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">thread_Fun</span><span class="params">(<span class="keyword">void</span> * arg)</span> </span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"新建线程开始执行\n"</span>);</span><br><span class="line">    sleep(<span class="number">10</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    <span class="keyword">pthread_t</span> myThread;</span><br><span class="line">    <span class="keyword">void</span> * mess;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    <span class="comment">//创建 myThread 线程</span></span><br><span class="line">    res = pthread_create(&amp;myThread, <span class="literal">NULL</span>, thread_Fun, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (res != <span class="number">0</span>) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"线程创建失败\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//向 myThread 线程发送 Cancel 信号</span></span><br><span class="line">    res = pthread_cancel(myThread);</span><br><span class="line">    <span class="keyword">if</span> (res != <span class="number">0</span>) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"终止 myThread 线程失败\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//获取已终止线程的返回值</span></span><br><span class="line">    res = pthread_join(myThread, &amp;mess);</span><br><span class="line">    <span class="keyword">if</span> (res != <span class="number">0</span>) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"等待线程失败\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//如果线程被强制终止，其返回值为 PTHREAD_CANCELED</span></span><br><span class="line">    <span class="keyword">if</span> (mess == PTHREAD_CANCELED) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"myThread 线程被强制终止\n"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"error\n"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="8-5-线程同步"><a href="#8-5-线程同步" class="headerlink" title="8.5 线程同步"></a>8.5 线程同步</h3><h4 id="8-5-1-概念和例子"><a href="#8-5-1-概念和例子" class="headerlink" title="8.5.1 概念和例子"></a>8.5.1 概念和例子</h4><blockquote>
<p>线程竞争的实例</p>
</blockquote>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEFT  30000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RIGHT 30000200</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THRNUM (RIGHT-LEFT+1) <span class="comment">// 线程个数</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">thr_prime</span><span class="params">(<span class="keyword">void</span> *p)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> i, j, mark;</span><br><span class="line">    i = *(<span class="keyword">int</span> *)p;</span><br><span class="line">    mark = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">2</span>; j &lt; i/<span class="number">2</span>; j++) {</span><br><span class="line">        <span class="keyword">if</span>(i % j == <span class="number">0</span>) {</span><br><span class="line">            mark = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(mark)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d is a primer.\n"</span>, i);</span><br><span class="line">	pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">	<span class="keyword">int</span> i, err;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid[THRNUM];</span><br><span class="line">    <span class="keyword">for</span>(i = LEFT; i &lt;= RIGHT; i++) {</span><br><span class="line">        err = pthread_create(tid+(i-LEFT), <span class="literal">NULL</span>, thr_prime, &amp;i);</span><br><span class="line">        <span class="keyword">if</span>(err) {</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"pthread_create(): %s\n"</span>, strerror(err));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = LEFT; i &lt;= RIGHT; i++)</span><br><span class="line">        pthread_join(tid[i-LEFT], <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>执行结果：发现每次都不一样，并且每次的结果都是相同的。</p>
<p>原因：线程发生了竞争。</p>
<p>创建线程时，main线程传递给函数<code>thr_prime</code>的参数<code>&amp;i</code>是同一个地址，但是地址保存的值不相同：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">err = pthread_create(tid+(i-LEFT), <span class="literal">NULL</span>, thr_prime, &amp;i);</span><br></pre></td></tr></tbody></table></figure>
<p>后面线程执行时，会对这个地址进行解引用：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = *(<span class="keyword">int</span> *)p;</span><br></pre></td></tr></tbody></table></figure>
<p>注意：main线程和创建的线程的调度是由调度算法决定，因此会出现，在线程解引用之前，main线程就将该地址上的i值进行了修改，所以后面线程得到的i值都是同一个值。</p>
<blockquote>
<p>解决竞争</p>
</blockquote>
<p>定义一个结构体，成员为要计算判断的数，然后每次动态分配内存，将地址作为线程函数的参数即可。</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEFT  30000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RIGHT 30000200</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THRNUM (RIGHT-LEFT+1)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thr_arg_st</span> {</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">thr_prime</span><span class="params">(<span class="keyword">void</span> *p)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> i, j, mark;</span><br><span class="line">    <span class="comment">// 先将void*强转为struct thr_arg_st *</span></span><br><span class="line">    i = ((struct thr_arg_st *)p) -&gt; n;</span><br><span class="line">    mark = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">2</span>; j &lt; i/<span class="number">2</span>; j++) {</span><br><span class="line">        <span class="keyword">if</span>(i % j == <span class="number">0</span>) {</span><br><span class="line">            mark = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(mark)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d is a primer.\n"</span>, i);</span><br><span class="line">    <span class="comment">// 将p作为返回值</span></span><br><span class="line">	pthread_exit(p);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">	<span class="keyword">int</span> i, err;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid[THRNUM];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">thr_arg_st</span> *<span class="title">p</span>;</span></span><br><span class="line">    <span class="keyword">void</span> * ret;</span><br><span class="line">    <span class="keyword">for</span>(i = LEFT; i &lt;= RIGHT; i++) {</span><br><span class="line">        <span class="comment">// 动态分配内存</span></span><br><span class="line">        p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*p));</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="literal">NULL</span>) {</span><br><span class="line">            perror(<span class="string">"malloc()"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        p -&gt; n = i; </span><br><span class="line">        err = pthread_create(tid+(i-LEFT), <span class="literal">NULL</span>, thr_prime, p);</span><br><span class="line">        <span class="keyword">if</span>(err) {</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"pthread_create(): %s\n"</span>, strerror(err));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = LEFT; i &lt;= RIGHT; i++) {</span><br><span class="line">        <span class="comment">// 用ret来接收（一级指针的地址）</span></span><br><span class="line">        pthread_join(tid[i-LEFT], &amp;ret);</span><br><span class="line">        <span class="comment">// 释放动态分配的内存</span></span><br><span class="line">        <span class="built_in">free</span>(ret);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
<p>当多个控制线程共享相同的内存时，需要确保每个线程看到一致的数据视图。如果每个线程使用的变量都是其他线程不会读取和修改的，那么就不存在一致性
问题。同样，如果变量是只读的，多个线程同时读取该变量也不会有一致性问题。但是，当一个线程可以修改的变量，其他线程也可以读取或者修改的时候，我们就
需要对这些线程进行同步，确保它们在访问变量的存储内容时不会访问到无效的值。</p>
<p>当一个线程修改变量时，其他线程在读取这个变量时可能会看到一个不一致的值。在变量修改时间多于一个存储器访问周期的处理器结构中，当存储器读与存
储器写这两个周期交叉时，这种不一致就会出现。当然，这种行为是与处理器体系结构相关的，但是可移植的程序并不能对使用何种处理器体系结构做出任何假设。</p>
<p>图11-7描述了两个线程读写相同变量的假设例子。在这个例子中，线程A读取变量然后给这个变量赋予一个新的数值，但写操作需要两个存储器周期。当线程B在这两个存储器写周期中间读取这个变量时，它就会得到不一致的值。</p>
<p><a href="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221230122215903.png" data-fancybox="gallery" data-caption="image-20221230122215903" data-thumb="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221230122215903.png"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221230122215903.png" alt="image-20221230122215903"></a></p>
<p>为了解决这个问题，线程不得不使用锁，同一时间只允许一个线程访问该变量。图11-8描述了这种同步。如果线程B希望读取变量，它首先要获取<strong>锁</strong>。同样，当线程A更新变量时，也需要获取同样的这把锁。这样，线程B在线程A释放锁以前就不能读取变量。</p>
<p><a href="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221230122240495.png" data-fancybox="gallery" data-caption="image-20221230122240495" data-thumb="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221230122240495.png"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221230122240495.png" alt="image-20221230122240495"></a></p>
<h4 id="8-5-2-互斥量"><a href="#8-5-2-互斥量" class="headerlink" title="8.5.2 互斥量"></a>8.5.2 互斥量</h4><p>可以使用 pthread 的互斥接口来保护数据，确保同一时间只有一个线程访问数据。互斥量（<code>mutex</code>）<strong>从本质上说是一把锁</strong>，在访问共享资源前对互斥量进行设置（加锁），在访问完成后释放（解锁）互斥量。</p>
<p>对互斥量进行加锁以后，任何其他试图再次对互斥量加锁的线程都会<strong>被阻塞</strong>直到当前线程释放该互斥锁。如果释放互斥
量时有一个以上的线程阻塞，那么所有该锁上的阻塞线程都会变成可运行状态，第一个变为运行的线程就可以对互斥量加锁，其他线程就会看到互斥量依然是锁着
的，只能回去再次等待它重新变为可用。在这种方式下，每次只有一个线程可以向前执行。</p>
<p>只有将所有线程都设计成遵守相同数据访问规则的，互斥机制才能正常工作。操作系统并不会为我们做数据访问的串行化。如果允许其中的某个线程在没有得到锁的情况下也可以访问共享资源，那么即使其他的线程在使用共享资源前都申请锁，也还是会出现数据不一致的问题。</p>
<p>互斥变量是用 <code>pthread_mutex_t</code> 数据类型表示的。在使用互斥变量以前，必须首先对它进行初始化，可以把它设置为常量<code>PTHREAD_MUTEX_INITIALIZER</code>（只适用于静态分配的互斥量），也可以通过调用<code>pthread_mutex_init</code>函数进行初始化。如果动态分配互斥量（例如，通过调用malloc函数），在释放内存前需要调用<code>pthread_mutex_destroy</code>。</p>
<p>相关函数：</p>
<ul>
<li>初始化和销毁：</li>
</ul>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="comment">// 销毁互斥量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_destroy</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex, <span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态分配互斥量</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>加锁和解锁</li>
</ul>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻塞加锁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="comment">// 非阻塞加锁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="comment">// 解锁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>代码示例——20个线程读写一个文件</p>
</blockquote>
<p>先向<code>/tmp/out</code>下入1，然后创建20个线程来读这个文件内容并加1，然后写入。期望内容为<code>21</code></p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FNAME <span class="meta-string">"/tmp/out"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THRNUM 20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LINESIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">thr_add</span><span class="params">(<span class="keyword">void</span> *p)</span> </span>{</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">char</span> linebuf[LINESIZE];</span><br><span class="line"></span><br><span class="line">    fp = fopen(FNAME, <span class="string">"r+"</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp == <span class="literal">NULL</span>) {</span><br><span class="line">        perror(<span class="string">"fopen()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    fgets(linebuf, LINESIZE, fp);</span><br><span class="line">    <span class="comment">// 读完后将文件指针指向文件起始处</span></span><br><span class="line">    fseek(fp, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 向文件写入内容</span></span><br><span class="line">    <span class="built_in">fprintf</span>(fp, <span class="string">"%d\n"</span>, atoi(linebuf) + <span class="number">1</span>);</span><br><span class="line">    fclose(fp);</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    <span class="keyword">pthread_t</span> tid[THRNUM];</span><br><span class="line">    <span class="keyword">int</span> i, err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; THRNUM; i++) {</span><br><span class="line">        err = pthread_create(tid + i, <span class="literal">NULL</span>, thr_add, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(err) {</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"pthread_create(): %s\n"</span>, strerror(err));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; THRNUM; i++)</span><br><span class="line">        pthread_join(tid[i], <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>执行结果：</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng posix]<span class="comment"># echo 1 &gt; /tmp/out</span></span><br><span class="line">[root@HongyiZeng posix]<span class="comment"># cat /tmp/out</span></span><br><span class="line">1</span><br><span class="line">[root@HongyiZeng posix]<span class="comment"># ./add</span></span><br><span class="line">[root@HongyiZeng posix]<span class="comment"># cat /tmp/out</span></span><br><span class="line">2</span><br></pre></td></tr></tbody></table></figure>
<p>分析：由于调度和竞争，线程读到文件内容1后，休眠1s，然后一起写入2，所以结果就为2；</p>
<blockquote>
<p>代码示例——互斥量的使用</p>
</blockquote>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FNAME <span class="meta-string">"/tmp/out"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THRNUM 20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LINESIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 互斥锁</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_mutex_t</span> mut = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">thr_add</span><span class="params">(<span class="keyword">void</span> *p)</span> </span>{</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">char</span> linebuf[LINESIZE];</span><br><span class="line"></span><br><span class="line">    fp = fopen(FNAME, <span class="string">"r+"</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp == <span class="literal">NULL</span>) {</span><br><span class="line">        perror(<span class="string">"fopen()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在进入临界区前加上互斥锁</span></span><br><span class="line">    pthread_mutex_lock(&amp;mut);</span><br><span class="line">    fgets(linebuf, LINESIZE, fp);</span><br><span class="line">    <span class="comment">// 读完后将文件指针指向文件起始处</span></span><br><span class="line">    fseek(fp, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 向文件写入内容</span></span><br><span class="line">    <span class="built_in">fprintf</span>(fp, <span class="string">"%d\n"</span>, atoi(linebuf) + <span class="number">1</span>);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="comment">// 退出临界区后解锁</span></span><br><span class="line">    pthread_mutex_unlock(&amp;mut);</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    <span class="keyword">pthread_t</span> tid[THRNUM];</span><br><span class="line">    <span class="keyword">int</span> i, err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; THRNUM; i++) {</span><br><span class="line">        err = pthread_create(tid + i, <span class="literal">NULL</span>, thr_add, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(err) {</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"pthread_create(): %s\n"</span>, strerror(err));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; THRNUM; i++)</span><br><span class="line">        pthread_join(tid[i], <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁互斥锁</span></span><br><span class="line">    pthread_mutex_destroy(&amp;mut);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>执行结果：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng posix]<span class="meta"># echo 1 &gt; /tmp/out</span></span><br><span class="line">[root@HongyiZeng posix]# ./add</span><br><span class="line">[root@HongyiZeng posix]<span class="meta"># cat /tmp/out</span></span><br><span class="line"><span class="number">21</span></span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>代码示例3——使用互斥锁实现线程同步</p>
</blockquote>
<p>需求：四个线程依次打印<code>abcd</code></p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THRNUM 4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_mutex_t</span> mut[THRNUM];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回下一个线程的编号0~3，3的下一个为0</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> (n + <span class="number">1</span>) == THRNUM ? <span class="number">0</span> : n + <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">thr_func</span><span class="params">(<span class="keyword">void</span> *p)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> n = (<span class="keyword">int</span>)p; <span class="comment">// 线程编号</span></span><br><span class="line">    <span class="keyword">int</span> c = <span class="string">'a'</span> + (<span class="keyword">int</span>)p; <span class="comment">// 线程打印的字符</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">        <span class="comment">// 加锁</span></span><br><span class="line">        pthread_mutex_lock(mut + n);</span><br><span class="line">        <span class="comment">// 向终端打印字符</span></span><br><span class="line">        write(<span class="number">1</span>, &amp;c, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 释放下一个线程的锁</span></span><br><span class="line">        pthread_mutex_unlock(mut + next(n));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> i, err;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid[THRNUM];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; THRNUM; i++) {</span><br><span class="line">        <span class="comment">// 初始化锁</span></span><br><span class="line">        pthread_mutex_init(mut + i, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// 加锁</span></span><br><span class="line">        pthread_mutex_lock(mut + i);</span><br><span class="line">        err = pthread_create(tid + i, <span class="literal">NULL</span>, thr_func, (<span class="keyword">void</span> *)i);</span><br><span class="line">        <span class="keyword">if</span>(err) {</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"pthread_create(): %s\n"</span>, strerror(err));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 释放打印a的线程的锁</span></span><br><span class="line">    pthread_mutex_unlock(mut + <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 运行3s终止进程</span></span><br><span class="line">    alarm(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; THRNUM; i++)</span><br><span class="line">        pthread_join(tid[i], <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="8-5-3-线程池"><a href="#8-5-3-线程池" class="headerlink" title="8.5.3 线程池"></a>8.5.3 线程池</h4><p>线程数是有一定限制的，<code>8.5.1节</code>用201个线程来检测质数，本节利用线程池来解决。</p>
<p>假设线程池提供4个线程来检测201个质数。设置临界区资源<code>num</code>，当：</p>
<ul>
<li><code>num = 0</code>：当前没有任务</li>
<li><code>num = -1</code>：当前任务已经全部完成</li>
<li><code>num = 300000~3000200</code>：当前有一个任务，需要一个线程来接受任务</li>
</ul>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEFT  30000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RIGHT 30000200</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THRNUM 4 <span class="comment">// 假设线程池中有4个线程</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 临界区资源</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 互斥锁</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_mutex_t</span> mut_num = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">thr_prime</span><span class="params">(<span class="keyword">void</span> *p)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> i, j, mark;</span><br><span class="line">    <span class="comment">// 死循环：领取任务</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">        pthread_mutex_lock(&amp;mut_num);</span><br><span class="line">        <span class="comment">// 循环检测是否有任务</span></span><br><span class="line">        <span class="keyword">while</span>(num == <span class="number">0</span>) { <span class="comment">// 当前没有任务</span></span><br><span class="line">            pthread_mutex_unlock(&amp;mut_num);</span><br><span class="line">            sched_yield();</span><br><span class="line">            pthread_mutex_lock(&amp;mut_num);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 拿到任务，判断是否为-1，即任务已经结束</span></span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">-1</span>) {</span><br><span class="line">            <span class="comment">// 要释放锁，防止其他线程死锁</span></span><br><span class="line">            pthread_mutex_unlock(&amp;mut_num);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 拿到任务</span></span><br><span class="line">        i = num;</span><br><span class="line">        <span class="comment">// 将num设置为0，即没有任务</span></span><br><span class="line">        num = <span class="number">0</span>;</span><br><span class="line">        pthread_mutex_unlock(&amp;mut_num);</span><br><span class="line">        <span class="comment">//---------线程做任务：检测是否为质数-------</span></span><br><span class="line">        mark = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">2</span>; j &lt; i/<span class="number">2</span>; j++) {</span><br><span class="line">            <span class="keyword">if</span>(i % j == <span class="number">0</span>) {</span><br><span class="line">                mark = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(mark)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"[thread-%d]%d is a primer.\n"</span>, (<span class="keyword">int</span>)p, i);</span><br><span class="line">    }</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">	<span class="keyword">int</span> i, err;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid[THRNUM];</span><br><span class="line">    <span class="comment">// 启动线程池</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; THRNUM; i++) {</span><br><span class="line">        err = pthread_create(tid+i, <span class="literal">NULL</span>, thr_prime, (<span class="keyword">void</span> *)i);</span><br><span class="line">        <span class="keyword">if</span>(err) {</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"pthread_create(): %s\n"</span>, strerror(err));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 主线程下发任务</span></span><br><span class="line">    <span class="keyword">for</span>(i = LEFT; i &lt;= RIGHT; i++) {</span><br><span class="line">        pthread_mutex_lock(&amp;mut_num);</span><br><span class="line">        <span class="comment">// 循环检测任务是否被线程领走</span></span><br><span class="line">        <span class="keyword">while</span>(num != <span class="number">0</span>) { <span class="comment">// 没有领走任务</span></span><br><span class="line">            pthread_mutex_unlock(&amp;mut_num);</span><br><span class="line">            <span class="comment">// 让出CPU</span></span><br><span class="line">            sched_yield();</span><br><span class="line">            pthread_mutex_lock(&amp;mut_num);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 设置num，即下发任务</span></span><br><span class="line">        num = i;</span><br><span class="line">        pthread_mutex_unlock(&amp;mut_num);</span><br><span class="line">    } <span class="comment">// 下发任务完毕</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置num为-1，代表任务全部结束</span></span><br><span class="line">    pthread_mutex_lock(&amp;mut_num);</span><br><span class="line">    <span class="comment">// 循环检测最后一个任务是否被完成</span></span><br><span class="line">    <span class="keyword">while</span>(num != <span class="number">0</span>) { <span class="comment">// 没有完成</span></span><br><span class="line">        pthread_mutex_unlock(&amp;mut_num);</span><br><span class="line">        sched_yield();</span><br><span class="line">        pthread_mutex_lock(&amp;mut_num);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 已完成，则设置为-1</span></span><br><span class="line">    num = <span class="number">-1</span>;</span><br><span class="line">    pthread_mutex_unlock(&amp;mut_num);</span><br><span class="line">	<span class="comment">// 收尸</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; THRNUM; i++) {</span><br><span class="line">        pthread_join(tid[i], <span class="literal">NULL</span>);</span><br><span class="line">    }</span><br><span class="line">	<span class="comment">// 销毁互斥锁</span></span><br><span class="line">    pthread_mutex_destroy(&amp;mut_num);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>打印结果：</p>
<figure class="highlight plaintext"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">plaintext</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[thread-0]30000001 is a primer.</span><br><span class="line">[thread-2]30000041 is a primer.</span><br><span class="line">[thread-3]30000023 is a primer.</span><br><span class="line">[thread-1]30000037 is a primer.</span><br><span class="line">[thread-1]30000079 is a primer.</span><br><span class="line">[thread-0]30000059 is a primer.</span><br><span class="line">[thread-3]30000071 is a primer.</span><br><span class="line">[thread-2]30000049 is a primer.</span><br><span class="line">[thread-0]30000083 is a primer.</span><br><span class="line">[thread-1]30000109 is a primer.</span><br><span class="line">[thread-3]30000137 is a primer.</span><br><span class="line">[thread-2]30000133 is a primer.</span><br><span class="line">[thread-3]30000163 is a primer.</span><br><span class="line">[thread-1]30000149 is a primer.</span><br><span class="line">[thread-0]30000167 is a primer.</span><br><span class="line">[thread-2]30000169 is a primer.</span><br><span class="line">[thread-0]30000199 is a primer.</span><br><span class="line">[thread-3]30000193 is a primer.</span><br></pre></td></tr></tbody></table></figure>
<p>不足：该程序存在盲等，即查询法的不足，上游main线程一直在循环查看任务是否被领走，而下游一直在循环查看是否有任务。</p>
<p>通知法：上游将设置任务后，唤醒下游来处理任务。如果没有领走任务，则阻塞自己，等待下游来唤醒。</p>
<p>下游发现有任务，则领走任务，并唤醒上游；没有任务，则阻塞，等待上游来唤醒。</p>
<h4 id="8-5-4-线程令牌桶"><a href="#8-5-4-线程令牌桶" class="headerlink" title="8.5.4 线程令牌桶"></a>8.5.4 线程令牌桶</h4><p>暂略</p>
<h4 id="8-5-5-条件变量"><a href="#8-5-5-条件变量" class="headerlink" title="8.5.5 条件变量"></a>8.5.5 条件变量</h4><p>条件变量是线程可用的另一种同步机制。条件变量给多个线程提供了一个会合的场所。条件变量与互斥量一起使用时，允许线程以无竞争的方式等待特定的条件发生。</p>
<p>条件本身是由互斥量保护的。线程在改变条件状态之前必须首先锁住互斥量。其他线程在获得互斥量之前不会察觉到这种改变，因为互斥量必须在锁定以后才能计算条件。</p>
<p>在使用条件变量之前，必须先对它进行初始化。由<code>pthread_cond_t</code>数据类型表示的条件变量可以用两种方式进行初始化。可以把常量<code>PTHREAD_COND_INITTALIZER</code>赋给静态分配的条件变量但是如果条件变量是动态分配的，则需要使用<code>pthread_cond_init</code>函数对它进行初始化。在释放条件变量底层的内存空间之前，可以使用<code>pthread_cond_destroy</code>函数对条件变量进行反初始化。</p>
<p>相关函数和作用：</p>
<blockquote>
<p>初始化条件变量</p>
</blockquote>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="comment">// 销毁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_destroy</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态初始化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_init</span><span class="params">(<span class="keyword">pthread_cond_t</span> *<span class="keyword">restrict</span> cond, <span class="keyword">const</span> <span class="keyword">pthread_condattr_t</span> *<span class="keyword">restrict</span> attr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态初始化</span></span><br><span class="line"><span class="keyword">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>阻塞当前线程，等待条件成立</p>
</blockquote>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有时间的条件等待</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_timedwait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,</span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex,</span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="keyword">const</span> struct timespec *<span class="keyword">restrict</span> abstime)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 条件等待</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_wait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>cond</code>：已初始化好的条件变量</li>
<li><code>mutex</code>：与条件变量配合使用的互斥锁</li>
<li><code>abstime</code>：阻塞线程的时间</li>
</ul>
<p>调用两个函数之前，我们必须先创建好一个互斥锁并完成加锁操作，然后才能作为实参传递给 <code>mutex</code> 参数。两个函数会完成以下两项工作：</p>
<ul>
<li>阻塞线程，直至接收到条件成立的信号</li>
<li>当线程被添加到等待队列上时，将互斥锁解锁，即释放mutex</li>
</ul>
<p>也就是说，函数尚未接收到“条件成立”的信号之前，它将一直阻塞线程执行。注意，当函数接收到“条件成立”的信号后，它并不会立即结束对线程的阻塞，而是先完成对互斥锁的“加锁”操作，然后才解除阻塞。</p>
<p>两个函数都以“原子操作”的方式完成“阻塞线程+解锁”或者“重新加锁+解除阻塞”这两个过程。</p>
<blockquote>
<p>解除线程的“阻塞”状态</p>
</blockquote>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="comment">// 唤醒所有的阻塞线程</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_broadcast</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 唤醒所有正在的至少一个线程</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_signal</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p>对于被上面两个函数阻塞的线程，我们可以借助如上两个函数向它们发送“条件成立”的信号，解除它们的“阻塞”状态。</p>
<p>由于互斥锁的存在，解除阻塞后的线程也不一定能立即执行。当互斥锁处于“加锁”状态时，解除阻塞状态的所有线程会组成等待互斥锁资源的队列，等待互斥锁“解锁”。</p>
<blockquote>
<p>代码示例1——查询法转通知法</p>
</blockquote>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEFT  30000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RIGHT 30000200</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THRNUM 4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_mutex_t</span> mut_num = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_cond_t</span> cond_num = PTHREAD_COND_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">thr_prime</span><span class="params">(<span class="keyword">void</span> *p)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> i, j, mark;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">        pthread_mutex_lock(&amp;mut_num);</span><br><span class="line">        <span class="comment">// 查看是否有任务</span></span><br><span class="line">        <span class="keyword">while</span>(num == <span class="number">0</span>) { <span class="comment">// 没有任务</span></span><br><span class="line">            <span class="comment">// 则阻塞自己，释放互斥锁</span></span><br><span class="line">            pthread_cond_wait(&amp;cond_num, &amp;mut_num);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">-1</span>) {</span><br><span class="line">            pthread_mutex_unlock(&amp;mut_num);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 领走任务</span></span><br><span class="line">        i = num;</span><br><span class="line">        num = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 唤醒所有阻塞线程</span></span><br><span class="line">        pthread_cond_broadcast(&amp;cond_num);</span><br><span class="line">        pthread_mutex_unlock(&amp;mut_num);</span><br><span class="line">        mark = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">2</span>; j &lt; i/<span class="number">2</span>; j++) {</span><br><span class="line">            <span class="keyword">if</span>(i % j == <span class="number">0</span>) {</span><br><span class="line">                mark = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(mark)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"[thread-%d]%d is a primer.\n"</span>, (<span class="keyword">int</span>)p, i);</span><br><span class="line">    }</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">	<span class="keyword">int</span> i, err;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid[THRNUM];</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; THRNUM; i++) {</span><br><span class="line">        err = pthread_create(tid+i, <span class="literal">NULL</span>, thr_prime, (<span class="keyword">void</span> *)i);</span><br><span class="line">        <span class="keyword">if</span>(err) {</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"pthread_create(): %s\n"</span>, strerror(err));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = LEFT; i &lt;= RIGHT; i++) {</span><br><span class="line">        pthread_mutex_lock(&amp;mut_num);</span><br><span class="line">        <span class="comment">// 查看任务是否领走</span></span><br><span class="line">        <span class="keyword">while</span>(num != <span class="number">0</span>) { <span class="comment">// 任务没有领走</span></span><br><span class="line">            <span class="comment">// 阻塞自己，并释放互斥锁</span></span><br><span class="line">            pthread_cond_wait(&amp;cond_num, &amp;mut_num);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 已经被领走，则设置任务</span></span><br><span class="line">        num = i; <span class="comment">// 设置任务</span></span><br><span class="line">        <span class="comment">// 唤醒任何一个阻塞的线程</span></span><br><span class="line">        pthread_cond_signal(&amp;cond_num);</span><br><span class="line">        pthread_mutex_unlock(&amp;mut_num);</span><br><span class="line">    }</span><br><span class="line">    pthread_mutex_lock(&amp;mut_num);</span><br><span class="line">    <span class="keyword">while</span>(num != <span class="number">0</span>) {</span><br><span class="line">        pthread_mutex_unlock(&amp;mut_num);</span><br><span class="line">        sched_yield();</span><br><span class="line">        pthread_mutex_lock(&amp;mut_num);</span><br><span class="line">    }</span><br><span class="line">    num = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 唤醒所有线程</span></span><br><span class="line">    pthread_cond_broadcast(&amp;cond_num);</span><br><span class="line">    pthread_mutex_unlock(&amp;mut_num);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; THRNUM; i++) {</span><br><span class="line">        pthread_join(tid[i], <span class="literal">NULL</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    pthread_mutex_destroy(&amp;mut_num);</span><br><span class="line">    pthread_cond_destroy(&amp;cond_num);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>代码示例2——打印abcd</p>
</blockquote>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THRNUM 4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_mutex_t</span> mut = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> (n + <span class="number">1</span>) == THRNUM ? <span class="number">0</span> : n + <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">thr_func</span><span class="params">(<span class="keyword">void</span> *p)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> n = (<span class="keyword">int</span>)p;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="string">'a'</span> + (<span class="keyword">int</span>)p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">        pthread_mutex_lock(&amp;mut);</span><br><span class="line">        <span class="comment">// 向终端打印字符</span></span><br><span class="line">        <span class="keyword">while</span>(num != n) {</span><br><span class="line">            <span class="comment">// 如果num不是自己的编号，则阻塞并释放锁</span></span><br><span class="line">            pthread_cond_wait(&amp;cond, &amp;mut);</span><br><span class="line">        }</span><br><span class="line">        write(<span class="number">1</span>, &amp;c, <span class="number">1</span>);</span><br><span class="line">        num = next(num); <span class="comment">// 将num修改为下一个线程的编号</span></span><br><span class="line">        <span class="comment">// 广播唤醒所有阻塞的线程</span></span><br><span class="line">        pthread_cond_broadcast(&amp;cond);</span><br><span class="line">        pthread_mutex_unlock(&amp;mut);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> i, err;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid[THRNUM];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; THRNUM; i++) {</span><br><span class="line">        err = pthread_create(tid + i, <span class="literal">NULL</span>, thr_func, (<span class="keyword">void</span> *)i);</span><br><span class="line">        <span class="keyword">if</span>(err) {</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"pthread_create(): %s\n"</span>, strerror(err));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    alarm(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; THRNUM; i++)</span><br><span class="line">        pthread_join(tid[i], <span class="literal">NULL</span>);</span><br><span class="line">    pthread_mutex_destroy(&amp;mut);</span><br><span class="line">    pthread_cond_destroy(&amp;cond);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="8-5-6-信号量"><a href="#8-5-6-信号量" class="headerlink" title="8.5.6 信号量"></a>8.5.6 信号量</h4><p>使用互斥量和条件变量可以实现信号量的功能。</p>
<p>需求：产生4个线程（4个资源）来筛选质数，任务完成后线程退出，然后又产生线程。这里的共享资源就是4个线程。</p>
<ul>
<li><code>mysem.h</code></li>
</ul>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __MYSEM_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __MYSEM_H__</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为void取别名为mysem_t</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> <span class="keyword">mysem_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">mysem_t</span> *<span class="title">mysem_init</span><span class="params">(<span class="keyword">int</span> initval)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mysem_add</span><span class="params">(<span class="keyword">mysem_t</span> *, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mysem_sub</span><span class="params">(<span class="keyword">mysem_t</span> *, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mysem_destroy</span><span class="params">(<span class="keyword">mysem_t</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>mysem.c</code></li>
</ul>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mysem.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号量的结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mysem_st</span> {</span></span><br><span class="line">    <span class="keyword">int</span> value; <span class="comment">// 现有资源数（相当于信号量）</span></span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> mut; <span class="comment">// 互斥量</span></span><br><span class="line">    <span class="keyword">pthread_cond_t</span> cond; <span class="comment">// 条件变量</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号量初始化，initval为资源总数</span></span><br><span class="line"><span class="function"><span class="keyword">mysem_t</span> *<span class="title">mysem_init</span><span class="params">(<span class="keyword">int</span> initval)</span> </span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mysem_st</span> *<span class="title">me</span>;</span></span><br><span class="line">    me = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*me));</span><br><span class="line">    <span class="keyword">if</span>(me == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line">    me-&gt;value = initval;</span><br><span class="line">    pthread_mutex_init(&amp;me-&gt;mut, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_cond_init(&amp;me-&gt;cond, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> me;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加信号量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mysem_add</span><span class="params">(<span class="keyword">mysem_t</span> *ptr, <span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">    <span class="comment">// 将void*的指针指向mysem_st*</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mysem_st</span> *<span class="title">me</span> =</span> ptr; </span><br><span class="line">    pthread_mutex_lock(&amp;me-&gt;mut);</span><br><span class="line">    me-&gt;value += n;</span><br><span class="line">    <span class="comment">// 广播唤醒所有等待线程</span></span><br><span class="line">    pthread_cond_broadcast(&amp;me-&gt;cond);</span><br><span class="line">    pthread_mutex_unlock(&amp;me-&gt;mut);</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 减少信号量，索要n个资源</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mysem_sub</span><span class="params">(<span class="keyword">mysem_t</span> *ptr, <span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mysem_st</span> *<span class="title">me</span> =</span> ptr;</span><br><span class="line">    pthread_mutex_lock(&amp;me-&gt;mut);</span><br><span class="line">    <span class="keyword">while</span>(me-&gt;value &lt; n) { <span class="comment">// 当资源总数少于需要的n</span></span><br><span class="line">        <span class="comment">// 条件等待</span></span><br><span class="line">        pthread_cond_wait(&amp;me-&gt;cond, &amp;me-&gt;mut);</span><br><span class="line">    }</span><br><span class="line">    me-&gt;value -= n;</span><br><span class="line">    pthread_mutex_unlock(&amp;me-&gt;mut);</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁信号量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mysem_destroy</span><span class="params">(<span class="keyword">mysem_t</span> *ptr)</span> </span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mysem_st</span> *<span class="title">me</span> =</span> ptr;</span><br><span class="line">    pthread_mutex_destroy(&amp;me-&gt;mut);</span><br><span class="line">    pthread_cond_destroy(&amp;me-&gt;cond);</span><br><span class="line">    <span class="built_in">free</span>(me);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>main.c</code></li>
</ul>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mysem.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEFT  30000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RIGHT 30000200</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THRNUM (RIGHT-LEFT+1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 4 <span class="comment">// 资源总量（可创建的线程总数）</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">mysem_t</span> *sem;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">thr_prime</span><span class="params">(<span class="keyword">void</span> *p)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> i, j, mark;</span><br><span class="line">    i = (<span class="keyword">int</span>)p;</span><br><span class="line">    mark = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">2</span>; j &lt; i/<span class="number">2</span>; j++) {</span><br><span class="line">        <span class="keyword">if</span>(i % j == <span class="number">0</span>) {</span><br><span class="line">            mark = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(mark)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d is a primer.\n"</span>, i);</span><br><span class="line">   	<span class="comment">// 假设任务需要5s完成</span></span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">// 增加信号量</span></span><br><span class="line">    mysem_add(sem, <span class="number">1</span>);</span><br><span class="line">	pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">	<span class="keyword">int</span> i, err;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid[THRNUM];</span><br><span class="line">    </span><br><span class="line">    sem = mysem_init(N);</span><br><span class="line">    <span class="keyword">if</span>(sem == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"mysem_init() failed!\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span>(i = LEFT; i &lt;= RIGHT; i++) {</span><br><span class="line">        <span class="comment">// 减少信号量</span></span><br><span class="line">        mysem_sub(sem, <span class="number">1</span>);</span><br><span class="line">        err = pthread_create(tid+(i-LEFT), <span class="literal">NULL</span>, thr_prime, (<span class="keyword">void</span> *)i);</span><br><span class="line">        <span class="keyword">if</span>(err) {</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"pthread_create(): %s\n"</span>, strerror(err));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = LEFT; i &lt;= RIGHT; i++) {</span><br><span class="line">        pthread_join(tid[i-LEFT], <span class="literal">NULL</span>);</span><br><span class="line">    }</span><br><span class="line">    mysem_destroy(sem);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>makefile</code></li>
</ul>
<figure class="highlight makefile"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">makefile</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CFLAGS+=-pthread</span><br><span class="line">LDFLAGS+=-pthread</span><br><span class="line"></span><br><span class="line"><span class="section">all: mysem</span></span><br><span class="line"></span><br><span class="line"><span class="section">mysem:main.o mysem.o</span></span><br><span class="line">	gcc <span class="variable">$^</span> -o <span class="variable">$@</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$(LDFLAGS)</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -rf *.o mysem</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>执行结果</p>
</blockquote>
<p>使用命令，查看线程关系：</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps ax -L</span><br></pre></td></tr></tbody></table></figure>
<p>由下图所示，主线程<code>main[3134]</code>创建了4个线程来筛选质数：</p>
<p><a href="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221231093757431.png" data-fancybox="gallery" data-caption="image-20221231093757431" data-thumb="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221231093757431.png"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221231093757431.png" alt="image-20221231093757431"></a></p>
<p>当某个线程完成任务后，增加信号量，并唤醒阻塞线程，下图表示原来的4个线程已经完成任务退出，主线程又创建了4个新的线程来筛选质数：</p>
<p><a href="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221231093816207.png" data-fancybox="gallery" data-caption="image-20221231093816207" data-thumb="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221231093816207.png"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221231093816207.png" alt="image-20221231093816207"></a></p>
<p>同理，图表示原来的4个线程已经完成任务退出，主线程又创建了4个新的线程来筛选质数：</p>
<p><a href="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221231093834252.png" data-fancybox="gallery" data-caption="image-20221231093834252" data-thumb="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221231093834252.png"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221231093834252.png" alt="image-20221231093834252"></a></p>
<h3 id="8-6-线程属性"><a href="#8-6-线程属性" class="headerlink" title="8.6 线程属性"></a>8.6 线程属性</h3><p>pthread 接口允许我们通过设置每个对象关联的不同属性来细调线程和同步对象的行为。通常，管理这些属性的函数都遵循相同的模式。</p>
<p>在所有调用<code>pthread_create</code>函数的实例中，传入的参数都是空指针，而不是指向<code>pthread_attr_t</code>结构的指针。可以使用<code>pthread_attr_t</code>结构修改线程默认属性，并把这些属性与创建的线程联系起来。</p>
<p>可以使用<code>pthread_attr_init</code>函数初始化 <code>pthread_attr_t</code> 结构。在调用 <code>pthread attr_init</code> 以后，<code>pthread_attr_t</code> 结构所包含的就是操作系统实现支持的所有线程属性的<strong>默认值</strong>。</p>
<blockquote>
<p>初始化和销毁</p>
</blockquote>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_init</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_destroy</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p>下图总结了 POSIX.1 定义的线程属性。POSIX.1 还为线程执行调度（Thread Execution Scheduling）选项定义了额外的属性，用以支持实时应用。下图同时给出了各个操作系统平台对每个线程属性的支持情况。</p>
<p><a href="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20221231175621629.png" data-fancybox="gallery" data-caption="image-20221231175621629" data-thumb="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20221231175621629.png"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20221231175621629.png" alt="image-20221231175621629"></a></p>
<hr>
<blockquote>
<p>线程分离状态属性</p>
</blockquote>
<p>线程分离：在我们使用默认属性创建一个线程的时候，线程是 joinable 的。 joinable 状态的线程，必须在另一个线程中使用 
pthread_join() 等待其结束， 如果一个 joinable 的线程在结束后，没有使用 pthread_join() 进行操作， 
这个线程就会变成”僵尸线程”。可以使用<code>pthread_detach</code>函数让线程分离。</p>
<p>当线程被设置为分离状态后，线程结束时，它的资源会被操作系统自动的回收， 而不再需要在其它线程中对其进行 pthread_join() 操作。</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="comment">// 设置状态</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_setdetachstate</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">int</span> detachstate)</span></span>;</span><br><span class="line"><span class="comment">// 获取状态</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_getdetachstate</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">int</span> *detachstate)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>detachstate</code>：可以设置为以下属性<ul>
<li><code>PTHREAD_CREATE_DETACHED</code>：线程分离状态</li>
<li><code>PTHREAD_CREATE_JONINABLE</code>：线程可joinable状态</li>
</ul>
</li>
</ul>
<p>代码示例：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">fn</span><span class="params">(<span class="keyword">void</span> *p)</span> </span>{</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    pthread_attr_init(&amp;attr);</span><br><span class="line">    <span class="comment">// 设置创建的线程为分离状态</span></span><br><span class="line">    pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);</span><br><span class="line">    <span class="comment">// 创建线程</span></span><br><span class="line">    err = pthread_create(&amp;tid, &amp;attr, fn, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(err) {</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 销毁</span></span><br><span class="line">    pthread_attr_destroy(&amp;attr);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>线程的栈和栈大小</p>
</blockquote>
<p>可以使用下列函数设置线程的栈属性。</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_setstack</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">void</span> *stackaddr, <span class="keyword">size_t</span> stacksize)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_getstack</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">void</span> **stackaddr, <span class="keyword">size_t</span> *stacksize)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p>对于进程来说，虚地址空间的大小是固定的。因为进程中只有一个栈，所以它的大小通常不是问题。但对于线程来说，同样大小的虚地址空间必须被所有的线
程栈共享。如果应用程序使用了许多线程，以致这些线程栈的累计大小超过了可用的虚地址空间，就需要减少默认的线程栈大小。另一方面，如果线程调用的函数分
配了大量的自动变量，或者调用的函数涉及许多很深的栈帧（stack frame），那么需要的栈大小可能要比默认的大。</p>
<p>如果线程栈的虚地址空间都用完了，那可以使用malloc或者mmap来为可替代的栈分配空间，并用<code>pthread_attr_setstack</code>函数来改变新建线程的栈位置。由<code>stackaddr</code> 参数指定的地址可以用作线程视的内容范围中的最低可寻找地址，该地址与处理器结构相应的边界应对齐。当然，这要假设malloc和mmap所用的虚地址范围与线程栈当前使用的虚地址范围不同。</p>
<p><code>stackaddr</code>线程属性被定义为栈的最低内存地址，但这并不一定是栈的开始位置。对于一个给定的处理器结构来说，如果栈是从高地址向低地址方向增长的，那么 <code>stackaddr</code>线程属性将是栈的结尾位置，而不是开始位置。</p>
<p>应用程序也可以通过下列函数读取或设置线程属性<code>stacksize</code>。</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_setstacksize</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">size_t</span> stacksize)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_getstacksize</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">size_t</span> *stacksize)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p>如果希望改变默认的栈大小，但又不想自己处理线程栈的分配问题，这时使用<code>pthread_attr_setstacksize</code>函数就非常有用。设置stacksize属性时，选择的stacksize不能小于<code>PTHREAD_STACK_MIN</code>。</p>
<p>代码示例——测试线程数量的上限：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">func</span><span class="params">(<span class="keyword">void</span> *p)</span> </span>{</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> i, err;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line">    pthread_attr_init(&amp;attr);</span><br><span class="line">    <span class="comment">// 定义线程的栈大小为10M</span></span><br><span class="line">    pthread_attr_setstacksize(&amp;attr, <span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i ; i++) {</span><br><span class="line">        err = pthread_create(&amp;tid, <span class="literal">NULL</span>, func, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(err) {</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"pthread_create(): %s\n"</span>, stderror(err));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i);</span><br><span class="line">    pthread_attr_destroy(&amp;attr);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="8-7-同步属性"><a href="#8-7-同步属性" class="headerlink" title="8.7 同步属性"></a>8.7 同步属性</h3><p>线程的同步对象也具有属性。</p>
<h4 id="8-7-1-互斥量属性"><a href="#8-7-1-互斥量属性" class="headerlink" title="8.7.1 互斥量属性"></a>8.7.1 互斥量属性</h4><p>互斥量属性是用 <code>pthread_mutexattr_t</code> 结构表示的。在<code>8.5.2节</code>每次对互斥量进行初始化时，都是通过使用<code>PTHREAD_MUTEX_INITTALIZER</code> 常量或者用指向互斥量属性结构的空指针作为参数调用 <code>pthread_mutex_init</code> 函数，得到互斥量的默认属性。</p>
<p>对于非默认属性，可以使用下列函数进行初始化和销毁：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_destroy</span><span class="params">(<span class="keyword">pthread_mutexattr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_init</span><span class="params">(<span class="keyword">pthread_mutexattr_t</span> *attr)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p>互斥量的三个主要属性：</p>
<ul>
<li>进程共享属性</li>
<li>健壮属性（略）</li>
<li>类型属性</li>
</ul>
<blockquote>
<p>进程共享</p>
</blockquote>
<p>在进程中，多个线程可以访问同一个同步对象。正如在<code>8.5.2节</code>看到的，这是默认的行为。在这种情况下，进程共享互斥量属性需设置为<code>PTHREAD_PROCESS_PRIVATE</code>。</p>
<p>但也存在这样的机制：允许相互独立的多个进程把同一个内存数据块映射到它们各自独立的地址空间中。就像多个线程访问共享数据一样，多个进程访问共享数据通常也需要同步。如果进程共享互斥量属性设置为<code>PTHREAD_PROCESS_SHARED</code>，从多个进程彼此之间共享的内存数据块中分配的互斥量就可以用于这些进程的同步。</p>
<p>相关函数调用：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_getpshared</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> * <span class="keyword">restrict</span> attr, <span class="keyword">int</span> *<span class="keyword">restrict</span> pshared)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_setpshared</span><span class="params">(<span class="keyword">pthread_mutexattr_t</span> *attr, <span class="keyword">int</span> pshared)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>pshared</code>：这里的p指的就是进程process<ul>
<li><code>PTHREAD_PROCESS_PRIVATE</code>：进程独占互斥量</li>
<li><code>PTHREAD_PROCESS_SHARED</code>：进程共享互斥量</li>
</ul>
</li>
</ul>
<blockquote>
<p>类型属性</p>
</blockquote>
<p>类型互斥量属性控制着互斥量的锁定特性。POSIX.1定义了4种类型。</p>
<ul>
<li><code>PTHREAD_MUTEX_NORMAL</code>：一种标准互斥量类型，不做任何特殊的错误检查或死锁检测。</li>
<li><code>PTHREAD_MUTEX_ERRORCHECK</code>：此互斥量类型提供错误检查。</li>
<li><code>PTHREAD_MUTEX_RECURSIVE</code> ：此互斥量类型允许同一线程在互斥量解锁之前对该互斥量进行多次加锁。递归互斥量维护锁的计数，在解锁次数和加锁次数不相同的情况下，不会释放锁。所以，如果对一个递归互斥量加锁两次，然后解锁一次，那么这个互斥量将依然处于加锁状态，对它再次解锁以前不能释放该锁。</li>
<li><code>PTHREAD_MUTEX_DEFAULT</code>：此互斥量类型可以提供默认特性和行为。操作系统在实现它的时候可以把这种类型自由地映射到其他互斥量类型中的一种。</li>
</ul>
<p><a href="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20221231194113676.png" data-fancybox="gallery" data-caption="image-20221231194113676" data-thumb="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20221231194113676.png"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20221231194113676.png" alt="image-20221231194113676"></a></p>
<p>上图不占用解锁是指解锁不是自己加的锁（解锁别人加的锁），例如打印abcd的程序。</p>
<p>相关函数：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_gettype</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr, <span class="keyword">int</span> *<span class="keyword">restrict</span> type)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_settype</span><span class="params">(<span class="keyword">pthread_mutexattr_t</span> *attr, <span class="keyword">int</span> type)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<h4 id="8-7-2-条件变量属性"><a href="#8-7-2-条件变量属性" class="headerlink" title="8.7.2 条件变量属性"></a>8.7.2 条件变量属性</h4><p>相关函数：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_condattr_destroy</span><span class="params">(<span class="keyword">pthread_condattr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_condattr_init</span><span class="params">(<span class="keyword">pthread_condattr_t</span> *attr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_condattr_getpshared</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_condattr_t</span> *<span class="keyword">restrict</span> attr, <span class="keyword">int</span> *<span class="keyword">restrict</span> pshared)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_condattr_setpshared</span><span class="params">(<span class="keyword">pthread_condattr_t</span> *attr,<span class="keyword">int</span> pshared)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<h3 id="8-8-线程安全IO"><a href="#8-8-线程安全IO" class="headerlink" title="8.8 线程安全IO"></a>8.8 线程安全IO</h3><p>此前介绍过的IO都是线程安全的IO，即在当多个线程操作IO时，都必须对缓冲区进行加锁和解锁，防止出现对缓冲区进行竞争的现象。</p>
<p>例如三个线程，分别向标准输出终端打印连续字符<code>aaa</code>，<code>bbb</code>和<code>ccc</code>，如果使用线程安全的io，例如<code>puts</code>，可能出现的情况有：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">aaabbbccc</span><br><span class="line">aaacccbbb</span><br><span class="line">cccbbbaaa</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></tbody></table></figure>
<p>但绝不会出现下面这种情况：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">abcabcabc</span><br><span class="line">aabbccabc</span><br><span class="line"><span class="comment">// ... </span></span><br></pre></td></tr></tbody></table></figure>
<p>原因就在于，<code>puts</code>是线程安全的，在对缓冲区操作前，需要加锁。</p>
<p>也存在线程不安全的IO调用，当考虑到效率问题（省去加锁和解锁的时间），并且确保只有单线程操作缓冲区时，可以使用下面的这些函数，这些函数在后面都加上了<code>_unlocked</code>，表示不加锁。</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getc_unlocked</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getchar_unlocked</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putc_unlocked</span><span class="params">(<span class="keyword">int</span> c, FILE *stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putchar_unlocked</span><span class="params">(<span class="keyword">int</span> c)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearerr_unlocked</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">feof_unlocked</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ferror_unlocked</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fileno_unlocked</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fflush_unlocked</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fgetc_unlocked</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputc_unlocked</span><span class="params">(<span class="keyword">int</span> c, FILE *stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">fread_unlocked</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> n,</span></span></span><br><span class="line"><span class="params"><span class="function">                      FILE *stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">fwrite_unlocked</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> n,</span></span></span><br><span class="line"><span class="params"><span class="function">                       FILE *stream)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">fgets_unlocked</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">int</span> n, FILE *stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputs_unlocked</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, FILE *stream)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<h3 id="8-9-线程和信号"><a href="#8-9-线程和信号" class="headerlink" title="8.9 线程和信号"></a>8.9 线程和信号</h3><p>对多线程的进程而言，只有进程级别的未决信号集<code>pending</code>，没有信号屏蔽字<code>mask</code>，而每个线程都有自己的<code>pending</code>和<code>mask</code>（线程级别）。</p>
<p>进程向进程发送信号，改变的是进程级别的<code>pending</code>，线程向线程发送信号，改变的是线程级别的<code>pending</code>。对于线程级别的信号响应，使用当前线程的<code>pending</code>和<code>mask</code>进行按位与。对于进程级别的信号响应，使用当前工作线程的<code>mask</code>和进程级别的<code>pending</code>进行按位与。</p>
<p>此前讨论了进程如何使用 <code>sigprocmask</code> 函数来阻止信号发送。然而，<code>sigprocmask</code> 的行为在多线程的进程中并没有定义，线程必须使用<code>pthread_sigmask</code>。</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改线程级别的信号屏蔽字</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_sigmask</span><span class="params">(<span class="keyword">int</span> how, <span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">sigset_t</span> *oldset)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向指定线程发送信号</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_kill</span><span class="params">(<span class="keyword">pthread_t</span> thread, <span class="keyword">int</span> sig)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p>线程可以调用<code>sigwait</code>等待一个或多个信号的出现：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待信号集set</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigwait</span><span class="params">(<span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> *sig)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<h3 id="8-10-线程与fork"><a href="#8-10-线程与fork" class="headerlink" title="8.10 线程与fork"></a>8.10 线程与fork</h3><p>暂略</p>
<h2 id="9-高级IO"><a href="#9-高级IO" class="headerlink" title="9 高级IO"></a>9 高级IO</h2><p>本节对应第十四章高级IO</p>
<p>IO模型分为五种：</p>
<ul>
<li>阻塞io</li>
<li>非阻塞io</li>
<li>信号驱动</li>
<li>多路转接</li>
<li>异步io</li>
</ul>
<h3 id="9-0-IO过程"><a href="#9-0-IO过程" class="headerlink" title="9.0 IO过程"></a>9.0 IO过程</h3><p>我们要将内存中的数据写入到磁盘的话，主体会是什么呢？主体可能是一个应用程序，比如一个Java进程（假设网络传来二进制流，一个Java进程可以把它写入到磁盘）。</p>
<p>操作系统负责计算机的资源管理和进程的调度。应用程序要把数据写入磁盘，或者从磁盘读取数据，只能通过调用操作系统开放出来的API来操作。</p>
<p>应用程序的IO操作分为两种动作：<strong>IO调用和IO执行</strong>。IO调用是由进程（应用程序的运行态）发起，而IO执行是操作系统内核的工作。此时所说的IO是应用程序对操作系统IO功能的一次触发，即IO调用。 </p>
<p>应用程序发起的一次IO操作包含两个阶段： </p>
<ul>
<li>IO调用：应用程序进程向操作系统内核发起调用。</li>
<li>IO执行：操作系统内核完成IO操作。 </li>
</ul>
<p>操作系统内核完成IO操作还包括两个过程：</p>
<ul>
<li>准备数据阶段：内核等待I/O设备准备好数据</li>
<li>拷贝数据阶段：将数据从内核缓冲区（内核空间）拷贝到用户进程缓冲区（用户空间）</li>
</ul>
<p><a href="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/e38120144a05bd53d5e871ec2b21a456ad4fd42f.png@942w_483h_progressive.webp" data-fancybox="gallery" data-caption="img" data-thumb="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/e38120144a05bd53d5e871ec2b21a456ad4fd42f.png@942w_483h_progressive.webp"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/e38120144a05bd53d5e871ec2b21a456ad4fd42f.png@942w_483h_progressive.webp" alt="img"></a></p>
<p>其实IO就是把进程的内部数据转移到外部设备，或者把外部设备的数据迁移到进程内部。外部设备一般指硬盘、socket通讯的网卡。 </p>
<h3 id="9-1-BIO和NIO"><a href="#9-1-BIO和NIO" class="headerlink" title="9.1 BIO和NIO"></a>9.1 BIO和NIO</h3><p>阻塞IO：当资源不可用的时候，应用程序就会挂起。当资源可用的时候，唤醒任务。</p>
<p>阻塞IO图示如下，应用程序调用 read 函数从设备中读取数据，当设备不可用或数据未准备好的时候就会进入到休眠态。等设备可用的时候就会从休眠态唤醒，然后从设备中读取数据返回给应用程序。</p>
<p><a href="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/65df26863b581ca59778100a7a1a02d189dfa866.png@942w_494h_progressive.webp" data-fancybox="gallery" data-caption="图片" data-thumb="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/65df26863b581ca59778100a7a1a02d189dfa866.png@942w_494h_progressive.webp"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/65df26863b581ca59778100a7a1a02d189dfa866.png@942w_494h_progressive.webp" alt="图片"></a></p>
<p>之前学习过的IO都是阻塞IO。<strong>阻塞IO要阻塞一次</strong>，即等待数据和拷贝数据这个过程。</p>
<blockquote>
<p>优缺点</p>
</blockquote>
<p>优点：应用的程序开发非常简单；在阻塞等待数据期间，用户线程挂起。在阻塞期间，用户线程基本不会占用CPU资源。</p>
<p>缺点：一般情况下，会为每个连接配备一个独立的线程；反过来说，就是一个线程维护一个连接的IO操作。在并发量小的情况下，这样做没有什么问题。但
是，当在高并发的应用场景下，需要大量的线程来维护大量的网络连接，内存、线程切换开销会非常巨大。因此，基本上阻塞IO模型在高并发应用场景下是不可用
的。</p>
<hr>
<p>非阻塞IO：当资源不可用的时候，应用程序轮询查看，或放弃，会有超时处理机制。</p>
<p>非阻塞IO图示如下，可以看出，应用程序使用非阻塞访问方式从设备读取数据，当设备不可用或数据未准备好的时候会立即向内核返回一个错误码，表示数据读取失败。应用程序会再次重新读取数据，这样一直往复循环，直到数据读取成功。</p>
<p><strong>非阻塞io也要阻塞一次</strong>，等待数据不用阻塞（内核马上返回未准备好），而从内核拷贝数据到用户区需要阻塞。</p>
<p><a href="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/59e8cd152207a719c491960c01db424c1daa2dcd.png@942w_668h_progressive.webp" data-fancybox="gallery" data-caption="图片" data-thumb="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/59e8cd152207a719c491960c01db424c1daa2dcd.png@942w_668h_progressive.webp"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/59e8cd152207a719c491960c01db424c1daa2dcd.png@942w_668h_progressive.webp" alt="图片"></a></p>
<p>缺点：依然存在性能问题，即<strong>频繁的轮询</strong>，导致频繁的系统调用，同样会消耗大量的CPU资源。可以考虑IO复用模型，去解决这个问题。 </p>
<h3 id="9-2-有限状态机"><a href="#9-2-有限状态机" class="headerlink" title="9.2 有限状态机"></a>9.2 有限状态机</h3><p>需求：有左右两个设备，第一个任务为读左设备，写右设备，第二个任务读右设备，写左设备。</p>
<p><a href="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20230307104712102.png" data-fancybox="gallery" data-caption="image-20230307104712102" data-thumb="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20230307104712102.png"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20230307104712102.png" alt="image-20230307104712102"></a></p>
<blockquote>
<p>代码实现</p>
</blockquote>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TTY1 <span class="meta-string">"/dev/tty3"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TTY2 <span class="meta-string">"/dev/tty4"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFSIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有限状态机的状态枚举</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> {</span></span><br><span class="line">    STATE_R = <span class="number">1</span>, <span class="comment">// 读</span></span><br><span class="line">    STATE_W, <span class="comment">// 写</span></span><br><span class="line">    STATE_Ex, <span class="comment">// 异常</span></span><br><span class="line">    STATE_T <span class="comment">// 终止</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fsm_st</span> {</span></span><br><span class="line">    <span class="keyword">int</span> state;</span><br><span class="line">    <span class="keyword">int</span> sfd;</span><br><span class="line">    <span class="keyword">int</span> dfd;</span><br><span class="line">    <span class="keyword">int</span> len; <span class="comment">// 读取到的数据</span></span><br><span class="line">    <span class="keyword">int</span> pos; <span class="comment">// buf的偏移量</span></span><br><span class="line">    <span class="keyword">char</span> buf[BUFSIZE]; <span class="comment">// 缓冲区</span></span><br><span class="line">    <span class="keyword">char</span> *errstr; <span class="comment">// 报错信息</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 状态机驱动 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fsm_driver</span><span class="params">(struct fsm_st *fsm)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="comment">// 根据当前状态，决定下一步动作</span></span><br><span class="line">    <span class="keyword">switch</span>(fsm-&gt;state) {</span><br><span class="line">        <span class="comment">// 当前状态为读状态</span></span><br><span class="line">        <span class="keyword">case</span> STATE_R:</span><br><span class="line">            fsm-&gt;len = read(fsm-&gt;sfd, fsm-&gt;buf, BUFSIZE);</span><br><span class="line">            <span class="keyword">if</span>(fsm-&gt;len == <span class="number">0</span>) { <span class="comment">// 读完文件</span></span><br><span class="line">                fsm-&gt;state = STATE_T;</span><br><span class="line">            }<span class="keyword">else</span> <span class="keyword">if</span>(fsm-&gt;len &lt; <span class="number">0</span>) {</span><br><span class="line">                <span class="keyword">if</span>(errno == EAGAIN) { <span class="comment">// 数据没有准备好</span></span><br><span class="line">                    fsm-&gt;state = STATE_R;</span><br><span class="line">                } <span class="keyword">else</span> { <span class="comment">// 真错</span></span><br><span class="line">                    fsm-&gt;errstr = <span class="string">"read()"</span>;</span><br><span class="line">                    fsm-&gt;state = STATE_Ex;</span><br><span class="line">                }</span><br><span class="line">            }<span class="keyword">else</span> { <span class="comment">// 转换为写状态</span></span><br><span class="line">                fsm-&gt;pos = <span class="number">0</span>;</span><br><span class="line">                fsm-&gt;state = STATE_W;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 当前状态为写状态</span></span><br><span class="line">        <span class="keyword">case</span> STATE_W:</span><br><span class="line">            ret = write(fsm-&gt;dfd, fsm-&gt;buf + fsm-&gt;pos, fsm-&gt;len);</span><br><span class="line">            <span class="keyword">if</span>(ret &lt; <span class="number">0</span>) {</span><br><span class="line">                <span class="keyword">if</span>(errno == EAGAIN) {</span><br><span class="line">                    fsm-&gt;state = STATE_W;</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    fsm-&gt;errstr = <span class="string">"write()"</span>;</span><br><span class="line">                    fsm-&gt;state = STATE_Ex;</span><br><span class="line">                }</span><br><span class="line">            }<span class="keyword">else</span> {</span><br><span class="line">                fsm-&gt;pos += ret;</span><br><span class="line">                fsm-&gt;len -= ret;</span><br><span class="line">                <span class="keyword">if</span>(fsm-&gt;len == <span class="number">0</span>) { <span class="comment">// 写够len个字节</span></span><br><span class="line">                    fsm-&gt;state = STATE_R;</span><br><span class="line">                } <span class="keyword">else</span> { <span class="comment">// 没有写够len个字节</span></span><br><span class="line">                    fsm-&gt;state = STATE_W;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> STATE_Ex:</span><br><span class="line">            perror(fsm-&gt;errstr);</span><br><span class="line">            fsm-&gt;state = STATE_T;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> STATE_T:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">abort</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">relay</span><span class="params">(<span class="keyword">int</span> fd1, <span class="keyword">int</span> fd2)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> fd1_save, fd2_save;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fsm_st</span> <span class="title">fsm12</span>, <span class="title">fsm21</span>;</span></span><br><span class="line">    <span class="comment">// 获取文件状态选项</span></span><br><span class="line">    fd1_save = fcntl(fd1, F_GETFL);</span><br><span class="line">    <span class="comment">// 设置文件状态选项，添加非阻塞模式</span></span><br><span class="line">    fcntl(fd1, F_SETFL, fd1_save|O_NONBLOCK);</span><br><span class="line"></span><br><span class="line">    fd2_save = fcntl(fd2, F_GETFL);</span><br><span class="line">    fcntl(fd2, F_SETFL, fd2_save|O_NONBLOCK);</span><br><span class="line">    <span class="comment">// 设置状态机</span></span><br><span class="line">    fsm12.state = STATE_R;</span><br><span class="line">    fsm12.sfd = fd1;</span><br><span class="line">    fsm12.dfd = fd2;</span><br><span class="line"></span><br><span class="line">    fsm21.state = STATE_R;</span><br><span class="line">    fsm21.sfd = fd2;</span><br><span class="line">    fsm21.dfd = fd1;</span><br><span class="line">	<span class="comment">// 轮询</span></span><br><span class="line">    <span class="keyword">while</span>(fsm12.state != STATE_T || fsm21.state != STATE_T) {</span><br><span class="line">        fsm_driver(&amp;fsm12);</span><br><span class="line">        fsm_driver(&amp;fsm21);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 恢复用户设置的文件状态</span></span><br><span class="line">    fcntl(fd1, F_SETFL, fd1_save);</span><br><span class="line">    fcntl(fd2, F_SETFL, fd2_save);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟用户的设置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> fd1, fd2; <span class="comment">// 左设备和右设备</span></span><br><span class="line">    <span class="comment">// 假设用户不以非阻塞的方式打开文件</span></span><br><span class="line">    <span class="keyword">if</span>((fd1 = open(TTY1, O_RDWR)) &lt; <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">"open()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    write(fd1,<span class="string">"TTY1\n"</span>,<span class="number">5</span>);</span><br><span class="line">    <span class="comment">// 假设用户以非阻塞的方式打开文件</span></span><br><span class="line">    <span class="keyword">if</span>((fd2 = open(TTY1, O_RDWR|O_NONBLOCK)) &lt; <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">"open()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    write(fd2,<span class="string">"TTY2\n"</span>,<span class="number">5</span>);</span><br><span class="line">    relay(fd1, fd2);</span><br><span class="line">    close(fd2);</span><br><span class="line">    close(fd1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>上述代码存在忙等现象，会使得CPU利用率占满，原因在于：</p>
<p>进入循环后：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(fsm12.state != STATE_T || fsm21.state != STATE_T) {</span><br><span class="line">    fsm_driver(&amp;fsm12);</span><br><span class="line">    fsm_driver(&amp;fsm21);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>如果设备没有准备好数据，则进入<code>fsm_driver</code>后，执行<code>read</code>调用时，内核立即会返回（非阻塞），是一个假错，执行：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(errno == EAGAIN) { <span class="comment">// 通常在执行非阻塞io时引发EAGAIN，这意味着“现在没有可用的数据，以后再试一次” 。</span></span><br><span class="line">    fsm-&gt;state = STATE_R;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>状态不变，跳出case语句和驱动函数后，继续循环，所以导致cpu利用率高。</p>
<h3 id="9-3-linux终端"><a href="#9-3-linux终端" class="headerlink" title="9.3 linux终端"></a>9.3 linux终端</h3><h4 id="9-3-1-终端，控制台和tty"><a href="#9-3-1-终端，控制台和tty" class="headerlink" title="9.3.1 终端，控制台和tty"></a>9.3.1 终端，控制台和tty</h4><p><a href="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/v2-7aa6997d017d876543671e4113048a62_720w.webp" data-fancybox="gallery" data-caption="img" data-thumb="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/v2-7aa6997d017d876543671e4113048a62_720w.webp"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/v2-7aa6997d017d876543671e4113048a62_720w.webp" alt="img"></a></p>
<p><code>tty</code>全称<code>teletypewriter</code>，即是电传打字机，它通过两根电缆连接计算机，一根用于向计算机发送指令，一根用于接收计算机的输出，输出结果是打印在纸上的。它是最早出现的一种终端设备。</p>
<p>最初tty是指连接到Unix系统上的物理或者虚拟终端。<strong>终端</strong>是一种字符型设备，通常使用<code>tty</code>来
统称各种类型的终端设备。随着时间的推移，当通过串行口能够建立起终端连接后，这个名字也用来指任何的串口设备。它还有多种类，例如串口（ttySn、
ttySACn、ttyOn）、USB到串口的转换器（ttyUSBn）等。tty虚拟设备支持虚拟控制台，它能通过键盘及网络连接或者通过xterm会
话登录到计算机上。</p>
<ul>
<li>终端（<code>terminal</code>）为主机提供了人机接口，每个人都通过终端使用主机的资源。终端有字符终端和图形终端两种，一台主机可以连很多终端。</li>
<li>控制台（<code>console</code>）是一种特殊的人机接口，是人控制主机的第一人机接口，而主机对于控制台的信任度高于其他终端。</li>
</ul>
<p>个人计算机只有控制台，没有终端。当然愿意的话，可以在串口上连一两台字符哑终端。但是linux按POSIX标准把个人计算机当成小型机来用，在控制台上通过软件虚拟了六个字符哑终端（或者叫虚拟控制台终端<code>tty1-tty6</code>）和一个图型终端，在虚拟图形终端中又可以通过软件再虚拟无限多个<strong>伪终端</strong>（<code>pts/0</code>等）。但这全是虚拟的，虽然用起来一样，但实际上没有物理实体。所以在个人计算机上，只有一个实际的控制台，没有终端，<strong>所有终端都是在控制台上用软件模拟的</strong>。要把个人计算机当主机再通过串口或网卡外连真正的物理终端也可以，论成本，谁会怎么做呢。</p>
<p><a href="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/v2-63cdd117f1026c2bbf455920b29c4454_720w.webp" data-fancybox="gallery" data-caption="img" data-thumb="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/v2-63cdd117f1026c2bbf455920b29c4454_720w.webp"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/v2-63cdd117f1026c2bbf455920b29c4454_720w.webp" alt="img"></a></p>
<p>linux的终端设备一般分为以下几种：</p>
<p><a href="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20230125192420131.png" data-fancybox="gallery" data-caption="image-20230125192420131" data-thumb="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20230125192420131.png"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20230125192420131.png" alt="image-20230125192420131"></a></p>
<h4 id="9-3-2-控制台"><a href="#9-3-2-控制台" class="headerlink" title="9.3.2 控制台"></a>9.3.2 控制台</h4><h5 id="①-系统控制台"><a href="#①-系统控制台" class="headerlink" title="① 系统控制台"></a>① 系统控制台</h5><p><code>/dev/console</code>是系统控制台，是与操作系统交互的设备。</p>
<h5 id="②-当前控制台"><a href="#②-当前控制台" class="headerlink" title="② 当前控制台"></a>② 当前控制台</h5><p><code>/dev/tty</code>是当前控制台，它会映射到当前设备（使用命令<code>tty</code>可以查看它具体对应哪个实际物理控制台设备）。</p>
<p>如果在控制台界面下（即字符界面下）那么<code>dev/tty</code>就是映射到<code>dev/tty1-6</code>之间的一个，但是如果现在是在图形界面（Xwindows），那么你会发现现在的<code>/dev/tty</code>映射到的是<code>/dev/pts</code>的伪终端上。</p>
<p><a href="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20230125193405486.png" data-fancybox="gallery" data-caption="image-20230125193405486" data-thumb="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20230125193405486.png"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20230125193405486.png" alt="image-20230125193405486"></a></p>
<h5 id="③-虚拟控制台"><a href="#③-虚拟控制台" class="headerlink" title="③ 虚拟控制台"></a>③ 虚拟控制台</h5><p><code>/dev/ttyn</code>是进程虚拟控制台，他们共享同一个真实的物理控制台。</p>
<p>在PC上，用户可以使用<code>alt+Fn</code>切换控制台，看起来感觉存在多个屏幕，这种虚拟控制台对应<code>tty1~n</code>，其中 ，<code>/dev/tty1</code>等代表第一个虚拟控制台。</p>
<p>例如当使用ALT+F2进行切换时，系统的虚拟控制台为/dev/tty2 ，当前控制台（/dev/tty）则指向/dev/tty2；</p>
<p>比较特殊的是<code>/dev/tty0</code>，他代表<strong>当前虚拟控制台</strong>，是当前所使用虚拟控制台的一个别名。因此不管当前正在使用哪个虚拟控制台（注意：这里是虚拟控制台，不包括伪终端），系统信息都会发送到/dev/tty0上。</p>
<h4 id="9-3-3-伪终端"><a href="#9-3-3-伪终端" class="headerlink" title="9.3.3 伪终端"></a>9.3.3 伪终端</h4><p>伪终端（<code>Pseudo Terminal</code>，或者<code>pty, pseudo-tty</code>）
是终端的发展，为满足现在需求（比如网络登陆、xwindow窗口的管理）。它是成对出现的逻辑终端设备（即master和slave设备，对
master的操作会反映到slave上），多用于模拟终端程序，是远程登陆（telnet、ssh、xterm等）后创建的控制台设备。</p>
<p>在<code>XWindow</code>下打开的终端或使用telnet 或ssh等方式登录Linux主机，此时均通过pty设备。例如，如果某人在网上使用telnet程序连接到计算机上，则telnet程序就可能会打开<code>/dev/ptmx</code>设备获取一个fd。此时一个getty程序就应该运行在对应的<code>/dev/pts/*</code>上。当telnet从远端获取了一个字符时，该字符就会通过ptmx、<code>pts/*</code>传递给getty程序，而getty程序就会通过<code>pts/*</code>、ptmx和telnet程序往网络上返回<code>login:</code>字符串信息。这样，登录程序与telnet程序就通过“伪终端”进行通信。</p>
<h4 id="9-3-4-串口终端"><a href="#9-3-4-串口终端" class="headerlink" title="9.3.4 串口终端"></a>9.3.4 串口终端</h4><p>略</p>
<h3 id="9-4-IO多路转接"><a href="#9-4-IO多路转接" class="headerlink" title="9.4 IO多路转接"></a>9.4 IO多路转接</h3><p>IO多路转接也称为IO多路复用。</p>
<p>IO复用模型核心思路：系统给我们提供一类函数（select、poll、epoll函数），它们可以<strong>同时监控多个fd的操作</strong>，任何一个返回内核数据就绪，应用进程再发起recvfrom系统调用。</p>
<h4 id="9-4-1-select"><a href="#9-4-1-select" class="headerlink" title="9.4.1 select"></a>9.4.1 select</h4><p>应用进程通过调用select函数，可以同时监控多个fd，在select函数监控的fd中，只要有任何一个数据状态准备就绪了，select函数就会返回可读状态，这时应用进程再发起recvfrom请求去读取数据。</p>
<blockquote>
<p>图示1</p>
</blockquote>
<p><a href="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/e691ef2b3102e647ac5fe3764c9221981d3d2fed.png@942w_576h_progressive.webp" data-fancybox="gallery" data-caption="图片" data-thumb="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/e691ef2b3102e647ac5fe3764c9221981d3d2fed.png@942w_576h_progressive.webp"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/e691ef2b3102e647ac5fe3764c9221981d3d2fed.png@942w_576h_progressive.webp" alt="图片"></a></p>
<blockquote>
<p>图示2</p>
</blockquote>
<p><a href="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/v2-a7c61c3f019f06d03570418778eb1b65_r.jpg" data-fancybox="gallery" data-caption="img" data-thumb="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/v2-a7c61c3f019f06d03570418778eb1b65_r.jpg"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/v2-a7c61c3f019f06d03570418778eb1b65_r.jpg" alt="img"></a></p>
<p><strong>IO多路转接需要阻塞两次</strong>，第一次是在select处阻塞（内核为我们轮询fd的变化情况），第二次是select返回后，拷贝数据发起系统调用（不管是读还是写）时需要再次阻塞。</p>
<p>函数原型：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* According to POSIX.1-2001 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* According to earlier standards */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除 set 中的给定的文件描述符</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>;</span><br><span class="line"><span class="comment">// 测试文件描述符 fd 是否在 set 集合中</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>;</span><br><span class="line"><span class="comment">// 将文件描述符 fd 添加到 set 中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>;</span><br><span class="line"><span class="comment">// 清空 set 中的文件描述符</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *<span class="built_in">set</span>)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p>注意select调用本身是阻塞的。</p>
<p>select参数含义：</p>
<ul>
<li><code>nfds</code>：最大的文件描述符 + 1；</li>
<li><code>readfds</code>：需要监视的输入文件描述符集合，底层采用数组存储。</li>
<li><code>writefds</code>：需要监视的输出文件描述符集合；</li>
<li><code>exceptfds</code>：需要监视的会发生异常的文件描述符集合；</li>
<li><code>timeout</code>：等待的超时时间，如果时间超时依然没有文件描述符状态发生变化那么就返回。设置为 0 会立即返回，设置为 NULL 则一直阻塞等待，不会超时。</li>
</ul>
<p>返回值：错误返回-1，超时返回0。当关注的事件返回时，返回大于0的值，该值是发生事件的文件描述符数。</p>
<blockquote>
<p>代码示例</p>
</blockquote>
<p>利用<code>select</code>重构<code>9.2小节</code>的代码：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TTY1 <span class="meta-string">"/dev/tty3"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TTY2 <span class="meta-string">"/dev/tty4"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFSIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有限状态机的状态枚举</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> {</span></span><br><span class="line">    STATE_R = <span class="number">1</span>, <span class="comment">// 读</span></span><br><span class="line">    STATE_W, <span class="comment">// 写</span></span><br><span class="line">    STATE_AUTO,</span><br><span class="line">    STATE_Ex, <span class="comment">// 异常</span></span><br><span class="line">    STATE_T <span class="comment">// 终止</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">relay</span><span class="params">(<span class="keyword">int</span> fd1, <span class="keyword">int</span> fd2)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> fd1_save, fd2_save;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fsm_st</span> <span class="title">fsm12</span>, <span class="title">fsm21</span>;</span></span><br><span class="line">    fd_set rset, wset;</span><br><span class="line">    <span class="comment">// 获取文件状态选项</span></span><br><span class="line">    fd1_save = fcntl(fd1, F_GETFL);</span><br><span class="line">    <span class="comment">// 设置文件状态选项，添加非阻塞模式</span></span><br><span class="line">    fcntl(fd1, F_SETFL, fd1_save|O_NONBLOCK);</span><br><span class="line"></span><br><span class="line">    fd2_save = fcntl(fd2, F_GETFL);</span><br><span class="line">    fcntl(fd2, F_SETFL, fd2_save|O_NONBLOCK);</span><br><span class="line">    <span class="comment">// 设置状态机</span></span><br><span class="line">    fsm12.state = STATE_R;</span><br><span class="line">    fsm12.sfd = fd1;</span><br><span class="line">    fsm12.dfd = fd2;</span><br><span class="line"></span><br><span class="line">    fsm21.state = STATE_R;</span><br><span class="line">    fsm21.sfd = fd2;</span><br><span class="line">    fsm21.dfd = fd1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(fsm12.state != STATE_T || fsm21.state != STATE_T) {</span><br><span class="line">        <span class="comment">// 布置监视任务，清空fd_set</span></span><br><span class="line">        FD_ZERO(&amp;rset);</span><br><span class="line">        FD_ZERO(&amp;wset);</span><br><span class="line">        <span class="keyword">if</span>(fsm12.state == STATE_R) { <span class="comment">// 当前为读态，即读sfd</span></span><br><span class="line">            FD_SET(fsm12.sfd, &amp;rset); <span class="comment">// 我们关心sfd是否可读，因此将其加入到rset中</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(fsm12.state == STATE_W) { <span class="comment">// 当前为写态，即写dfd</span></span><br><span class="line">            FD_SET(fsm12.dfd, &amp;wset);<span class="comment">// 我们关心dfd是否可写，因此将其加入到wset中</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(fsm21.state == STATE_R) {</span><br><span class="line">            FD_SET(fsm21.sfd, &amp;rset);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(fsm21.state == STATE_W) {</span><br><span class="line">            FD_SET(fsm21.dfd, &amp;wset);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 监视</span></span><br><span class="line">        <span class="keyword">if</span>(fsm12.state &lt; STATE_AUTO || fsm21.state &lt; STATE_AUTO) {</span><br><span class="line">            <span class="comment">// 阻塞监视</span></span><br><span class="line">            <span class="keyword">if</span>(select(max(fd1, fd2) + <span class="number">1</span>, &amp;rset, &amp;wset, <span class="literal">NULL</span>, <span class="literal">NULL</span>) &lt; <span class="number">0</span>) {</span><br><span class="line">                <span class="keyword">if</span>(errno == EINTR) { <span class="comment">// 阻塞调用被信号打断，假错</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                }</span><br><span class="line">                perror(<span class="string">"select()"</span>); <span class="comment">// 真错</span></span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 查看监视结果</span></span><br><span class="line">        <span class="keyword">if</span>(FD_ISSET(fd1, &amp;rset) || FD_ISSET(fd2, &amp;wset) || fsm12.state &gt; STATE_AUTO) { <span class="comment">// 读fd1准备好 或 写fd2准备好 或 其他状态</span></span><br><span class="line">            fsm_driver(&amp;fsm12);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(FD_ISSET(fd2, &amp;rset) || FD_ISSET(fd1, &amp;wset) || fsm21.state &gt; STATE_AUTO) { <span class="comment">// 读fd2准备好 或 写fd1准备好 或 其他状态</span></span><br><span class="line">            fsm_driver(&amp;fsm21);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 恢复用户设置的文件状态</span></span><br><span class="line">    fcntl(fd1, F_SETFL, fd1_save);</span><br><span class="line">    fcntl(fd2, F_SETFL, fd2_save);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>上面的代码不会出现盲等现象，原因在于：</p>
<p>调用<code>select</code>函数后会在此处阻塞，同时内核监控<code>rset</code>和<code>wset</code>中的文件描述符的变化（准备数据）。</p>
<p>当发生变化时（数据准备好时），唤醒线程，<code>select</code>函数返回值大于0，继续向下执行，推动状态机运行（进行读写时还会再次阻塞，例如read或write，因为明确了数据已经准备好）。</p>
<p>综上，不会产生盲等。</p>
<hr>
<p>select的缺点：</p>
<ul>
<li>监听的IO最大连接数有限，在Linux系统上一般为1024。</li>
<li>select函数返回后，是通过遍历fdset，找到就绪的描述符fd。（仅知道有I/O事件发生，却不知是哪几个流，所以遍历所有流） ，如果同时连接的大量客户端，在一时刻可能只有极少处于就绪状态，伴随着监视的描述符数量的增长，效率也会线性下降。 </li>
<li>内存拷贝：需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大。</li>
</ul>
<h4 id="9-4-2-poll"><a href="#9-4-2-poll" class="headerlink" title="9.4.2 poll"></a>9.4.2 poll</h4><p>select
 和 poll 系统调用的本质一样，poll 的机制与 select 类似，与 select 
在本质上没有多大差别，管理多个描述符也是进行轮询，根据描述符的状态进行处理，但是 poll 
没有最大文件描述符数量的限制（数量过大后性能也是会下降）。poll 和 select 
同样存在一个缺点就是，包含大量文件描述符的数组被整体复制于用户态和内核的地址空间之间，而不论这些文件描述符是否就绪，它的开销随着文件描述符数量的
增加而线性增大。</p>
<p>函数原型：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// poll - wait for some event on a file descriptor</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *fds, <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> {</span></span><br><span class="line">    <span class="keyword">int</span>   fd;         <span class="comment">/* 需要监视的文件描述符 */</span></span><br><span class="line">    <span class="keyword">short</span> events;     <span class="comment">/* 要监视的事件 */</span></span><br><span class="line">    <span class="keyword">short</span> revents;    <span class="comment">/* 该文件描述符发生了的事件 */</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>参数含义：</p>
<ul>
<li><code>fds</code>：实际上是一个结构体数组的首地址，因为 poll 可以帮助我们监视多个文件描述符，而一个文件描述放到一个 <code>struct pollfd</code> 结构体中，多个文件描述符就需要一个数组来存储了（一个文件描述符对应一个结构体）。底层采用链表存储。</li>
<li><code>nfds</code>：fds 这个数组的长度。</li>
<li><code>timeout</code>：阻塞等待的超时时间。传入 -1 则始终阻塞，不超时。</li>
</ul>
<p>返回值：</p>
<ul>
<li>成功时，poll 返回结构体中 revents 域不为 0 的文件描述符个数；如果在超时前没有任何事件发生，poll返回 0；</li>
<li>失败时，poll 返回 -1，并设置 errno</li>
</ul>
<p>结构体中的事件<code>events</code>和<code>revents</code>可以指定下面七种事件，同时监视多个事件可以使用按位或（<code>|</code>）添加：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>事件</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>POLLIN</td>
<td>文件描述符可读</td>
</tr>
<tr>
<td>POLLPRI</td>
<td>可以非阻塞的读高优先级的数据</td>
</tr>
<tr>
<td>POLLOUT</td>
<td>文件描述符可写</td>
</tr>
<tr>
<td>POLLRDHUP</td>
<td>流式套接字连接点关闭，或者关闭写半连接。</td>
</tr>
<tr>
<td>POLLERR</td>
<td>已出错</td>
</tr>
<tr>
<td>POLLHUP</td>
<td>已挂断（一般指设备）</td>
</tr>
<tr>
<td>POLLNVAL</td>
<td>参数非法</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>程序实例</p>
</blockquote>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">relay</span><span class="params">(<span class="keyword">int</span> fd1, <span class="keyword">int</span> fd2)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> fd1_save, fd2_save;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fsm_st</span> <span class="title">fsm12</span>, <span class="title">fsm21</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pfd</span>[2];</span></span><br><span class="line">    <span class="comment">// 获取文件状态选项</span></span><br><span class="line">    fd1_save = fcntl(fd1, F_GETFL);</span><br><span class="line">    <span class="comment">// 设置文件状态选项，添加非阻塞模式</span></span><br><span class="line">    fcntl(fd1, F_SETFL, fd1_save|O_NONBLOCK);</span><br><span class="line"></span><br><span class="line">    fd2_save = fcntl(fd2, F_GETFL);</span><br><span class="line">    fcntl(fd2, F_SETFL, fd2_save|O_NONBLOCK);</span><br><span class="line">    <span class="comment">// 设置状态机</span></span><br><span class="line">    fsm12.state = STATE_R;</span><br><span class="line">    fsm12.sfd = fd1;</span><br><span class="line">    fsm12.dfd = fd2;</span><br><span class="line"></span><br><span class="line">    fsm21.state = STATE_R;</span><br><span class="line">    fsm21.sfd = fd2;</span><br><span class="line">    fsm21.dfd = fd1;</span><br><span class="line"></span><br><span class="line">    pfd[<span class="number">0</span>].fd = fd1;</span><br><span class="line">    pfd[<span class="number">1</span>].fd = fd2;</span><br><span class="line">    <span class="keyword">while</span>(fsm12.state != STATE_T || fsm21.state != STATE_T) {</span><br><span class="line">        <span class="comment">// 布置监视任务</span></span><br><span class="line">        pfd[<span class="number">0</span>].events = <span class="number">0</span>; <span class="comment">// 清空监视的事件</span></span><br><span class="line">        pfd[<span class="number">1</span>].events = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(fsm12.state == STATE_R) {</span><br><span class="line">            pfd[<span class="number">0</span>].events |= POLLIN; <span class="comment">// 监视是否可读</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(fsm12.state == STATE_W) {</span><br><span class="line">            pfd[<span class="number">1</span>].events |= POLLOUT;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(fsm21.state == STATE_R) {</span><br><span class="line">            pfd[<span class="number">1</span>].events |= POLLIN;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(fsm21.state == STATE_W) {</span><br><span class="line">            pfd[<span class="number">0</span>].events |= POLLOUT;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 监视</span></span><br><span class="line">        <span class="keyword">if</span>(fsm12.state &lt; STATE_AUTO || fsm21.state &lt; STATE_AUTO) {</span><br><span class="line">            <span class="keyword">if</span>(poll(pfd, <span class="number">2</span>, <span class="number">-1</span>) &lt; <span class="number">0</span>) { <span class="comment">// 阻塞监视</span></span><br><span class="line">                <span class="keyword">if</span>(errno == EINTR) {</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                }</span><br><span class="line">                perror(<span class="string">"poll()"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// poll返回后，查看监视结果</span></span><br><span class="line">        <span class="comment">// 用按位与</span></span><br><span class="line">        <span class="keyword">if</span>(pfd[<span class="number">0</span>].revents &amp; POLLIN || pfd[<span class="number">1</span>].revents &amp; POLLOUT || fsm12.state &gt; STATE_AUTO) {</span><br><span class="line">            fsm_driver(&amp;fsm12);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(pfd[<span class="number">1</span>].revents &amp; POLLIN || pfd[<span class="number">0</span>].revents &amp; POLLOUT || fsm21.state &gt; STATE_AUTO) {</span><br><span class="line">            fsm_driver(&amp;fsm21);</span><br><span class="line">        }</span><br><span class="line">    }    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 恢复用户设置的文件状态</span></span><br><span class="line">    fcntl(fd1, F_SETFL, fd1_save);</span><br><span class="line">    fcntl(fd2, F_SETFL, fd2_save);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>同样不会出现盲等现象。</p>
<h4 id="9-4-3-epoll"><a href="#9-4-3-epoll" class="headerlink" title="9.4.3 epoll"></a>9.4.3 epoll</h4><p>select和poll在需要我们在用户态创建监视文件描述符的集合（<code>fd_set</code>和<code>pollfd</code>，底层分别采用数组和链表存储，因此前者有大小限制，后者没有），调用时，需要将该集合复制到内核空间中，这样内核才能帮助我们轮询fd，这个过程具有一定开销。</p>
<p>epoll则只提供这个集合创建、控制相关的接口，调用时，直接在内核空间创建监视fd的集合，因此去除了复制过程开销。过程如下：</p>
<p><a href="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/1d9b9756bbdedb14e683b20c87d1577e89f4efb9.png@942w_573h_progressive.webp" data-fancybox="gallery" data-caption="img" data-thumb="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/1d9b9756bbdedb14e683b20c87d1577e89f4efb9.png@942w_573h_progressive.webp"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/1d9b9756bbdedb14e683b20c87d1577e89f4efb9.png@942w_573h_progressive.webp" alt="img"></a></p>
<p>相关调用：<code>epoll_create</code>，<code>epoll_ctl</code>，<code>epoll_wait</code></p>
<blockquote>
<p><code>epoll_create</code></p>
</blockquote>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p>参数：调用 epoll_create 时<strong>最初</strong> size 参数给传入多少，内核在建立数组的时候就是多少个元素。后来改进为只要 size 传入一个正整数即可，内核不会再根据传入的 size 直接作为数组的长度，因为内核是使用 hash 来管理要监视的文件描述符的。</p>
<p>作用和返回值：该函数会创建一个 epoll 实例（或epoll对象），同时返回一个引用该实例的<strong>文件描述符</strong>。<strong>返回的文件描述符仅仅指向对应的 epoll 实例</strong>，并不表示真实的磁盘文件节点。其他 API 如 epoll_ctl、epoll_wait 会使用这个文件描述符来操作相应的 epoll 实例，需要手动释放这个文件描述符。</p>
<p>一个epoll对象都有一个独立的eventpoll结构体，结构体如下：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> {</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/*红黑树的根节点，这颗树存储着所有添加到epoll中的需要监控的事件*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span>  <span class="title">rbr</span>;</span></span><br><span class="line">    <span class="comment">/*双链表存储所有就绪的文件描述符*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">rdlist</span>;</span></span><br><span class="line">    ...</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>epoll 实例内部存储：</p>
<ul>
<li>监听列表：所有要监听的文件描述符，使用红黑树，由 epoll_ctl 传来</li>
<li>就绪列表：所有就绪的文件描述符，使用双向链表</li>
</ul>
<blockquote>
<p><code>epoll_ctl</code></p>
</blockquote>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> {</span></span><br><span class="line">       <span class="keyword">uint32_t</span> events; <span class="comment">/* Epoll 监视的事件，这些事件与 poll 能监视的事件差不多，只是宏名前面加了个E */</span></span><br><span class="line">       <span class="keyword">epoll_data_t</span> data; <span class="comment">/* 用户数据，除了能保存文件描述符以外，还能让你保存一些其它有关数据，比如你这个文件描述符是嵌在一棵树上的，你在使用它的时候不知道它是树的哪个节点，则可以在布置监视任务的时候将相关的位置都保存下来。这个联合体成员就是 epoll 设计的精髓。 */</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span> {</span></span><br><span class="line">    <span class="keyword">void</span>        *ptr;</span><br><span class="line">    <span class="keyword">int</span>          fd;</span><br><span class="line">    <span class="keyword">uint32_t</span>     u32;</span><br><span class="line">    <span class="keyword">uint64_t</span>     u64;</span><br><span class="line">} <span class="keyword">epoll_data_t</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>参数和返回值：</p>
<ul>
<li><code>epfd</code> 即 epoll_create 返回的文件描述符，指向一个 epoll 实例</li>
<li><code>fd</code> 表示要监听的目标文件描述符</li>
<li><code>event</code> 表示要监听的事件（可读、可写、发送错误…）</li>
<li><p><code>op</code> 表示要对 fd 执行的操作，有以下几种：</p>
<ul>
<li><code>EPOLL_CTL_ADD</code>：为 fd 添加一个监听事件 event</li>
<li><code>EPOLL_CTL_MOD</code>：event 是一个结构体变量，这相当于变量 event 本身没变，但是更改了其内部字段的值</li>
<li><code>EPOLL_CTL_DEL</code>：删除 fd 的所有监听事件，这种情况下 event 参数没用</li>
</ul>
</li>
<li><p>返回值 0 或 -1，表示上述操作成功与否。</p>
</li>
</ul>
<p>作用：epoll_ctl 会将文件描述符 fd 添加到 epoll 实例的监听列表里，同时为 fd 设置一个回调函数，并监听事件 
event，如果红黑树中已经存在立刻返回。当 fd 上发生相应事件时，会调用回调函数，将 fd 添加到 epoll 实例的就绪队列上。</p>
<blockquote>
<p><code>epoll_wait</code></p>
</blockquote>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event *events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p>参数和返回值：</p>
<ul>
<li><code>epfd</code>：要操作的 epoll 实例；</li>
<li><code>events</code> 是一个数组，保存就绪状态的文件描述符，其空间由调用者负责申请</li>
<li><code>maxevents</code> 指定 events 的大小</li>
<li><code>timeout</code> 类似于 select 中的 timeout。如果没有文件描述符就绪，即就绪队列为空，则 
epoll_wait 会阻塞 timeout 毫秒。如果 timeout 设为 -1，则 epoll_wait 
会一直阻塞，直到有文件描述符就绪；如果 timeout 设为 0，则 epoll_wait 会立即返回</li>
<li>返回值表示 events 中存储的就绪描述符个数，最大不超过 maxevents。</li>
</ul>
<blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">relay</span><span class="params">(<span class="keyword">int</span> fd1, <span class="keyword">int</span> fd2)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> fd1_save, fd2_save;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fsm_st</span> <span class="title">fsm12</span>, <span class="title">fsm21</span>;</span></span><br><span class="line">    <span class="keyword">int</span> epfd; <span class="comment">// epoll对象的文件描述符</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">    <span class="comment">// 获取文件状态选项</span></span><br><span class="line">    fd1_save = fcntl(fd1, F_GETFL);</span><br><span class="line">    <span class="comment">// 设置文件状态选项，添加非阻塞模式</span></span><br><span class="line">    fcntl(fd1, F_SETFL, fd1_save|O_NONBLOCK);</span><br><span class="line"></span><br><span class="line">    fd2_save = fcntl(fd2, F_GETFL);</span><br><span class="line">    fcntl(fd2, F_SETFL, fd2_save|O_NONBLOCK);</span><br><span class="line">    <span class="comment">// 设置状态机</span></span><br><span class="line">    fsm12.state = STATE_R;</span><br><span class="line">    fsm12.sfd = fd1;</span><br><span class="line">    fsm12.dfd = fd2;</span><br><span class="line"></span><br><span class="line">    fsm21.state = STATE_R;</span><br><span class="line">    fsm21.sfd = fd2;</span><br><span class="line">    fsm21.dfd = fd1;</span><br><span class="line"></span><br><span class="line">    epfd = epoll_create(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span>(epfd &lt; <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">"epoll_create()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    ev.events = <span class="number">0</span>; <span class="comment">// 清空监听的事件</span></span><br><span class="line">    ev.data.fd = fd1; <span class="comment">// 设置监听的文件描述符</span></span><br><span class="line">    epoll_ctl(epfd, EPOLL_CTL_ADD, fd1, &amp;ev); <span class="comment">// 将fd1添加到epfd的监听列表里，同时为 fd 设置一个回调函数，并监听事件 event</span></span><br><span class="line"></span><br><span class="line">    ev.events = <span class="number">0</span>;</span><br><span class="line">    ev.data.fd = fd2;</span><br><span class="line">    epoll_ctl(epfd, EPOLL_CTL_ADD, fd2, &amp;ev);</span><br><span class="line">    <span class="keyword">while</span>(fsm12.state != STATE_T || fsm21.state != STATE_T) {</span><br><span class="line">        <span class="comment">// 布置监视任务</span></span><br><span class="line">        ev.events = <span class="number">0</span>;</span><br><span class="line">        ev.data.fd = fd1;</span><br><span class="line">        <span class="keyword">if</span>(fsm12.state == STATE_R) {</span><br><span class="line">            ev.events |= EPOLLIN;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(fsm21.state == STATE_W) {</span><br><span class="line">            ev.events |= EPOLLOUT;</span><br><span class="line">        }</span><br><span class="line">        epoll_ctl(epfd, EPOLL_CTL_MOD, fd1, &amp;ev);</span><br><span class="line"></span><br><span class="line">        ev.events = <span class="number">0</span>;</span><br><span class="line">        ev.data.fd = fd2;</span><br><span class="line">        <span class="keyword">if</span>(fsm12.state == STATE_W) {</span><br><span class="line">            ev.events |= EPOLLOUT;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(fsm21.state == STATE_R) {</span><br><span class="line">            ev.events |= EPOLLIN;</span><br><span class="line">        }</span><br><span class="line">        epoll_ctl(epfd, EPOLL_CTL_MOD, fd2, &amp;ev);</span><br><span class="line">        <span class="comment">// 监视</span></span><br><span class="line">        <span class="keyword">if</span>(fsm12.state &lt; STATE_AUTO || fsm21.state &lt; STATE_AUTO) {</span><br><span class="line">            <span class="keyword">if</span>(epoll_wait(epfd, &amp;ev, <span class="number">1</span>, <span class="number">-1</span>) &lt; <span class="number">0</span>) { <span class="comment">// 阻塞监视</span></span><br><span class="line">                <span class="keyword">if</span>(errno == EINTR) {</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                }</span><br><span class="line">                perror(<span class="string">"epoll_wait()"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 查看监视结果</span></span><br><span class="line">        <span class="keyword">if</span>(ev.data.fd == fd1 &amp;&amp; ev.events &amp; EPOLLIN \</span><br><span class="line">            || ev.data.fd == fd2 &amp;&amp; ev.events &amp; EPOLLOUT \</span><br><span class="line">            || fsm12.state &gt; STATE_AUTO) {</span><br><span class="line">            fsm_driver(&amp;fsm12);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(ev.data.fd == fd2 &amp;&amp; ev.events &amp; EPOLLIN \</span><br><span class="line">            || ev.data.fd == fd1 &amp;&amp; ev.events &amp; EPOLLIN \</span><br><span class="line">            || fsm12.state &gt; STATE_AUTO) {</span><br><span class="line">            fsm_driver(&amp;fsm21);</span><br><span class="line">        }</span><br><span class="line">    }    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 恢复用户设置的文件状态</span></span><br><span class="line">    fcntl(fd1, F_SETFL, fd1_save);</span><br><span class="line">    fcntl(fd2, F_SETFL, fd2_save);</span><br><span class="line">    close(epfd);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>三者区别</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>select</th>
<th>poll</th>
<th>epoll</th>
</tr>
</thead>
<tbody>
<tr>
<td>底层数据结构</td>
<td>数组存储文件描述符</td>
<td>链表存储文件描述符</td>
<td>红黑树存储监控的文件描述符，双链表存储就绪的文件描述符</td>
</tr>
<tr>
<td>如何从fd数据中获取就绪的fd</td>
<td>遍历fd_set</td>
<td>遍历链表</td>
<td>回调</td>
</tr>
<tr>
<td>时间复杂度</td>
<td>获得就绪的文件描述符需要遍历fd数组，O(n)</td>
<td>获得就绪的文件描述符需要遍历fd链表，O(n)</td>
<td>当有就绪事件时，系统注册的回调函数就会被调用，将就绪的fd放入到就绪链表中。O(1)</td>
</tr>
<tr>
<td>FD数据拷贝</td>
<td>每次调用select，需要将fd数据从用户空间拷贝到内核空间</td>
<td>每次调用poll，需要将fd数据从用户空间拷贝到内核空间</td>
<td>使用内存映射(mmap)，不需要从用户空间频繁拷贝fd数据到内核空间</td>
</tr>
<tr>
<td>最大连接数</td>
<td>有限制，一般为1024</td>
<td>无限制</td>
<td>无限制</td>
</tr>
</tbody>
</table>
</div>
<h3 id="9-5-其它IO函数"><a href="#9-5-其它IO函数" class="headerlink" title="9.5 其它IO函数"></a>9.5 其它IO函数</h3><p>暂略</p>
<h3 id="9-6-存储映射IO"><a href="#9-6-存储映射IO" class="headerlink" title="9.6 存储映射IO"></a>9.6 存储映射IO</h3><p>暂略</p>
<h2 id="10-进程间通信"><a href="#10-进程间通信" class="headerlink" title="10 进程间通信"></a>10 进程间通信</h2><p>对应APUE第十五章——进程间通信。</p>
<p>进程间通信（<code>IPC</code>，<code>InterProcess Communication</code>）分为：</p>
<ul>
<li><code>PIPE</code>（管道）</li>
<li><code>Socket</code>（套接字）</li>
<li><code>XSI</code>（System V）<ul>
<li>消息队列</li>
<li>信号量数组</li>
<li>共享内存</li>
</ul>
</li>
</ul>
<p>这些手段都是用于进程间通讯的，只有进程间通讯才需要借助第三方机制，线程之间的通讯是不需要借助第三方机制的，因为线程之间的地址空间是共享的。</p>
<h3 id="10-1-管道"><a href="#10-1-管道" class="headerlink" title="10.1 管道"></a>10.1 管道</h3><p>管道是UNIX系统IPC的最古老形式，所有UNIX系统都提供此种通信机制，管道有以下两种局限性。</p>
<ol>
<li>历史上，它们是半双工的（即数据只能在一个方向上流动），现在，某些系统提供全双工管道。</li>
<li><strong>管道只能在具有公共祖先的两个进程之间使用</strong>。通常，一个管道由一个进程创建，在进程调用fork之后，这个管道就能在父进程和子进程之间使用了。</li>
</ol>
<p>尽管有这两种局限性，半双工管道仍是最常用的IPC形式。每当在管道中键入一个命令序列，让shell执行时，shell都会为每一条命令单独创建一个进程，然后用管道将前一条命令进程的标准输出与后一条命令的标准输入相连接。</p>
<p>管道分为命名管道（FIFO）和匿名管道（PIPE），无论是哪种管道，都是由内核帮你创建和维护的。</p>
<h4 id="10-1-1-匿名管道"><a href="#10-1-1-匿名管道" class="headerlink" title="10.1.1 匿名管道"></a>10.1.1 匿名管道</h4><p>匿名管道是通过调用pipe函数创建的。</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> pipefd[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p><code>pipefd</code> 是一个数组，表示管道的两端文件描述符，<code>pipefd[0]</code> 端作为读端，<code>pipefd[1]</code> 端作为写端。</p>
<p><code>pipe</code>产生的是<strong>匿名管道</strong>，在磁盘的任何位置上找不到这个管道文件，而且匿名管道只能用于具有亲缘关系的进程之间通信。一般情况有亲缘关系的进程之间使用管道进行通信时，会把自己不用的一端文件描述符关闭。</p>
<p><a href="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/c49d573cd7a94f7db43c268c1aa7e9d8.png" data-fancybox="gallery" data-caption="img" data-thumb="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/c49d573cd7a94f7db43c268c1aa7e9d8.png"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/c49d573cd7a94f7db43c268c1aa7e9d8.png" alt="img"></a></p>
<p>注意：子进程打开的文件描述符与父进程的一致。</p>
<blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFSIZE        1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> pd[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">char</span> buf[BUFSIZE];</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建匿名管道</span></span><br><span class="line">    <span class="keyword">if</span>(pipe(pd) &lt; <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">"pipe()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">"fork()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>) { <span class="comment">// 子进程 读取管道数据</span></span><br><span class="line">        <span class="comment">// 关闭写端</span></span><br><span class="line">        close(pd[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 从管道中读取数据，如果子进程比父进程先被调度会阻塞等待数据写入</span></span><br><span class="line">        len = read(pd[<span class="number">0</span>], buf, BUFSIZE);</span><br><span class="line">        <span class="built_in">puts</span>(buf);</span><br><span class="line">        <span class="comment">// 管道是fork之前创建的，父子进程里都有一份，所以退出之前要确保管道两端都关闭</span></span><br><span class="line">        close(pd[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    } <span class="keyword">else</span> { <span class="comment">// 父进程 向管道写入数据</span></span><br><span class="line">        <span class="comment">// 关闭读端</span></span><br><span class="line">        close(pd[<span class="number">0</span>]);</span><br><span class="line">        write(pd[<span class="number">1</span>], <span class="string">"Hello!"</span>, <span class="number">6</span>);</span><br><span class="line">        close(pd[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 等待子进程退出</span></span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// never reached</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="10-1-2-命名管道"><a href="#10-1-2-命名管道" class="headerlink" title="10.1.2 命名管道"></a>10.1.2 命名管道</h4><p><code>mkfifo</code>函数用于创建命名管道，作用与匿名管道相同，不过可以在不同的进程之间使用，相当于对一个普通文件进行读写操作就可以了。</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>pathname</code>：管道文件的路径和文件名。</li>
<li><code>mode</code>：创建管道文件的权限。该mode还需要和umask做并运算来确定最后的管道文件权限。</li>
<li>返回值：成功返回 0，失败返回 -1 并设置 errno</li>
</ul>
<p>当用mkfifo创建FIFO时，要用<code>open</code>来打开它。</p>
<p>FIFO有以下两种用途：</p>
<ul>
<li>shell命令使用FIFO将数据从一条管道传送到另一条时，无需创建中间临时文件</li>
<li>客户进程-服务器进程应用程序中，FIFO 用作汇聚点，在客户进程和服务器进程二者之间传递数据。</li>
</ul>
<hr>
<p>可以使用命令，来创建管道文件：</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfifo filename</span><br></pre></td></tr></tbody></table></figure>
<p>例如：</p>
<p><a href="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20230307140848686.png" data-fancybox="gallery" data-caption="image-20230307140848686" data-thumb="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20230307140848686.png"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20230307140848686.png" alt="image-20230307140848686"></a></p>
<p>由第一位<code>p</code>可知其为一个管道文件。</p>
<blockquote>
<p>代码示例1</p>
</blockquote>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PATHNAME    <span class="meta-string">"/tmp/myfifo"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFSIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> fd = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[BUFSIZE] = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个命名管道，用 ls -l 命令查看这个管道文件的属性</span></span><br><span class="line">    <span class="keyword">if</span> (mkfifo(PATHNAME, <span class="number">0644</span>) &lt; <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">"mkfifo()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    fflush(<span class="literal">NULL</span>);</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">"fork()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) { <span class="comment">// 父进程</span></span><br><span class="line">        pid = fork(); <span class="comment">// 再次产生一个子进程</span></span><br><span class="line">        <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) {</span><br><span class="line">            perror(<span class="string">"fork()"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) { <span class="comment">// 父进程</span></span><br><span class="line">            <span class="comment">// 两个子进程都创建完之后父进程直接退出，使两个子进程不具有亲缘关系。</span></span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">/* 子进程2 */</span></span><br><span class="line">        <span class="comment">/* 像操作普通文件一样对这个管道进行 open(2)、read(2)、write(2)、close(2) */</span></span><br><span class="line">        fd = open(PATHNAME, O_RDWR);</span><br><span class="line">        <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) {</span><br><span class="line">            perror(<span class="string">"open()"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        read(fd, buf, BUFSIZE); <span class="comment">// 读管道，如果没有数据会阻塞</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s"</span>, buf);</span><br><span class="line">        write(fd, <span class="string">" World!"</span>, <span class="number">8</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    } <span class="keyword">else</span> { <span class="comment">// 子进程1</span></span><br><span class="line">        fd = open(PATHNAME, O_RDWR);</span><br><span class="line">        <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) {</span><br><span class="line">            perror(<span class="string">"open()"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        write(fd, <span class="string">"Hello"</span>, <span class="number">6</span>);</span><br><span class="line">        sleep(<span class="number">1</span>); <span class="comment">// 刚写完管道不要马上读，等第二个进程读取完并且写入新数据之后再读。</span></span><br><span class="line">        read(fd, buf, BUFSIZE);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="built_in">puts</span>(buf);</span><br><span class="line">        <span class="comment">// 肯定是这个进程最后退出，所以把管道文件删除，不然下次再创建的时候会报文件已存在的错误</span></span><br><span class="line">        remove(PATHNAME);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>子进程1在写完管道之后要先休眠，等待子进程2从管道的另一端把数据读入并写入新的数据，子进程1再醒来读出管道的内容。如果子进程1不休眠而是在
写完之后马上读管道，很可能在它写完管道之后子进程2还没来得及调度，它自己就又把管道里的数据读出来了，这样不仅读出来的不是子进程2写入的数据，还会
导致子进程2永远阻塞在 read ，因为管道中不会再有数据写入。</p>
<p>可能的过程：</p>
<figure class="highlight plaintext"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">plaintext</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">子进程2 read 阻塞 --&gt; 子进程1写Hello --&gt; 子进程1休眠 --&gt; 子进程2读Hello --&gt; 子进程1 read 阻塞 --&gt; 子进程2写 World! --&gt; 子进程1读 World!</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>代码示例2</p>
</blockquote>
<ul>
<li><code>comm.h</code></li>
</ul>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MY_FIFO <span class="meta-string">"./fifo"</span></span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>server.c</code></li>
</ul>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"comm.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFSIZE 1024</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    umask(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(mkfifo(MY_FIFO, <span class="number">0666</span>) &lt; <span class="number">0</span>) { <span class="comment">//创建命名管道</span></span><br><span class="line">    	perror(<span class="string">"mkfifo"</span>);</span><br><span class="line">    	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只需要文件操作即可</span></span><br><span class="line">    <span class="keyword">int</span> fd = open(MY_FIFO, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>) {</span><br><span class="line">    	perror(<span class="string">"open"</span>);</span><br><span class="line">    	<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 业务逻辑</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">char</span> buffer[BUFSIZE];</span><br><span class="line">        <span class="keyword">ssize_t</span> s = read(fd, buffer, BUFSIZE<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(s &gt; <span class="number">0</span>) {</span><br><span class="line">            buffer[s] = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"client-&gt; %s\n"</span>, buffer);</span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">if</span>(s == <span class="number">0</span>) {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"client quit...\n"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }<span class="keyword">else</span> {</span><br><span class="line">            perror(<span class="string">"read"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>client.c</code></li>
</ul>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"comm.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFSIZE 1024</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> fd = open(MY_FIFO, O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">"open"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 业务逻辑</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">   		<span class="built_in">printf</span>(<span class="string">"请输入-&gt; "</span>);</span><br><span class="line">    	fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    	<span class="keyword">char</span> buffer[BUFSIZE];</span><br><span class="line">    	<span class="keyword">ssize_t</span> s = read(<span class="number">0</span>, buffer, BUFSIZE<span class="number">-1</span>);</span><br><span class="line">    	<span class="keyword">if</span>(s &gt; <span class="number">0</span>) {</span><br><span class="line">            buffer[s<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">    		write(fd, buffer, <span class="built_in">strlen</span>(buffer));</span><br><span class="line">    	}</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>执行结果：</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng proc]<span class="comment"># ./server</span></span><br><span class="line">client-&gt; 1</span><br><span class="line">client-&gt; Hello World!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@HongyiZeng proc]<span class="comment"># ./client </span></span><br><span class="line">请输入-&gt; 1</span><br><span class="line">请输入-&gt; Hello World!</span><br><span class="line">请输入-&gt; </span><br></pre></td></tr></tbody></table></figure>
<h3 id="10-2-XSI-IPC"><a href="#10-2-XSI-IPC" class="headerlink" title="10.2 XSI IPC"></a>10.2 XSI IPC</h3><p><code>XSI IPC</code>函数是紧密地基于System V的IPC函数的。</p>
<p><code>system V</code>：同一主机内的进程间通信方案，在OS层面专门为进程间通信设计的方案。</p>
<p>system V标准下的三种通信方式：</p>
<ul>
<li>共享内存</li>
<li>消息队列</li>
<li>信号量</li>
</ul>
<h4 id="10-2-1-相关命令"><a href="#10-2-1-相关命令" class="headerlink" title="10.2.1 相关命令"></a>10.2.1 相关命令</h4><ul>
<li><code>ipcs</code>命令可以查看 XSI IPC 的使用情况。</li>
<li><code>ipcrm</code>命令可以删除指定的 XSI IPC。</li>
</ul>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng proc]<span class="comment"># ipcs</span></span><br><span class="line">------ Message Queues -------- <span class="comment"># 消息队列</span></span><br><span class="line">key        msqid      owner      perms      used-bytes   messages    </span><br><span class="line"></span><br><span class="line">------ Shared Memory Segments -------- <span class="comment"># 共享内存</span></span><br><span class="line">key        shmid      owner      perms      bytes      nattch     status      </span><br><span class="line"></span><br><span class="line">------ Semaphore Arrays -------- <span class="comment"># 信号量数组</span></span><br><span class="line">key        semid      owner      perms      nsems</span><br></pre></td></tr></tbody></table></figure>
<p>通过 ipcs 命令可以看出来，命令的输出结果分为三个部分，第一部分是系统中当前开辟的<strong>共享内存（shm）</strong>，第二部分是<strong>信号量数组（sem）</strong>，第三部分是<strong>消息队列（msg）</strong>。</p>
<p>可以看到，不论是哪一部分，都有一列叫做<code>key</code>，使用 XSI IPC 通信的进程就是通过同一个 key 
值操作同一个共享资源的。这个 key 是一个正整数，与文件描述符不同的是，生成一个新 key 
值时它不采用当前可用数值中的最小值，而是类似生成进程 ID 的方式，key 值连续的加 1，直至达到一个整数的最大正值，然后再回转到 0 
从头开始累加。</p>
<blockquote>
<p>不同IPC的特征比较</p>
</blockquote>
<p><a href="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20230307144926725.png" data-fancybox="gallery" data-caption="image-20230307144926725" data-thumb="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20230307144926725.png"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20230307144926725.png" alt="image-20230307144926725"></a></p>
<h4 id="10-2-2-标识符和键"><a href="#10-2-2-标识符和键" class="headerlink" title="10.2.2 标识符和键"></a>10.2.2 标识符和键</h4><p>每
个内核中的IPC结构（消息队列、信号量或共享存储）都用一个非负整数的标识符（identifier）加以引用。例如，要向一个消息队列发送消息或者从
一个消息队列取消息，只需要知道其队列标识符。标识符是IPC对象的内部名，为使多个合作进程能够在同一IPC对象上汇聚，需要提供一个外部命名方案。为
此，每个 IPC对象都与一个<strong>键</strong>（key）相关联，将这个键作为该对象的外部名。</p>
<p>无论何时创建IPC结构（通过调用msgget、semget或shmget 创建），都应指定一个键。这个键的数据类型是基本系统数据类型<code>key_t</code>，通常在头文件<code>&lt;sys/types.h&gt;</code>中被定义为长整型。<strong>这个键由内核变换成标识符</strong>。</p>
<p>有多种方法使客户进程和服务器进程在同一IPC结构上汇聚。</p>
<ul>
<li><p>方法1：服务器进程可以指定键<code>IPC_PRIVATE</code>创建一个新IPC结构，将返回的标识符存放在某处（如一个文件）以便客户进程取用。键<code>IPC_PRIVATE</code>保证服务器进程创建一个新IPC结构。这种技术的缺点是：文件系统操作需要服务器进程将整型标识符写到文件中，此后客户进程又要读这个文件取得此标识符。<code>IPC_PRIVATE</code>键也可用于父进程子关系。父进程指定<code>IPC_PRIVATE</code>创建一个新IPC结构，所返回的标识符可供fork后的子进程使用。接着，子进程又可将此标识符作为exec函数的一个参数传给一个新程序。</p>
</li>
<li><p>方法2：可以在一个公用头文件中定义一个客户进程和服务器进程都认可的键。然后服务器进程指定此键创建一个新的IPC结构。这种方法的问题
是该键可能已与一个IPC结构相结合，在此情况下，get 函数（msgget、semget 
或shmget）出错返回。服务器进程必须处理这一错误，删除已存在的IPC结构，然后试着再创建它。</p>
</li>
<li>方法3：客户进程和服务器进程认同一个路径名和项目ID（项目ID是0～255之间的字符值），接着，调用函数ftok将这两个值变换为一个键。然后在方法2中使用此键。ftok提供的唯一服务就是由一个路径名和项目ID产生一个键。</li>
</ul>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">key_t</span> <span class="title">ftok</span><span class="params">(<span class="keyword">const</span> chat *path, <span class="keyword">int</span> id)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p>path参数必须引用一个现有的文件。当产生键时，只使用id参数的低8位。对于不同文件的两个路径名，如果使用同一项目ID，可能产生相同的键。</p>
<p>3个get 函数（msgget、semget和shmget）都有两个类似的参数：一个key和一个整型flag。在创建新的IPC结构（通常由服务器进程创建）时，如果key是<code>IPC_PRIVATE</code>或者和当前某种类型的IPC结构无关，则需要指明 flag 的<code>IPC_CREAT</code>标志位。为了引用一个现有队列（通常由客户进程创建），key必须等于队列创建时指明的key的值，并且<code>IPC_CREAT</code>必须不被指明。</p>
<p>注意，决不能指定<code>IPC_PRIVATE</code>作为键来引用一个现有队列，因为这个特殊的键值总是用于创建一个新队列。</p>
<p>如果希望创建一个新的IPC结构，而且要确保没有引用具有同一标识符的一个现有IPC结构，那么必须在flag中同时指定<code>IPC_CREAT</code>和<code>IPC_EXCL</code>位。这样做了以后，如果IPC结构已经存在就会造成出错，返回<code>EEXTST</code>。</p>
<h4 id="10-2-3-消息队列"><a href="#10-2-3-消息队列" class="headerlink" title="10.2.3 消息队列"></a>10.2.3 消息队列</h4><p>消息队列是消息的链接表，存储在内核中，由消息队列标识符标识。</p>
<p>msg、sem 和 shm 都有一系列函数遵循下面的命名规则：</p>
<ul>
<li><code>xxxget()</code>：创建或引用，将key转换为标识符id</li>
<li><code>xxxop()</code>：相关操作</li>
<li><code>xxxctl()</code>：其它的控制或销毁</li>
</ul>
<hr>
<p>每个队列都有一个<code>msqid_ds</code>结构体与之关联：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msqid_ds</span> {</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> <span class="title">msg_perm</span>;</span> <span class="comment">// 保存ipc权限信息的结构体</span></span><br><span class="line">    <span class="keyword">msgqnum_t</span> msg_qnum;</span><br><span class="line">    <span class="keyword">msglen_t</span> msg_qbytes;</span><br><span class="line">    <span class="keyword">pid_t</span> msg_lspid;</span><br><span class="line">    <span class="keyword">pid_t</span> msg_lrpid;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>相关系统调用</p>
</blockquote>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// msgget - get a System V message queue identifier</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="comment">// 函数的作用是创建或引用一个消息队列，消息队列是双工的，两边都可以读写。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> msgflg)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>key</code>：IPC内核标识符的外部方案实现，拥有相同 key 的双方才可以通信。key 值必须是唯一的，<code>ftok</code> 函数可以用于获取 key</li>
<li><code>msgflg</code>：特殊要求，没有写0</li>
<li>返回：非负的队列ID或出错-1</li>
</ul>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 msgp 指向的结构体存放到 msgid 的消息队列中，这段空间有 msgz 个字节大小，msgz 的值要减掉强制的成员 mtype 的大小（sizeof(long)）。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgsnd</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">const</span> <span class="keyword">void</span> *msgp, <span class="keyword">size_t</span> msgsz, <span class="keyword">int</span> msgflg)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 msgid 这个消息队列中取出 msgp 结构体数据，msgp 的大小是 msgsz，msgflg 是特殊要求，没有特殊要求可以写 0。 </span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">msgrcv</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">void</span> *msgp, <span class="keyword">size_t</span> msgsz, <span class="keyword">long</span> msgtyp,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="keyword">int</span> msgflg)</span></span>;</span><br><span class="line"><span class="comment">// msgtyp可以指定接收哪一种信息“</span></span><br><span class="line"><span class="comment">// 0:  返回队列的第一个信息</span></span><br><span class="line"><span class="comment">// &gt;0: 返回队列中消息类型为 type 的第一个消息。</span></span><br><span class="line"><span class="comment">// &lt;0: 返回队列中消息类型值小于等于 type 绝对值的消息，如果这种消息有若干个，则取类型值最小的消息。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* msgp 指向的结构体的成员定义要类似 msgbuf 这个结构体，第一个成员必须是 long 类型的 mtype，并且必须是 &gt; 0 的值 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> {</span></span><br><span class="line">    <span class="keyword">long</span> mtype;       <span class="comment">/* 消息类型，必须 &gt; 0 */</span></span><br><span class="line">    <span class="keyword">char</span> mtext[<span class="number">512</span>];  <span class="comment">/* 消息数据字段 */</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="comment">// msqctl函数对队列执行多种操作。它和另外两个与信号量及共享存储有关的函数（semctl 和shmctl）都是XSI IPC的类似于ioctl的函数（亦即垃圾桶函数）。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgctl</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">int</span> cmd, struct msqid_ds *buf)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p>cmd参数指定对msqid指定的队列要执行的命令： </p>
<ul>
<li><code>IPC_STAT</code>：取此队列的<code>msqid_ds</code>结构，并将它存放在buf指向的结构中。</li>
<li><code>IPC_RMID</code>：从系统中删除该消息队列以及仍在该队列中的所有数据。这种删除立即生效。仍在使用这一消息队列的其
他进程在它们下一次试图对此队列进行操作时，将得到EIDRM错误。此命令只能由下列两种进程执行：一种是其有效用户ID等于msg_perm.cuid
或msg_perm.uid；另一种是具有超级用户特权的进程。</li>
</ul>
<blockquote>
<p>代码示例</p>
</blockquote>
<ul>
<li><code>proto.h</code>：定义双方都需要使用的数据或对象</li>
</ul>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __PROTO_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __PROTO_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NAMESIZE        32</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 通讯双方生成 key 值共同使用的文件 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEYPATH            <span class="meta-string">"/usr/local/linux_c/proc/key"</span></span></span><br><span class="line"><span class="comment">/* 通讯双方生成 key 值共同使用的 salt 值：0～255之间的字符值 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEYPROJ            <span class="meta-string">'a'</span></span></span><br><span class="line"><span class="comment">/* 消息类型，只要是大于 0 的合法整数即可 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSGTYPE            10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 通讯双方约定的协议 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_st</span> {</span></span><br><span class="line">    <span class="keyword">long</span> mtype; <span class="comment">// 消息类型</span></span><br><span class="line">    <span class="keyword">char</span> name[NAMESIZE]; <span class="comment">// 消息数据</span></span><br><span class="line">    <span class="keyword">int</span> math; <span class="comment">// 其他信息</span></span><br><span class="line">    <span class="keyword">int</span> chinese;</span><br><span class="line">};</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>snder.c</code>：客户端</li>
</ul>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"proto.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">key_t</span> key;</span><br><span class="line">    <span class="keyword">int</span> msgid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_st</span> <span class="title">sbuf</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置随机数种子</span></span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="comment">// 用与接收方相同的文件和 salt 生成一样的key，这样才可以通讯</span></span><br><span class="line">    key = ftok(KEYPATH, KEYPROJ);</span><br><span class="line">    <span class="keyword">if</span>(key &lt; <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">"ftok()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取得消息队列</span></span><br><span class="line">    msgid = msgget(key, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(msgid &lt; <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">"msgget()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为要发送的结构体赋值</span></span><br><span class="line">    sbuf.mtype = MSGTYPE;</span><br><span class="line">    <span class="built_in">strcpy</span>(sbuf.name, <span class="string">"Alan"</span>);</span><br><span class="line">    sbuf.math = rand() % <span class="number">100</span>;</span><br><span class="line">    sbuf.chinese = rand() % <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送结构体</span></span><br><span class="line">    <span class="keyword">if</span>(msgsnd(msgid, &amp;sbuf, <span class="keyword">sizeof</span>(sbuf)-<span class="keyword">sizeof</span>(<span class="keyword">long</span>), <span class="number">0</span>) &lt; <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">"msgsnd()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"ok!"</span>);</span><br><span class="line">    <span class="comment">// 消息队列不是发送方创建的，所以发送方不用负责销毁</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>rcver.c</code>：服务器</li>
</ul>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"proto.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">key_t</span> key;</span><br><span class="line">    <span class="keyword">int</span> msgid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_st</span> <span class="title">rbuf</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过文件和字符 'a' 生成唯一的 key，注意文件必须是真实存在的</span></span><br><span class="line">    key = ftok(KEYPATH,KEYPROJ);</span><br><span class="line">    <span class="keyword">if</span>(key &lt; <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">"ftok()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收端应该先启动，所以消息队列由接收端创建</span></span><br><span class="line">    msgid = msgget(key, IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">    <span class="keyword">if</span>(msgid &lt; <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">"msgget()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不停的接收消息</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">        <span class="comment">// 没有消息的时候会阻塞等待</span></span><br><span class="line">        <span class="keyword">if</span>(msgrcv(msgid, &amp;rbuf, <span class="keyword">sizeof</span>(rbuf)-<span class="keyword">sizeof</span>(<span class="keyword">long</span>), <span class="number">0</span>, <span class="number">0</span>) &lt; <span class="number">0</span>) {</span><br><span class="line">            perror(<span class="string">"msgrcv"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 用结构体中强制添加的成员判断消息类型，</span></span><br><span class="line"><span class="comment">         * 当然在这个例子中只有一种消息类型，所以不判断也可以。</span></span><br><span class="line"><span class="comment">         * 如果包含多种消息类型这里可以写一组 switch...case 结构</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span>(rbuf.mtype == MSGTYPE) {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Name = %s\n"</span>,rbuf.name);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Math = %d\n"</span>,rbuf.math);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Chinese = %d\n"</span>,rbuf.chinese);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 谁创建谁销毁。</span></span><br><span class="line"><span class="comment">     * 当然这个程序是无法正常结束的，只能通过信号杀死。</span></span><br><span class="line"><span class="comment">     * 使用信号杀死之后大家可以用 ipcs(1) 命令查看一下，消息队列应该是没有被销毁的，</span></span><br><span class="line"><span class="comment">     * 大家可以使用上面我们提到的 ipcrm(1) 命令把它删掉。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    msgctl(msgid, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>执行结果：</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng proc]<span class="comment"># ./rcver </span></span><br><span class="line">Name = Alan</span><br><span class="line">Math = 81</span><br><span class="line">Chinese = 36</span><br><span class="line"></span><br><span class="line">[root@HongyiZeng proc]<span class="comment"># ./snder </span></span><br><span class="line">ok!</span><br></pre></td></tr></tbody></table></figure>
<p>使用命令查看ipc并销毁：</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng proc]<span class="comment"># ipcs</span></span><br><span class="line">------ Message Queues --------</span><br><span class="line">key        msqid      owner      perms      used-bytes   messages    </span><br><span class="line">0x610125ef 0          root       600        0            0           </span><br><span class="line"></span><br><span class="line">------ Shared Memory Segments --------</span><br><span class="line">key        shmid      owner      perms      bytes      nattch     status      </span><br><span class="line"></span><br><span class="line">------ Semaphore Arrays --------</span><br><span class="line">key        semid      owner      perms      nsems</span><br><span class="line">[root@HongyiZeng proc]<span class="comment"># ipcrm -q 0</span></span><br><span class="line">[root@HongyiZeng proc]<span class="comment"># ipcs</span></span><br><span class="line">------ Message Queues --------</span><br><span class="line">key        msqid      owner      perms      used-bytes   messages    </span><br><span class="line"></span><br><span class="line">------ Shared Memory Segments --------</span><br><span class="line">key        shmid      owner      perms      bytes      nattch     status      </span><br><span class="line"></span><br><span class="line">------ Semaphore Arrays --------</span><br><span class="line">key        semid      owner      perms      nsems </span><br></pre></td></tr></tbody></table></figure>
<h4 id="10-2-4-信号量"><a href="#10-2-4-信号量" class="headerlink" title="10.2.4 信号量"></a>10.2.4 信号量</h4><p>信号量与已经介绍过的IPC（管道、FIFO以及消息列队）不同。它是一个计数器，用于为多个进程提供对共享数据对象的访问。</p>
<p>为了获得共享资源，进程需要执行下列操作：</p>
<ol>
<li>测试控制该资源的信号量。</li>
<li>若此信号量的值为正，则进程可以使用该资源。在这种情况下，进程会将信号量值减1，表示它使用了一个资源单位。</li>
<li>否则，若此信号量的值为0，则进程进入休眠状态，直至信号量值大于0。进程被唤醒后，它返回至步骤1。</li>
</ol>
<p>当进程不再使用由一个信号量控制的共享资源时，该信号量值增1。如果有进程正在休眠等待此信号量，则唤醒它们。</p>
<p>为了正确地实现信号量，信号量值的测试及减1操作应当是<strong>原子操作</strong>。为此，信号量通常是在内核中实现的。</p>
<p>常用的信号最形式被称为二元信号量（binary semaphore）。它控制单个资源，其初始值为1。但是，一般而言，信号量的初值可以是任意一个正值，该值表明有多少个共享资源单位可供共享应用。</p>
<blockquote>
<p>相关系统调用</p>
</blockquote>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建或获得一个信号量id</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> nsems, <span class="keyword">int</span> semflg)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>key</code>：具有亲缘关系的进程之间可以使用一个匿名的 key 值，key 使用宏 <code>IPC_PRIVATE</code> 即可。</li>
<li><code>nsems</code>：表示有多少个信号。信号量实际上是一个计数器，所以如果设置为 1 可以用来模拟互斥量。</li>
<li><code>semflg</code>：<code>IPC_CREAT</code> 表示创建信号量，同时需要按位或一个权限，如果是匿名 IPC 则无需指定这个宏，直接给权限就行了。</li>
<li>成功返回 sem  ID，失败返回 -1 并设置 errno。</li>
</ul>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="comment">// 用来控制或销毁信号量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semctl</span><span class="params">(<span class="keyword">int</span> semid, <span class="keyword">int</span> semnum, <span class="keyword">int</span> cmd, ...)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>semid</code>：信号量id</li>
<li><code>semnum</code>：信号量数组的下标</li>
</ul>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="comment">// 操作信号量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semop</span><span class="params">(<span class="keyword">int</span> semid, struct sembuf *sops, <span class="keyword">unsigned</span> nsops)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> {</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> sem_num; <span class="comment">/* 对第几个资源（数组下标）操作 */</span></span><br><span class="line">    <span class="keyword">short</span> sem_op; <span class="comment">/* 取几个资源写负数几(不要写减等于)，归还几个资源就写正数几 */</span></span><br><span class="line">    <span class="keyword">short</span> sem_flg; <span class="comment">/* 特殊要求 */</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>sops</code>：结构体数组起始位置；</li>
<li><code>nsops</code>：结构体数组长度；</li>
<li>返回值：成功返回0，失败返回-1并设置 errno。</li>
</ul>
<blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROCNUM        20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FNAME        <span class="meta-string">"/tmp/out"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFSIZE        1024</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多个函数都要使用这个信号量 ID，所以定义为全局变量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> semid;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">P</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">op</span>;</span></span><br><span class="line"></span><br><span class="line">    op.sem_num = <span class="number">0</span>; <span class="comment">// 只有一个资源，所以数组下标是 0</span></span><br><span class="line">    op.sem_op = <span class="number">-1</span>; <span class="comment">// 取一个资源就减1</span></span><br><span class="line">    op.sem_flg = <span class="number">0</span>; <span class="comment">// 没有特殊要求</span></span><br><span class="line">    <span class="keyword">while</span>(semop(semid,&amp;op,<span class="number">1</span>) &lt; <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// 出现假错就重试</span></span><br><span class="line">        <span class="keyword">if</span>(errno != EINTR &amp;&amp; errno != EAGAIN) {</span><br><span class="line">            perror(<span class="string">"semop()"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">V</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">op</span>;</span></span><br><span class="line"></span><br><span class="line">    op.sem_num = <span class="number">0</span>;</span><br><span class="line">    op.sem_op = <span class="number">1</span>; <span class="comment">// 归还一个资源</span></span><br><span class="line">    op.sem_flg = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(semop(semid,&amp;op,<span class="number">1</span>) &lt; <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">if</span>(errno != EINTR &amp;&amp; errno != EAGAIN) {</span><br><span class="line">            perror(<span class="string">"semop()"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func_add</span><span class="params">()</span> </span>{</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">char</span> buf[BUFSIZE];</span><br><span class="line"></span><br><span class="line">    fp = fopen(FNAME,<span class="string">"r+"</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp == <span class="literal">NULL</span>) {</span><br><span class="line">        perror(<span class="string">"fopen()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先取得信号量在操作文件，取不到就阻塞等待，避免发生竞争</span></span><br><span class="line">    P();</span><br><span class="line">    fgets(buf,BUFSIZE,fp);</span><br><span class="line">    rewind(fp);</span><br><span class="line">    sleep(<span class="number">1</span>); <span class="comment">// 调试用，为了放大竞争，更容易看出来互斥量发挥了作用</span></span><br><span class="line">    <span class="built_in">fprintf</span>(fp,<span class="string">"%d\n"</span>,atoi(buf)+<span class="number">1</span>);</span><br><span class="line">    fflush(fp);</span><br><span class="line">    <span class="comment">// 操作结束之后归还信号量，让其它进程可以取得信号量</span></span><br><span class="line">    V();</span><br><span class="line">    fclose(fp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在具有亲缘关系的进程之间使用，所以设置为 IPC_PRIVATE 即可。</span></span><br><span class="line">    <span class="comment">// 另外想要实现互斥量的效果，所以信号量数量设置为 1 个即可。</span></span><br><span class="line">    semid = semget(IPC_PRIVATE, <span class="number">1</span>, <span class="number">0600</span>);</span><br><span class="line">    <span class="keyword">if</span>(semid &lt; <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">"semget()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 union semun.val 的值设置为 1</span></span><br><span class="line">    <span class="keyword">if</span>(semctl(semid, <span class="number">0</span>, SETVAL, <span class="number">1</span>) &lt; <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">"semctl()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 20 个子进程</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; PROCNUM ; i++) {</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid &lt; <span class="number">0</span>) {</span><br><span class="line">            perror(<span class="string">"fork()"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>) {   <span class="comment">// child</span></span><br><span class="line">        </span><br><span class="line">            func_add();</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; PROCNUM ; i++)</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁信号量</span></span><br><span class="line">    semctl(semid,<span class="number">0</span>,IPC_RMID);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="10-2-5-共享存储"><a href="#10-2-5-共享存储" class="headerlink" title="10.2.5 共享存储"></a>10.2.5 共享存储</h4><p>共享存储允许两个或多个进程共享一个给定的存储区。因为数据不需要在客户进程和服务器进程之间复制，所以<strong>这是最快的一种IPC</strong>。</p>
<p>使用共享存储时要掌握的唯一窍门是，在多个进程之间同步访问一个给定的存储区。若服务器进程正在将数据放入共享存储区，则在它做完这一操作之前，客户进程不应当去取这些数据。通常，信号量用于同步共享存储访问。（不过正如前节最后部分所述，也可以用记录锁或互斥量。）</p>
<p>我们已经看到了共享存储的一种形式，就是在多个进程将同一个文件映射到它们的地址空间的时候。XSI共享存储和内存映射的文件的不同之处在于，前者没有相关的文件。<strong>XSI共享存储段是内存的匿名段</strong>。</p>
<blockquote>
<p>相关系统调用</p>
</blockquote>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">size_t</span> size, <span class="keyword">int</span> shmflg)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">shmat</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">const</span> <span class="keyword">void</span> *shmaddr, <span class="keyword">int</span> shmflg)</span></span>;<span class="number">78</span> <span class="function"><span class="keyword">int</span> <span class="title">shmdt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *shmaddr)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmctl</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">int</span> cmd, struct shmid_ds *buf)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 申请的共享内存大小，单位是字节</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEMSIZE        1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">char</span> *str;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> shmid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有亲缘关系的进程 key 参数可以使用 IPC_PRIVATE 宏，并且创建共享内存 shmflg 参数不需要使用 IPC_CREAT 宏</span></span><br><span class="line">    shmid = shmget(IPC_PRIVATE, MEMSIZE, <span class="number">0600</span>);</span><br><span class="line">    <span class="keyword">if</span>(shmid &lt; <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">"shmget()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">"fork()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>) { <span class="comment">// 子进程</span></span><br><span class="line">        <span class="comment">// 关联共享内存</span></span><br><span class="line">        str = shmat(shmid,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(str == (<span class="keyword">void</span> *)<span class="number">-1</span>) {</span><br><span class="line">            perror(<span class="string">"shmat()"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 向共享内存写入数据</span></span><br><span class="line">        <span class="built_in">strcpy</span>(str,<span class="string">"Hello!"</span>);</span><br><span class="line">        <span class="comment">// 分离共享内存</span></span><br><span class="line">        shmdt(str);</span><br><span class="line">        <span class="comment">// 无需释放共享内存</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> { <span class="comment">// 父进程</span></span><br><span class="line">        <span class="comment">// 等待子进程结束再运行，因为需要读取子进程写入共享内存的数据</span></span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// 关联共享内存</span></span><br><span class="line">        str = shmat(shmid,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(str == (<span class="keyword">void</span> *)<span class="number">-1</span>) {</span><br><span class="line">            perror(<span class="string">"shmat()"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 直接把共享内存中的数据打印出来</span></span><br><span class="line">        <span class="built_in">puts</span>(str);</span><br><span class="line">        <span class="comment">// 分离共享内存</span></span><br><span class="line">        shmdt(str);</span><br><span class="line">        <span class="comment">// 释放共享内存</span></span><br><span class="line">        shmctl(shmid,IPC_RMID,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="11-网络套接字"><a href="#11-网络套接字" class="headerlink" title="11 网络套接字"></a>11 网络套接字</h2><p>本节对应APUE第十六章——网络IPC：套接字</p>
<h3 id="11-1-引言"><a href="#11-1-引言" class="headerlink" title="11.1 引言"></a>11.1 引言</h3><p>上
一章考察了各种UNIX系统所提供的经典进程间通信机制（IPC）：管道、FIFO、消息队列、信号量以及共享存储。这些机制允许在同一台计算机上运行的
进程可以相互通信。本章将考察不同计算机（通过网络相连）上的进程相互通信的机制：网络进程间通信（network IPC）。</p>
<p>在本章中，我们将描述套接字网络进程间通信接口，进程用该接口能够和其他进程通信，无论它们是在同一台计算机上还是在不同的计算机上。实际上，这正
是套接字接口的设计目标之一：同样的接口既可以用于计算机间通信，也可以用于计算机内通信。尽管套接口可以采用许多不同的网络协议进行通信，但本章的讨论
限制在因特网事实上的通信标准：<strong>TCP/IP协议栈</strong>。</p>
<h3 id="11-2-套接字描述符"><a href="#11-2-套接字描述符" class="headerlink" title="11.2 套接字描述符"></a>11.2 套接字描述符</h3><p>套
接字是一种通信机制（通信的两方的一种约定），socket屏蔽了各个协议的通信细节，提供了tcp/ip协议的抽象，对外提供了一套接口，通过这个接口
就可以统一、方便的使用tcp/ip协议的功能。这使得程序员无需关注协议本身，直接使用socket提供的接口来进行互联的不同主机间的进程的通信。我
们可以用套接字中的相关函数来完成通信过程。</p>
<p><a href="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20230309130959948.png" data-fancybox="gallery" data-caption="image-20230309130959948" data-thumb="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20230309130959948.png"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20230309130959948.png" alt="image-20230309130959948"></a></p>
<p>套接字是通信端点的抽象。正如使用文件描述符访问文件，应用程序用套接字描述符访问套接字。套接字描述符在UNIX系统中被当作是一种文件描述符。事实上，许多处理文件描述符的函数（如read和write）可以用于处理套接字描述符。</p>
<p>为创建一个套接字，调用socket函数：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>domain</code>：域，或者协议族，确定通信的特性。即采用什么协议来传输数据。<ul>
<li><code>AF_UNIX</code>、<code>AF_LOCAL</code>：本地协议；</li>
<li><code>AF_INET</code>：IPV4 协议；</li>
<li><code>AF_INET6</code>：IPV6 协议；</li>
<li><code>AF_IPX</code>：是非常古老的操作系统，出现在 TCP/IP 之前；</li>
<li><code>AF_NETLINK</code>：是用户态与内核态通信的协议；</li>
<li><code>AF_APPLETALK</code>：苹果使用的一个局域网协议；</li>
<li><code>AF_PACKET</code>：底层 socket 所用到的协议，比如抓包器所遵循的协议一定要在网卡驱动层，而不能在应用层，否则无法见到包封装的过程。再比如 ping 命令，想要实现 ping 命令就需要了解这个协议族。</li>
</ul>
</li>
<li><code>type</code>：确定套接字的类型，进一步确定通信特征。<ul>
<li><code>SOCK_STREAM</code>：<strong>流式套接字</strong>，特点是有序、可靠。有序、双工、基于连接的、以字节流为单位的。<ul>
<li><strong>可靠</strong>不是指不丢包，而是流式套接字保证只要你能接收到这个包，那么包中的数据的完整性一定是正确的。</li>
<li><strong>双工</strong>是指双方都能收发。</li>
<li><strong>基于连接的</strong>是指：通信双方是知道对方是谁。</li>
<li><strong>字节流</strong>是指数据没有明显的界限，一端数据可以分为任意多个包发送。</li>
</ul>
</li>
<li><code>SOCK_DGRAM</code>：<strong>报式套接字（数据报套接字）</strong>，无连接的，固定的最大长度，不可靠的消息。</li>
<li><code>SOCK_SEQPACKET</code>：提供有序、可靠、双向、基于连接的<strong>数据报通信</strong>。</li>
<li><code>SOCK_RAW</code>：原始的套接字，提供的是网络协议层的访问。</li>
<li><code>SOCK_RDM</code>：数据层的访问，不保证传输顺序。</li>
</ul>
</li>
<li><code>protocol</code>：具体使用哪个协议。在 domain 的协议族中每一个对应的 type 都有一个或多个协议，使用协议族中默认的协议可以填写0。</li>
<li>返回值：如果成功，返回套接字描述符；如果失败，返回 -1，并设置 errno。</li>
</ul>
<p>调用socket与调用open相类似。在两种情况下，均可获得用于I/O的文件描述符。当不再需要该文件描述符时，调用close来关闭对文件或套接字的访问，并且释放该描述符以便重新使用。</p>
<p>虽然套接字描述符本质上是一个文件描述符，但不是所有参数为文件描述符的函数都可以接受套接字描述符。图16-4总结了到目前为止所讨论的大多数以
文件描述符为参数的函数使用套接字描述符时的行为。未指定和由实现定义的行为通常意味着该函数对套接字描述符无效。例如lseek不能以套接字描述符为参
数，因为套接字不支持文件偏移量的概念。</p>
<p><a href="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20230308114158215.png" data-fancybox="gallery" data-caption="image-20230308114158215" data-thumb="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20230308114158215.png"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20230308114158215.png" alt="image-20230308114158215"></a></p>
<h3 id="11-3-制定协议"><a href="#11-3-制定协议" class="headerlink" title="11.3 制定协议"></a>11.3 制定协议</h3><h4 id="11-3-1-字节序"><a href="#11-3-1-字节序" class="headerlink" title="11.3.1 字节序"></a>11.3.1 字节序</h4><p>大端格式：低地址存放高位数据，高地址存放低位数据。</p>
<p>小端格式：低地址存放低位数据，高地址存放高位数据。</p>
<p>假设要存放的数据是 <code>0x30313233</code>，那么 33 是低位，30 是高位，在大端存储格式中，30 存放在低位，33 存放在高位；而在小端存储格式中，33 存放在低位，30 存放在高位。</p>
<p><a href="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/041752279239537.png" data-fancybox="gallery" data-caption="img" data-thumb="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/041752279239537.png"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/041752279239537.png" alt="img"></a></p>
<p>主机字节序：host</p>
<p>网络字节序：network</p>
<p>网络协议指定了字节序，因此异构计算机系统能够交换协议信息而不会被字节序所混淆。TCP/IP协议栈使用<strong>大端字节序</strong>。应用程序交换格式化数据时，字节序问题就会出现。对于TCP/IP，地址用网络字节序来表示，所以应用程序有时需要在处理器的字节序与网络字节序之间转换它们。例如，以一种易读的形式打印一个地址时，这种转换很常见。</p>
<p>对于TCP/IP应用程序，有4个用来在处理器字节序和网络字节序之间实施转换的函数：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 主机字节序转换为网络字节序</span></span><br><span class="line"><span class="comment">// 返回以网络字节序表示的32位整数</span></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">htonl</span><span class="params">(<span class="keyword">uint32_t</span> hostlong)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主机字节序转换为网络字节序</span></span><br><span class="line"><span class="comment">// 返回以网络字节序表示的16位整数</span></span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">htons</span><span class="params">(<span class="keyword">uint16_t</span> hostshort)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">ntohl</span><span class="params">(<span class="keyword">uint32_t</span> netlong)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">ntohs</span><span class="params">(<span class="keyword">uint16_t</span> netshort)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>h</code>表示主机字节序，</li>
<li><code>n</code>表示网络字节序。</li>
<li><code>l</code>表示长（即4字节）整数</li>
<li><code>s</code>表示短（即2字节）整数</li>
</ul>
<h4 id="11-3-2-对齐"><a href="#11-3-2-对齐" class="headerlink" title="11.3.2 对齐"></a>11.3.2 对齐</h4><p>以下面的结构体为例：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">float</span> f;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>在32位的机器上，各占用4，4，1共9个字节的大小。但是编译器会将其自动对齐，此时为12个字节。</p>
<p>对齐原因：</p>
<ul>
<li>平台原因： 不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。</li>
<li>性能原因： 数据结构(尤其是栈)应该尽可能地在自然边界上对齐。 原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。</li>
</ul>
<p>总体来说：结构体的内存对齐是<strong>拿空间来换取时间</strong>的做法。优点是提高了可移植性和cpu性能。</p>
<hr>
<p>网络传输的结构体中的成员都是紧凑的，所以不能地址对齐，需要在结构体外面增加 <code>__attribute__((packed))</code>。例如：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_st</span> {</span></span><br><span class="line">     <span class="keyword">uint8_t</span> name[NAMESIZE];</span><br><span class="line">     <span class="keyword">uint32_t</span> math;</span><br><span class="line">     <span class="keyword">uint32_t</span> chinese;</span><br><span class="line">}__attribute__((packed));</span><br></pre></td></tr></tbody></table></figure>
<h4 id="11-3-3-类型长度问题"><a href="#11-3-3-类型长度问题" class="headerlink" title="11.3.3 类型长度问题"></a>11.3.3 类型长度问题</h4><p>标准C并没有对int、char这样的基本数据类型占用多大字节做一个明确的规定，例如：</p>
<p>一个16位的机器上，int可能占2个字节；</p>
<p>一个32位的机器上，int可能占4个字节；</p>
<p>解决：使用<code>int32_t</code>、<code>uint32_t</code>、<code>int64_t</code>、<code>int8_t</code>、<code>uint8_t</code>等类型明确指定占用的位数。这些类型包含在头文件<code>&lt;stdint.h&gt;</code>中。</p>
<blockquote>
<p><code>stdint.h</code></p>
</blockquote>
<p><code>stdint.h</code>是c99中引进的一个标准C库的头文件。</p>
<p>C的整数类型有：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>最小大小（bits）</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>char</td>
<td>无要求</td>
<td>最小的可寻址单元，能包含基础字符集，大小无硬性要求，可能是signed或unsigned的，现在基本都是8 bits</td>
</tr>
<tr>
<td>short</td>
<td>16</td>
<td></td>
</tr>
<tr>
<td>int</td>
<td>16</td>
<td>没有要求要大于short</td>
</tr>
<tr>
<td>long</td>
<td>32</td>
<td></td>
</tr>
<tr>
<td>long long</td>
<td>64</td>
<td>C99 及以后支持</td>
</tr>
</tbody>
</table>
</div>
<p>每个类型都有signed和unsigned之分。</p>
<p>C99中引入了固定大小的整数类型，和字节数有关的类型，其中包括：</p>
<ul>
<li>定长类型<code>(u)intN_t</code>，比如 <code>int16_t</code>，<code>uint64_t</code> ，保证变量占用的内存空间一定，但是不保证能够无开销的进行无符号整数溢出，<strong>也不保证在任何平台和编译器中存在</strong>。</li>
<li>快速运算类型<code>(u)int_fastN_t</code>，比如<code>int_fast32_t</code>，会根据平台来
选择运算速度最快的大于N比特的类型，通常在AMD64下当N大于等于16时都是 
(u)int64_t，这样就没有必要保证完美的进行无开销的无符号整数溢出的行为，并且保证在任何编译器实现中都存在。通常它们都用于在寄存器中的运
算，你绝对不会想把它们存在内存里，这就要看：</li>
<li>空间优先类型<code>(u)int_leastN_t</code>，比如<code>int_least16_t</code>，会从定长类型中选择满足最小的至少为N的类型，保证一定存在，不保证一定为N比特.</li>
</ul>
<h4 id="11-3-4-主动端和被动端"><a href="#11-3-4-主动端和被动端" class="headerlink" title="11.3.4 主动端和被动端"></a>11.3.4 主动端和被动端</h4><p><a href="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/2979323-20221012162732620-991514705.png" data-fancybox="gallery" data-caption="img" data-thumb="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/2979323-20221012162732620-991514705.png"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/2979323-20221012162732620-991514705.png" alt="img"></a></p>
<p>Socket中主动端（客户端）和被动端（服务器）需要做的工作有：</p>
<blockquote>
<p>主动端——客户端</p>
</blockquote>
<ol>
<li>取得 Socket</li>
<li>给 Socket 关联绑定地址（可省略，不必与操作系统约定端口，由操作系统指定随机端口）</li>
<li>发/收消息</li>
<li>关闭 Socket</li>
</ol>
<blockquote>
<p>被动端——服务器</p>
</blockquote>
<ol>
<li>取得 Socket</li>
<li>给 Socket 关联地址</li>
<li>将Socket置为监听模式（如果是流式套接字）</li>
<li>接受连接（如果是流式套接字）</li>
<li>收/发消息</li>
<li>关闭 Socket</li>
</ol>
<h3 id="11-4-寻址"><a href="#11-4-寻址" class="headerlink" title="11.4 寻址"></a>11.4 寻址</h3><p>标识目标通信进程需要网络地址（IP）和端口号（port），前者标识网络上想与之通信的计算机，后者帮助标识特定的进程，因此需要将套接字与这两者进行绑定关联。</p>
<h4 id="11-4-1-地址格式"><a href="#11-4-1-地址格式" class="headerlink" title="11.4.1 地址格式"></a>11.4.1 地址格式</h4><p>一个地址（<code>IP+PORT</code>）标识一个特定通信域的套接字端点，地址格式与这个特定的通信域相关。为使不同格式地址能够传入到套接字函数，不同的地址结构会被强制转换成一个通用的地址结构 <code>sockaddr</code>：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> {</span></span><br><span class="line">	<span class="keyword">sa_family_t</span> sa_family; <span class="comment">// 协议族</span></span><br><span class="line">    <span class="keyword">char</span> sa_data[]; <span class="comment">// 变长地址</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>例如，因特网地址定义在<code>&lt;netinet/in.h&gt;</code>头文件中。在IPv4因特网域（AF_INET）中，套接字的地址用结构 <code>sockaddr_in</code>表示：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 地址</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> {</span> </span><br><span class="line">    <span class="keyword">sa_family_t</span> sin_family; <span class="comment">// 协议族</span></span><br><span class="line">    <span class="keyword">in_port_t</span> sin_port; <span class="comment">// 端口号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span> <span class="comment">// ipv4地址</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> {</span></span><br><span class="line">	<span class="keyword">uint32_t</span> s_addr; <span class="comment">// ipv4地址，是一个32位无符号的整数</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>有时，需要打印出能被人理解而不是计算机所理解的地址格式。BSD 网络软件包含函数<code>inet_addr</code>和<code>inet_ntoa</code>，用于二进制地址格式与点分十进制字符表示（a.b.c.d）之间的相互转换。但是这些函数仅适用于IPv4地址。有两个新函数<code>inet_ntop</code>和<code>inet_pton</code>具有相似的功能，而且同时支持IPv4地址和IPv6地址。</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="comment">// 将网络字节序的地址addr（一个uint32_t的大整数）转换为点分十进制的文本字符串格式str</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">inet_ntop</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">const</span> <span class="keyword">void</span> *restrcit addr, <span class="keyword">char</span> *<span class="keyword">restrict</span> str, <span class="keyword">socklen_t</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将点分十进制的文本字符串格式转换为网络字节序的地址（一个uint32_t的大整数），放在addr中</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">inet_pton</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">const</span> <span class="keyword">void</span> *restrcit str, <span class="keyword">char</span> *<span class="keyword">restrict</span> addr)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>domain</code>：协议族，仅支持以下两种：<ul>
<li><code>AF_INET</code>：IPV4 协议</li>
<li><code>AF_INET6</code>：IPV6 协议</li>
</ul>
</li>
<li><code>addr</code>：网络字节序的二进制地址</li>
<li><code>str</code>和<code>size</code>：指定存放转换后地址的位置和缓冲区大小，size的大小可设置为下面两个常数<ul>
<li><code>INET_ADDRSTRLEN</code>：它定义了足够大的空间来存放一个表示IPv4地址的文本字符串</li>
<li><code>INET6_ADDRSTRLEN</code> ：定义了足够大的空间来存放一个表示 IPv6 地址的文本字符串</li>
</ul>
</li>
</ul>
<h4 id="11-4-2-套接字与地址关联"><a href="#11-4-2-套接字与地址关联" class="headerlink" title="11.4.2 套接字与地址关联"></a>11.4.2 套接字与地址关联</h4><p>将一个客户端的套接字关联上一个地址没有多少新意，可以让系统选一个默认的地址。然而，对于服务器，需要给一个接收客户端请求的服务器套接字关联上一个众所周知的地址。客户端应有一种方法来发现连接服务器所需要的地址，最简单的方法就是服务器保留一个地址并且注册在<code>/etc/services</code>或者某个名字服务中。</p>
<p>使用bind函数来关联地址和套接字：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bind - bind a name to a socket</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span>          <span class="comment">/* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>sockfd</code>：套接字描述符</li>
<li><code>addr</code>：要绑定到套接字上的地址。该地址必须和创建套接字时的地址族所支持的格式相匹配。例如，创建套接字时指定的domain为<code>AF_INET</code>（ipv4），则传入的地址的结构体类型必须为<code>sockaddr_in</code>，详见<code>11.4.1节</code></li>
<li><code>addrlen</code>：addr 传递的地址结构体的长度。</li>
</ul>
<p>可以调用 <code>getsockname</code>函数来发现绑定到套接字上的地址：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockname</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *<span class="keyword">restrict</span> addr, <span class="keyword">socklen_t</span> *<span class="keyword">restrict</span> alenp)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p>如果套接字已经和对等方连接，可以调用 <code>getpeername</code> 函数来找到对方的地址：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getpeername</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *<span class="keyword">restrict</span> addr, <span class="keyword">socklen_t</span> *<span class="keyword">restrict</span> alenp)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<h3 id="11-5-建立连接"><a href="#11-5-建立连接" class="headerlink" title="11.5 建立连接"></a>11.5 建立连接</h3><p>如果要处理一个面向连接（流套接字）的网络服务，那么在开始交换数据以前，需要在请求服务的进程套接字（客户端）和提供服务的进程套接字（服务器）之间建立一个连接。</p>
<p>使用connect函数来建立连接：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> len)</span></span>;</span><br><span class="line"><span class="comment">// 成功返回0， 错误返回-1</span></span><br></pre></td></tr></tbody></table></figure>
<p>在connect中指定的地址是我们想与之通信的服务器地址。如果sockfd没有绑定到一个地址，connect会给调用者绑定一个默认地址。</p>
<p>服务器调用 <code>listen</code> 函数来宣告它<strong>愿意接受</strong>连接请求。</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</span><br><span class="line"><span class="comment">// 成功返回0， 错误返回-1</span></span><br></pre></td></tr></tbody></table></figure>
<p>参数 <code>backlog</code> 提供了一个提示，提示系统该进程所要入队的未完成连接请求数量。其实际值由系统决定，但上限由<code>&lt;sys/socket.h&gt;</code>中的<code>SOMAXCONN</code>指定。</p>
<p>一旦队列满，系统就会拒绝多余的连接请求，所以 backlog 的值应该基于服务器期望负载和处理量来选择，其中处理量是指接受连接请求与启动服务的数量。</p>
<p>一旦服务器调用了 listen，所用的套接字就能接收连接请求。</p>
<p>使用<code>accept</code>函数<strong>获得连接请求并建立连接</strong>。</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *<span class="keyword">restrict</span> addr, <span class="keyword">socklen_t</span> *<span class="keyword">restrict</span> len)</span></span>;</span><br><span class="line"><span class="comment">// 成功返回套接字描述符，失败返回-1</span></span><br></pre></td></tr></tbody></table></figure>
<p>函数accept所返回的文件描述符是套接字描述符，该描述符连接到调用connect的客户端。这个新的套接字描述符和原始套接字（<code>sockfd</code>）具有相同的套接字类型和地址族。但是传给 accept 的原始套接字没有关联到这个连接，而是继续保持可用状态并接收其他连接请求。</p>
<p>如果不关心客户端标识，可以将参数<code>addr</code>（对端地址）和<code>len</code>设为<code>NULL</code>。否则，在调用accept之前，将addr参数设为足够大的缓冲区来存放地址，并且将len指向的整数设为这个缓冲区的字节大小。返回时，accept会在缓冲区填充客户端的地址，并且更新指向len的整数来反映该地址的大小。</p>
<p>如果没有连接请求在等待，accept 会<strong>阻塞</strong>直到一个请求到来。如果 sockfd处于非阻塞模式，accept 会返回-1，并将 errno 设置为 <code>EAGAIN</code>。</p>
<p>如果服务器调用 accept，并且当前没有连接请求，服务器会阻塞直到一个请求到来，另外，服务器可以使用 poll或 select 来等待一个请求的到来。在这种情况下，一个带有等待连接请求的套接字会以可读的方式出现。</p>
<h3 id="11-6-套接字选项"><a href="#11-6-套接字选项" class="headerlink" title="11.6 套接字选项"></a>11.6 套接字选项</h3><p>套接字机制提供了两个套接字选项接口来控制套接字行为。一个接口用来设置选项，另一个接口可以查询选项的状态。</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="comment">// 成功返回0，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> optname, <span class="keyword">const</span> <span class="keyword">void</span> *optval, <span class="keyword">socklen_t</span> optlen)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>level</code>： 标识了选项应用的协议。<ul>
<li>如果选项是通用的套接字层次选项，则 level 设置成<code>SOL_SOCKET</code>。否则，level设置成控制这个选项的协议编号</li>
<li>对于TCP，level是<code>IPPROTO_TCP</code></li>
<li>对于IP，level是<code>IPPROTO_IP</code>。</li>
<li>下图总结了<strong>通用套接字</strong>层次选项。</li>
</ul>
</li>
</ul>
<p><a href="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20230310142807921.png" data-fancybox="gallery" data-caption="image-20230310142807921" data-thumb="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20230310142807921.png"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20230310142807921.png" alt="image-20230310142807921"></a></p>
<ul>
<li><code>optname</code>： 需设置的选项</li>
<li><code>optval</code>：根据选项的不同指向一个数据结构或者一个整数。一些选项是on/off开关。如果整数非0，则启用选项。如果整数为0，则禁止选项。</li>
<li><code>optlen</code>：指定了optval指向的对象的大小。</li>
</ul>
<p>可以使用 getsockopt 函数来查看选项的当前值：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="comment">// 成功返回0，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> optname, <span class="keyword">void</span> *optval, <span class="keyword">socklen_t</span> *optlen)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<h3 id="11-7-数据传输"><a href="#11-7-数据传输" class="headerlink" title="11.7 数据传输"></a>11.7 数据传输</h3><h4 id="11-7-1-发送和接收"><a href="#11-7-1-发送和接收" class="headerlink" title="11.7.1 发送和接收"></a>11.7.1 发送和接收</h4><p>发送数据，类似于write：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于有连接的流套接字</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">send</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以在无连接的报式套接字上指定一个目标地址</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sendto</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="keyword">const</span> struct sockaddr *dest_addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"><span class="comment">// 返回值是真正发送出去的数据的长度；出现错误返回 -1 并设置 errno。</span></span><br></pre></td></tr></tbody></table></figure>
<p>注意：即使 send 成功返回，也并不表示连接的另一端的进程就一定接收了数据。我们所能保证的只是当send成功返回时，数据已经被无错误地发送到网络驱动程序上。</p>
<p>接收数据，类似于read：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 流套接字</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recv</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报套接字</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recvfrom</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">                 struct sockaddr *src_addr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br><span class="line"><span class="comment">// 返回读到的字节数，若无可读数据或对等方已经结束，返回0，出错返回-1</span></span><br></pre></td></tr></tbody></table></figure>
<p>recv 函数一般用在流式（<code>SOCK_STREAM</code>）套接字中，而 recvfrom 则一般用在报式（<code>SOCK_DGRAM</code>）套接字中。</p>
<h4 id="11-7-2-报式套接字示例"><a href="#11-7-2-报式套接字示例" class="headerlink" title="11.7.2 报式套接字示例"></a>11.7.2 报式套接字示例</h4><h5 id="①-基本实现"><a href="#①-基本实现" class="headerlink" title="① 基本实现"></a>① 基本实现</h5><ul>
<li><code>proto.h</code></li>
</ul>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* proto.h */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __PROTO_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __PROTO_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RCVPORT <span class="meta-string">"1989"</span> <span class="comment">// 服务器的端口号，使用到时用atoi进行转换，原因：没有单位的数字1989没有意义，因此用字符串来代替</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NAMESIZE 13 <span class="comment">//为了测试数据对齐的问题，这里选择一个一定不对齐的数字</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 传输的结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_st</span> {</span></span><br><span class="line">    <span class="keyword">uint8_t</span> name[NAMESIZE];</span><br><span class="line">    <span class="keyword">uint32_t</span> math;</span><br><span class="line">    <span class="keyword">uint32_t</span> chinese;</span><br><span class="line">}__attribute__((packed)); <span class="comment">//告诉gcc编译器,不要对齐</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>rcver.c</code></li>
</ul>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* rcver.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"proto.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPSTRSIZE        64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    <span class="comment">// 套接字</span></span><br><span class="line">    <span class="keyword">int</span> sd;</span><br><span class="line">    <span class="comment">// laddr -- local address -- 本机地址</span></span><br><span class="line">    <span class="comment">// raddr -- remote address -- 对端地址</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">laddr</span>,<span class="title">raddr</span>;</span></span><br><span class="line">    <span class="comment">// 对端地址长度</span></span><br><span class="line">    <span class="keyword">socklen_t</span> raddr_len;</span><br><span class="line">    <span class="comment">// 接收到的结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_st</span> <span class="title">rbuf</span>;</span></span><br><span class="line">    <span class="comment">// 存储点分十进制字符串的数组</span></span><br><span class="line">    <span class="keyword">char</span> ipstr[IPSTRSIZE];</span><br><span class="line">	<span class="comment">// 创建协议为ipv4的报式套接字，0为默认协议，即UDP</span></span><br><span class="line">    sd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span><span class="comment">/*IPPROTO_UDP*/</span>);</span><br><span class="line">    <span class="keyword">if</span>(sd &lt; <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">"socket()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">	<span class="comment">// 本机地址的配置</span></span><br><span class="line">    laddr.sin_family = AF_INET;</span><br><span class="line">    <span class="comment">// ip地址和网络端口号是要通过网络发送过去的,所以需要考虑字节序的问题,也就是htons</span></span><br><span class="line">    laddr.sin_port = htons(atoi(RCVPORT));</span><br><span class="line">    <span class="comment">// 因为本机的ip地址有可能会变化,为了避免ip地址每一次变化,都要进来修改,所以给它匹配一个万能地址0.0.0.0</span></span><br><span class="line">    <span class="comment">// 对"0.0.0.0"的定义是any address.就是说在当前绑定阶段,本机的ip地址是多少,这四个0就会自动换成当前的ip地址.</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">"0.0.0.0"</span>, &amp;laddr.sin_addr.s_addr);</span><br><span class="line">	<span class="comment">// 关联地址和套接字</span></span><br><span class="line">    <span class="keyword">if</span>(bind(sd, (struct sockaddr *)&amp;laddr, <span class="keyword">sizeof</span>(laddr)) &lt; <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">"bind()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">	<span class="comment">// 这里一定要初始化对端地址的大小！</span></span><br><span class="line">    raddr_len = <span class="keyword">sizeof</span>(raddr);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">if</span>(recvfrom(sd, &amp;rbuf, <span class="keyword">sizeof</span>(rbuf), <span class="number">0</span>, (<span class="keyword">void</span> *)&amp;raddr, &amp;raddr_len) &lt; <span class="number">0</span>) {</span><br><span class="line">            perror(<span class="string">"recvfrom()"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">		<span class="comment">// 整数转点分十进制的字符串</span></span><br><span class="line">        inet_ntop(AF_INET, &amp;raddr.sin_addr, ipstr, IPSTRSIZE);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"---MESSAGE FROM %s:%d---\n"</span>, ipstr, ntohs(raddr.sin_port));</span><br><span class="line">        <span class="comment">// 单字节传输不涉及到大端小端的存储情况</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Name = %s\n"</span>,rbuf.name);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Math = %d\n"</span>,ntohl(rbuf.math));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Chinese = %d\n"</span>,ntohl(rbuf.chinese));</span><br><span class="line">    }</span><br><span class="line">	<span class="comment">// 关闭套接字</span></span><br><span class="line">    close(sd);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行编译好的代码，然后，重启一个终端，使用命令<code>netstat -anu</code>来查看，其中，u代表的是udp。</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng socket]<span class="comment"># netstat -anu</span></span><br><span class="line">Active Internet connections (servers and established)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State      </span><br><span class="line">udp        0      0 0.0.0.0:1989            0.0.0.0:*                          </span><br><span class="line">udp        0      0 0.0.0.0:68              0.0.0.0:*                          </span><br><span class="line">udp        0      0 10.0.24.5:123           0.0.0.0:*                          </span><br><span class="line">udp        0      0 127.0.0.1:123           0.0.0.0:*                          </span><br><span class="line">udp6       0      0 fe80::5054:ff:fe2f::123 :::*                               </span><br><span class="line">udp6       0      0 ::1:123                 :::* </span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>snder.c</code>：这端可以不用向操作系统绑定端口，发送数据的时候由操作系统为我们分配可用的端口即可，当然如果想要自己绑定特定的端口也是可以的。</li>
</ul>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* snder.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"proto.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> sd;</span><br><span class="line">    <span class="comment">// 发送的结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_st</span> <span class="title">sbuf</span>;</span></span><br><span class="line">    <span class="comment">// 对端地址</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">raddr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>) {</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"Usage...\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 创建套接字</span></span><br><span class="line">    sd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sd &lt; <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">"socket()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="comment">//    bind();    // 主动端可省略绑定端口的步骤</span></span><br><span class="line">	<span class="built_in">memset</span>(&amp;sbuf, <span class="string">'\0'</span>, <span class="keyword">sizeof</span>(sbuf));</span><br><span class="line">    <span class="built_in">strcpy</span>(sbuf.name, <span class="string">"Alan"</span>);</span><br><span class="line">    sbuf.math = htonl(rand()%<span class="number">100</span>);</span><br><span class="line">    sbuf.chinese = htonl(rand()%<span class="number">100</span>);</span><br><span class="line">	<span class="comment">// 对端地址的配置</span></span><br><span class="line">    raddr.sin_family = AF_INET; <span class="comment">// 对端协议</span></span><br><span class="line">    raddr.sin_port = htons(atoi(RCVPORT)); <span class="comment">// 对端端口</span></span><br><span class="line">    inet_pton(AF_INET, argv[<span class="number">1</span>], &amp;raddr.sin_addr); <span class="comment">// 对端ip地址</span></span><br><span class="line">	<span class="comment">// 发送数据</span></span><br><span class="line">    <span class="keyword">if</span>(sendto(sd, &amp;sbuf, <span class="keyword">sizeof</span>(sbuf), <span class="number">0</span>, (<span class="keyword">void</span> *)&amp;raddr, <span class="keyword">sizeof</span>(raddr)) &lt; <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">"sendto()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"OK!"</span>);</span><br><span class="line">    close(sd);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>执行结果：</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng socket]<span class="comment"># ./snder 127.0.0.1</span></span><br><span class="line">OK!</span><br><span class="line"></span><br><span class="line">[root@HongyiZeng socket]<span class="comment"># ./rcver </span></span><br><span class="line">---MESSAGE FROM 127.0.0.1:46573---</span><br><span class="line">Name = Alan</span><br><span class="line">Math = 83</span><br><span class="line">Chinese = 86</span><br></pre></td></tr></tbody></table></figure>
<h5 id="②-动态报式套接字"><a href="#②-动态报式套接字" class="headerlink" title="② 动态报式套接字"></a>② 动态报式套接字</h5><p>传输的结构体中含有变长的数组。例如结构体中name数组的大小是不固定，此时可以使用<strong>变长结构体</strong>。</p>
<ul>
<li>变长结构体</li>
</ul>
<p>变长结构体是由gcc扩展的一种技术，它是指其最后一个成员的长度不固定（flexible array member，也叫柔性数组）。</p>
<p>使用范围：数据长度不固定，例如协议对接中有固定的头结构体，数据结构体不固定。</p>
<p>问题引出：项目中用到数据包的处理，但包的大小是不固定的，其长度由包头的2字节决定。比如如下的包头：</p>
<figure class="highlight plaintext"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">plaintext</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">88 0f 0a ob cd ef 23 00</span><br></pre></td></tr></tbody></table></figure>
<p> 长度由头2个字节<code>880f</code>决定，考虑字节序，转为<code>0f88</code>，转为10进制为<code>3976</code>个字节的包长度。</p>
<p>这个时候存储包的时候，一方面可以考虑设定包的大小固定：如4K=4*1024=4096个字节，因为最大包长不可能超过4k，但该方法的有缺陷，存在一种极端就是包最小仅含包头不含数据域，此时包为8个字节，浪费了4096-8 =4088个字节的存储空间。</p>
<p>另一方面考虑有没有一种方法能根据长度进行存储，或者说初始不分配长度，计算出了长度后再分配存储呢。而实际项目中正是通过包头计算出了包的整体大小的。</p>
<p>这就引出了变长结构体的概念。例如：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Var_Len_Struct</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="keyword">int</span> nsize;</span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 或者不指定大小 char buffer[];</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>那结构体是怎么实现可变长的呢？如上所示，请注意看结构体中的最后一个元素：一个没有元素的数组（柔性数组）。我们可以通过动态开辟一个比结构体大
的空间，然后让buffer去指向那些额外的空间，这样就可以实现可变长的结构体了。更为巧妙的是，我们甚至可以用nsize存储字符串buffer的长
度。</p>
<p>代码示例：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">packet_st</span> {</span></span><br><span class="line">	<span class="keyword">uint32_t</span> packetHead; <span class="comment">// 占4个字节</span></span><br><span class="line">	<span class="keyword">uint8_t</span> packetData[<span class="number">0</span>];</span><br><span class="line">}__attribute__((packed));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 结构体长度</span></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="comment">// 结构体指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">packet_st</span> *<span class="title">bufp</span>;</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"sizeof(packet_st) = %d\n"</span>, <span class="keyword">sizeof</span>(struct packet_st));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 要发送的数据</span></span><br><span class="line">    <span class="keyword">char</span> data[] = <span class="string">"123456"</span>;</span><br><span class="line">    <span class="comment">// 发送的结构体长度: 结构体定长 + 要发送数据的长度</span></span><br><span class="line">    size = <span class="keyword">sizeof</span>(struct packet_st) + <span class="built_in">strlen</span>(data);</span><br><span class="line">    <span class="comment">// 以长度申请动态内存</span></span><br><span class="line">    bufp = (struct packet_st*)<span class="built_in">malloc</span>(size);</span><br><span class="line">    <span class="comment">// 设置结构体成员</span></span><br><span class="line">    bufp-&gt;packetHead = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(bufp-&gt;packetData , data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送数据的操作</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"packetHead: %d\n"</span>, bufp-&gt;packetHead);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"packetData: %s\n"</span>, bufp-&gt;packetData);</span><br><span class="line">    <span class="built_in">free</span>(bufp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>执行结果：</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng socket]<span class="comment"># ./val_struct </span></span><br><span class="line">sizeof(packet_st) = 4</span><br><span class="line">packetHead: 1</span><br><span class="line">packetData: 123456</span><br></pre></td></tr></tbody></table></figure>
<p>可以看到，<code>packetData</code>在结构体中虽然定义长度为0，但仍然可以填充数据。</p>
<p>之前的代码修改如下：</p>
<ul>
<li><code>proto.h</code></li>
</ul>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* proto.h */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __PROTO_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __PROTO_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RCVPORT <span class="meta-string">"1989"</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NAMEMAX (512-8-8) <span class="comment">// 512为udp包推荐的字节数，8为udp的报头大小，8为结构体中固定长度的大小，即math和chinese</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 传输的变长结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_st</span> {</span></span><br><span class="line">    <span class="keyword">uint32_t</span> math;</span><br><span class="line">    <span class="keyword">uint32_t</span> chinese;</span><br><span class="line">    <span class="keyword">uint8_t</span> name[<span class="number">1</span>]; <span class="comment">// 1仅为占位符，数组定义一定要放在最后</span></span><br><span class="line">}__attribute__((packed));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>snder.c</code>：发送方发送的结构体大小和内容是动态的，根据用户的命令行参数来确定</li>
</ul>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* snder.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"proto.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> sd;</span><br><span class="line">    <span class="comment">// 结构体指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_st</span> *<span class="title">sbufp</span>;</span></span><br><span class="line">    <span class="comment">// 对端地址</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">raddr</span>;</span></span><br><span class="line">    <span class="comment">// 发送结构体的大小</span></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">	<span class="comment">// Usage: ./snder IP NAME</span></span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">3</span>) {</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"Usage...\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strlen</span>(argv[<span class="number">2</span>]) &gt; NAMEMAX) {</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Name is to long!"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    sd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sd &lt; <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">"socket()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 结构体定长和可变名字的长度</span></span><br><span class="line">    size = <span class="keyword">sizeof</span>(struct msg_st) + <span class="built_in">strlen</span>(argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="comment">// 申请动态内存</span></span><br><span class="line">	sbufp = (struct msg_st *)<span class="built_in">malloc</span>(size);</span><br><span class="line">    <span class="keyword">if</span>(sbufp == <span class="literal">NULL</span>) {</span><br><span class="line">        perror(<span class="string">"malloc()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">strcpy</span>(sbufp-&gt;name, argv[<span class="number">2</span>]);</span><br><span class="line">    sbufp-&gt;math = htonl(rand()%<span class="number">100</span>);</span><br><span class="line">    sbufp-&gt;chinese = htonl(rand()%<span class="number">100</span>);</span><br><span class="line">	<span class="comment">// 对端地址的配置</span></span><br><span class="line">    raddr.sin_family = AF_INET; <span class="comment">// 对端协议</span></span><br><span class="line">    raddr.sin_port = htons(atoi(RCVPORT)); <span class="comment">// 对端端口</span></span><br><span class="line">    inet_pton(AF_INET, argv[<span class="number">1</span>], &amp;raddr.sin_addr); <span class="comment">// 对端ip地址</span></span><br><span class="line">	<span class="comment">// 发送数据</span></span><br><span class="line">    <span class="keyword">if</span>(sendto(sd, sbufp, size, <span class="number">0</span>, (<span class="keyword">void</span> *)&amp;raddr, <span class="keyword">sizeof</span>(raddr)) &lt; <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">"sendto()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"OK!"</span>);</span><br><span class="line">    close(sd);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>rcver.c</code>：接收方不知道发送方发送的内容大小</li>
</ul>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* rcver.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"proto.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPSTRSIZE 64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    <span class="comment">// 套接字</span></span><br><span class="line">    <span class="keyword">int</span> sd;</span><br><span class="line">    <span class="comment">// laddr -- local address -- 本机地址</span></span><br><span class="line">    <span class="comment">// raddr -- remote address -- 对端地址</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">laddr</span>,<span class="title">raddr</span>;</span></span><br><span class="line">    <span class="comment">// 对端地址长度</span></span><br><span class="line">    <span class="keyword">socklen_t</span> raddr_len;</span><br><span class="line">    <span class="comment">// 结构体指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_st</span> *<span class="title">rbufp</span>;</span></span><br><span class="line">    <span class="comment">// 存储点分十进制字符串的数组</span></span><br><span class="line">    <span class="keyword">char</span> ipstr[IPSTRSIZE];</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    size = <span class="keyword">sizeof</span>(struct msg_st) + NAMEMAX - <span class="number">1</span>; <span class="comment">// 1是name的占位大小</span></span><br><span class="line">    rbufp = (struct msg_st*)<span class="built_in">malloc</span>(size);</span><br><span class="line">    </span><br><span class="line">    sd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span><span class="comment">/*IPPROTO_UDP*/</span>);</span><br><span class="line">    <span class="keyword">if</span>(sd &lt; <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">"socket()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    laddr.sin_family = AF_INET;</span><br><span class="line">    laddr.sin_port = htons(atoi(RCVPORT));</span><br><span class="line">    inet_pton(AF_INET, <span class="string">"0.0.0.0"</span>, &amp;laddr.sin_addr.s_addr);</span><br><span class="line">    <span class="keyword">if</span>(bind(sd, (struct sockaddr *)&amp;laddr, <span class="keyword">sizeof</span>(laddr)) &lt; <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">"bind()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    raddr_len = <span class="keyword">sizeof</span>(raddr);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">if</span>(recvfrom(sd, rbufp, size, <span class="number">0</span>, (<span class="keyword">void</span> *)&amp;raddr, &amp;raddr_len) &lt; <span class="number">0</span>) {</span><br><span class="line">            perror(<span class="string">"recvfrom()"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        inet_ntop(AF_INET, &amp;raddr.sin_addr, ipstr, IPSTRSIZE);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"---MESSAGE FROM %s:%d---\n"</span>, ipstr, ntohs(raddr.sin_port));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Name = %s\n"</span>,rbufp-&gt;name);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Math = %d\n"</span>,ntohl(rbufp-&gt;math));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Chinese = %d\n"</span>,ntohl(rbufp-&gt;chinese));</span><br><span class="line">    }</span><br><span class="line">    close(sd);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>执行结果：</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng socket]<span class="comment"># ./snder 127.0.0.1 Mark</span></span><br><span class="line">OK!</span><br><span class="line"></span><br><span class="line">[root@HongyiZeng socket]<span class="comment"># ./rcver </span></span><br><span class="line">---MESSAGE FROM 127.0.0.1:52874---</span><br><span class="line">Name = Mark</span><br><span class="line">Math = 83</span><br><span class="line">Chinese = 86</span><br></pre></td></tr></tbody></table></figure>
<h5 id="③-广播"><a href="#③-广播" class="headerlink" title="③ 广播"></a>③ 广播</h5><p>在使用TCP/IP 协议的网络中，主机标识段host ID 为全1 的 IP 地址为广播地址。</p>
<p>广播数据有如下特点：</p>
<ul>
<li>TCP/IP协议栈中，传输层只有UDP可以广播，TCP没有广播的概念.</li>
<li>UDP广播不需要经过路由器转发，因为路由器不会转发广播数据；</li>
</ul>
<blockquote>
<p>代码示例</p>
</blockquote>
<ul>
<li><code>snder.c</code>：设置套接字，打开广播选项，并向广播地址<code>255.255.255.255</code>发送数据报</li>
</ul>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* snder.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"proto.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv)</span> </span>{</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> val = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 设置该套接字，打开广播</span></span><br><span class="line">    <span class="keyword">if</span>(setsockopt(sd, SOL_SOCKET, SO_BROADCAST, &amp;val, <span class="keyword">sizeof</span>(val)) &lt; <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">"setsockopt()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">"255.255.255.255"</span>, &amp;raddr.sin_addr); <span class="comment">// 对端ip地址</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>打印结果：</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng dgram]<span class="comment"># ./snder Mark</span></span><br><span class="line">OK!</span><br><span class="line">[root@HongyiZeng dgram]<span class="comment"># ./snder Mary</span></span><br><span class="line">OK!</span><br><span class="line"></span><br><span class="line">[root@HongyiZeng dgram]<span class="comment"># ./rcver </span></span><br><span class="line">---MESSAGE FROM 10.0.24.5:52621---</span><br><span class="line">Name = Mark</span><br><span class="line">Math = 83</span><br><span class="line">Chinese = 86</span><br><span class="line">---MESSAGE FROM 10.0.24.5:42769---</span><br><span class="line">Name = Mary</span><br><span class="line">Math = 83</span><br><span class="line">Chinese = 86</span><br></pre></td></tr></tbody></table></figure>
<h5 id="④-多播-组播"><a href="#④-多播-组播" class="headerlink" title="④ 多播/组播"></a>④ 多播/组播</h5><p>多播地址，也叫组播地址，组播报文的目的地址使用<code>D类IP地址</code>， D类地址不能出现在IP报文的源IP地址字段。组播地址可以分为四类：</p>
<ul>
<li>224.0.0.0～224.0.0.255为预留的组播地址（永久组地址），地址224.0.0.0保留不做分配，其它地址供路由协议使用；</li>
<li>224.0.1.0～224.0.1.255是公用组播地址，可以用于Internet；</li>
<li>224.0.2.0～238.255.255.255为用户可用的组播地址（临时组地址），全网范围内有效；</li>
<li>239.0.0.0～239.255.255.255为本地管理组播地址，仅在特定的本地范围内有效。</li>
</ul>
<blockquote>
<p>代码示例</p>
</blockquote>
<p>多播选项在IP协议中。相关数据结构和选项可以通过<code>man 7 ip</code>查看。</p>
<ul>
<li><code>proto.h</code>：设置一个约定的多播地址</li>
</ul>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MTGOURP <span class="meta-string">"224.2.2.2"</span> <span class="comment">// 约定的多播组ip</span></span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>snder.c</code>：创建多播组</li>
</ul>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"proto.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv)</span> </span>{</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建多播组选项IP_MULTICAST_IF需要传入的数据结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ip_mreqn</span> <span class="title">mreq</span>;</span></span><br><span class="line"></span><br><span class="line">    inet_pton(AF_INET, MTGOURP, &amp;mreq.imr_multiaddr); <span class="comment">// 多播地址</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">"0.0.0.0"</span>, &amp;mreq.imr_address); <span class="comment">// 自己的地址</span></span><br><span class="line">    mreq.imr_ifindex = if_nametoindex(<span class="string">"eth0"</span>); <span class="comment">// 网络设备的索引号</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置该套接字（协议为IP，即IPPROTO_IP），创建多播组</span></span><br><span class="line">    <span class="keyword">if</span>(setsockopt(sd, IPPROTO_IP, IP_MULTICAST_IF, &amp;mreq, <span class="keyword">sizeof</span>(mreq)) &lt; <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">"setsockopt()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    inet_pton(AF_INET, MTGOURP, &amp;raddr.sin_addr); <span class="comment">// 对端ip地址</span></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>其中，可以使用命令查看网络设备的索引号：</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip ad sh</span><br></pre></td></tr></tbody></table></figure>
<p><a href="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20230310152637363.png" data-fancybox="gallery" data-caption="image-20230310152637363" data-thumb="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20230310152637363.png"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20230310152637363.png" alt="image-20230310152637363"></a></p>
<p>可以通过下列函数来获取网络设备名的索引编号：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">if_nametoindex</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *ifname)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>rcver.v</code>：加入多播组</li>
</ul>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"proto.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPSTRSIZE 64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加入多播组选项IP_ADD_MEMBERSHIP需要传入的数据结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ip_mreqn</span> <span class="title">mreq</span>;</span></span><br><span class="line"></span><br><span class="line">    inet_pton(AF_INET, MTGOURP, &amp;mreq.imr_multiaddr); <span class="comment">// 多播地址</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">"0.0.0.0"</span>, &amp;mreq.imr_address); <span class="comment">// 自己的地址</span></span><br><span class="line">    mreq.imr_ifindex = if_nametoindex(<span class="string">"eth0"</span>); <span class="comment">// 网络设备的索引号</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置该套接字（协议为IP，即IPPROTO_IP），加入多播组</span></span><br><span class="line">    <span class="keyword">if</span>(setsockopt(sd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &amp;mreq, <span class="keyword">sizeof</span>(mreq)) &lt; <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">"setsockopt()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>执行结果：</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng mcast]<span class="comment"># ./snder Mark</span></span><br><span class="line">OK!</span><br><span class="line">[root@HongyiZeng mcast]<span class="comment"># ./snder Mike</span></span><br><span class="line">OK!</span><br><span class="line"></span><br><span class="line">[root@HongyiZeng mcast]<span class="comment"># ./rcver </span></span><br><span class="line">---MESSAGE FROM 10.0.24.5:51081---</span><br><span class="line">Name = Mark</span><br><span class="line">Math = 83</span><br><span class="line">Chinese = 86</span><br><span class="line">---MESSAGE FROM 10.0.24.5:53772---</span><br><span class="line">Name = Mike</span><br><span class="line">Math = 83</span><br><span class="line">Chinese = 86</span><br></pre></td></tr></tbody></table></figure>
<p>多播中有一个特殊的 ip 地址（<code>224.0.0.1</code>），它表示，所有支持多播的地址默认都存在这个组当中，并且无法离开。如果 snder 方向这个 ip 地址发送信息，就相当于向 <code>255.255.255.255</code> 上发消息。</p>
<h4 id="11-7-3-流式套接字示例"><a href="#11-7-3-流式套接字示例" class="headerlink" title="11.7.3 流式套接字示例"></a>11.7.3 流式套接字示例</h4><p>主动端和被动端的工作详见<code>11.3.4小节</code></p>
<h5 id="①-基本实现-1"><a href="#①-基本实现-1" class="headerlink" title="① 基本实现"></a>① 基本实现</h5><ul>
<li><code>proto.h</code></li>
</ul>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __PROTO_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __PROTO_H__</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> SERVERPORT <span class="meta-string">"1989"</span> <span class="comment">// 服务器端口</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> FMT_STAMP <span class="meta-string">"%lld\r\n"</span> <span class="comment">// 格式化参数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>server.c</code></li>
</ul>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"proto.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPSTRSIZE 40</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFSIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">server_job</span><span class="params">(<span class="keyword">int</span> sd)</span> </span>{</span><br><span class="line">    <span class="keyword">char</span> buf[BUFSIZE];</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="comment">// 将格式化数据写入到buf中,返回写入的字符总数</span></span><br><span class="line">    len = <span class="built_in">sprintf</span>(buf, FMT_STAMP, (<span class="keyword">long</span> <span class="keyword">long</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">if</span>(send(sd, buf, len, <span class="number">0</span>) &lt; <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">"send()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> sd;</span><br><span class="line">    <span class="keyword">int</span> new_sd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">laddr</span>, <span class="title">raddr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> raddr_len;</span><br><span class="line">    <span class="keyword">char</span> ipstr[IPSTRSIZE];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 采用流式套接字SOCK_STREAM</span></span><br><span class="line">    sd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sd &lt; <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">"socket()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> val = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(setsockopt(sd, SOL_SOCKET, SO_REUSEADDR, &amp;val, <span class="keyword">sizeof</span>(val)) &lt; <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">"setsockopt()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    laddr.sin_family = AF_INET;</span><br><span class="line">    laddr.sin_port = htons(atoi(SERVERPORT));</span><br><span class="line">    inet_pton(AF_INET, <span class="string">"0.0.0.0"</span>, &amp;laddr.sin_addr.s_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定地址</span></span><br><span class="line">    <span class="keyword">if</span>(bind(sd, (struct sockaddr *)&amp;laddr, <span class="keyword">sizeof</span>(laddr)) &lt; <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">"bind()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听连接</span></span><br><span class="line">    <span class="keyword">if</span>(listen(sd, <span class="number">200</span>) &lt; <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">"listen"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    raddr_len = <span class="keyword">sizeof</span>(raddr);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">        <span class="comment">// 接收连接</span></span><br><span class="line">        new_sd = accept(sd, (<span class="keyword">void</span> *)&amp;raddr, &amp;raddr_len);</span><br><span class="line">        <span class="keyword">if</span>(new_sd &lt; <span class="number">0</span>) {</span><br><span class="line">            perror(<span class="string">"accept()"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        inet_ntop(AF_INET, &amp;raddr.sin_addr, ipstr, IPSTRSIZE);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Client:%s:%d\n"</span>, ipstr, ntohs(raddr.sin_port));</span><br><span class="line">        server_job(new_sd);</span><br><span class="line">        close(new_sd);</span><br><span class="line">    }</span><br><span class="line">    close(sd);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>使用命令，查看是否成功，<code>t</code>代表tcp</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -ant</span><br></pre></td></tr></tbody></table></figure>
<p><a href="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20230310173916206.png" data-fancybox="gallery" data-caption="image-20230310173916206" data-thumb="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20230310173916206.png"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20230310173916206.png" alt="image-20230310173916206"></a></p>
<p>发现已经处于监听状态。</p>
<p>可以使用<code>nc</code>命令来与服务器端建立连接：</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc 127.0.0.1 1989</span><br></pre></td></tr></tbody></table></figure>
<p>执行结果：</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng basic]<span class="comment"># nc 127.0.0.1 1989</span></span><br><span class="line">1678513397</span><br><span class="line"></span><br><span class="line">[root@HongyiZeng basic]<span class="comment"># ./server </span></span><br><span class="line">Client:127.0.0.1:36270</span><br></pre></td></tr></tbody></table></figure>
<p>现在实现客户端的功能，其实也就是nc命令的功能。这里采用将系统io转换为标准io的指针来实现，当然，也可以采用<code>recv</code>来实现。</p>
<ul>
<li><code>client.c</code></li>
</ul>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* client.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"proto.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>*argv[])</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> sd;</span><br><span class="line">    <span class="comment">// 对端地址</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">raddr</span>;</span></span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> stamp;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// Usage: ./client IP</span></span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>) {</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"Usage...\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    sd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sd &lt; <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">"socket()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对端地址的配置</span></span><br><span class="line">    raddr.sin_family = AF_INET; <span class="comment">// 对端协议</span></span><br><span class="line">    raddr.sin_port = htons(atoi(SERVERPORT)); <span class="comment">// 对端端口</span></span><br><span class="line">    inet_pton(AF_INET, argv[<span class="number">1</span>], &amp;raddr.sin_addr); <span class="comment">// 对端ip地址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 与对端建立连接</span></span><br><span class="line">    <span class="keyword">if</span>(connect(sd, (<span class="keyword">void</span> *)&amp;raddr, <span class="keyword">sizeof</span>(raddr)) &lt; <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">"connect()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">	<span class="comment">// 系统io转换为标准io</span></span><br><span class="line">    <span class="comment">// r+表示打开可读写的文件，且该文件必须存在</span></span><br><span class="line">    fp = fdopen(sd, <span class="string">"r+"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fp == <span class="literal">NULL</span>) {</span><br><span class="line">        perror(<span class="string">"dfopen()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 根据数据格式FMT_STAMP从fp中读取数据到stamp中</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fscanf</span>(fp, FMT_STAMP, &amp;stamp) &lt; <span class="number">1</span>) {</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Bad format!\n"</span>);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"stamp = %lld\n"</span>, stamp);</span><br><span class="line">    }</span><br><span class="line">	<span class="comment">// 按照标准io的方式关闭fp</span></span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><code>fdopen</code>的使用详见<code>3.5节</code>。</p>
<p>执行结果：</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng basic]<span class="comment"># ./client 127.0.0.1</span></span><br><span class="line">stamp = 1678514756</span><br><span class="line"></span><br><span class="line">[root@HongyiZeng basic]<span class="comment"># ./server </span></span><br><span class="line">Client:127.0.0.1:37820</span><br></pre></td></tr></tbody></table></figure>
<h5 id="②-并发实现"><a href="#②-并发实现" class="headerlink" title="② 并发实现"></a>② 并发实现</h5><p>服务器端<code>fork</code>出子进程来执行任务。</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"proto.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPSTRSIZE 40</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFSIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">server_job</span><span class="params">(<span class="keyword">int</span> sd)</span> </span>{</span><br><span class="line">    <span class="comment">// 假设很耗时</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">        <span class="comment">// 父进程只接收连接</span></span><br><span class="line">        new_sd = accept(sd, (<span class="keyword">void</span> *)&amp;raddr, &amp;raddr_len);</span><br><span class="line">        <span class="keyword">if</span>(new_sd &lt; <span class="number">0</span>) {</span><br><span class="line">            perror(<span class="string">"accept()"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        pid = fork(); <span class="comment">// 创建子进程</span></span><br><span class="line">        <span class="keyword">if</span>(pid) {</span><br><span class="line">            perror(<span class="string">"fork()"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>) { <span class="comment">// 子进程</span></span><br><span class="line">            close(sd); <span class="comment">// 关闭不需要的主套接字（监听套接字）</span></span><br><span class="line">            inet_ntop(AF_INET, &amp;raddr.sin_addr, ipstr, IPSTRSIZE);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Client:%s:%d\n"</span>, ipstr, ntohs(raddr.sin_port));</span><br><span class="line">            server_job(new_sd); <span class="comment">// 干活</span></span><br><span class="line">            close(new_sd);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">// 干完活后退出</span></span><br><span class="line">        }</span><br><span class="line">        close(new_sd); <span class="comment">// 关闭不需要的副套接字</span></span><br><span class="line">    }</span><br><span class="line">    close(sd);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这里需要关闭不需要的套接字，详见<code>6.2.1</code>节的<code>父子进程之间的文件共享</code>。</p>
<p>原因在于 fork 
执行之后，所有已经打开的套接字都被增加了引用计数，在其中任一个进程中都无法彻底关闭套接字，只能减少该文件的引用计数。因此，在 fork 
之后，每个进程立即关闭不再需要的文件是个好的策略，否则很容易导致大量没有正确关闭的文件一直占用系统资源的现象。</p>
<h5 id="③-请求http服务实现"><a href="#③-请求http服务实现" class="headerlink" title="③ 请求http服务实现"></a>③ 请求http服务实现</h5><p>客户端功能：使用http的GET请求，下载服务器端上的一张图片。</p>
<ul>
<li>服务器端准备</li>
</ul>
<p>使用nginx作为web服务器，根目录一般位于<code>usr/local/nginx</code>。</p>
<p>将静态文件，例如<code>test.jpg</code>放置于根目录下的<code>img</code>文件夹（自己新建）中。</p>
<p>编写<code>usr/local/nginx/conf/nginx.conf</code>配置文件，在server块中新增映射关系，以响应请求静态文件的请求：</p>
<figure class="highlight nginx"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">nginx</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> <span class="regexp">~* \.(gif|jpg|jpeg|png)$</span>  { <span class="comment"># url为gif|jpg|jpeg|png结尾时</span></span><br><span class="line">    <span class="attribute">root</span> img; <span class="comment"># 以root方式设置资源路径</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>例如，访问<code>http://xxx.xxx.xxx.xxx:80/test.jpg</code>时，匹配到末尾的jpg，nginx将其替换为<code>/img/test.jpg</code>。</p>
<ul>
<li><code>client.c</code></li>
</ul>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* client.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// #include "proto.h"</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFSIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>*argv[])</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> sd;</span><br><span class="line">    <span class="comment">// 对端地址</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">raddr</span>;</span></span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">char</span> rbuf[BUFSIZE];</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// Usage: ./client IP</span></span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>) {</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"Usage...\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    sd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sd &lt; <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">"socket()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对端地址的配置</span></span><br><span class="line">    raddr.sin_family = AF_INET; <span class="comment">// 对端协议</span></span><br><span class="line">    raddr.sin_port = htons(<span class="number">80</span>); <span class="comment">// 对端端口，http一般为80端口</span></span><br><span class="line">    inet_pton(AF_INET, argv[<span class="number">1</span>], &amp;raddr.sin_addr); <span class="comment">// 对端ip地址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 与对端建立连接</span></span><br><span class="line">    <span class="keyword">if</span>(connect(sd, (<span class="keyword">void</span> *)&amp;raddr, <span class="keyword">sizeof</span>(raddr)) &lt; <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">"connect()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    fp = fdopen(sd, <span class="string">"r+"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fp == <span class="literal">NULL</span>) {</span><br><span class="line">        perror(<span class="string">"dfopen()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 发送http请求</span></span><br><span class="line">    <span class="built_in">fprintf</span>(fp, <span class="string">"GET /test.jpg\r\n\r\n"</span>);</span><br><span class="line">    <span class="comment">// 发送后刷新流</span></span><br><span class="line">    fflush(fp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">        len = fread(rbuf, <span class="number">1</span>, BUFSIZE, fp);</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 打印在标准终端</span></span><br><span class="line">        fwrite(rbuf, <span class="number">1</span>, len, <span class="built_in">stdout</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>执行结果：</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng basic]<span class="comment"># ./webdl XXX.XXX.XXX.XXX &gt; /tmp/out</span></span><br></pre></td></tr></tbody></table></figure>
<p><a href="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20230311160634337.png" data-fancybox="gallery" data-caption="image-20230311160634337" data-thumb="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20230311160634337.png"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20230311160634337.png" alt="image-20230311160634337"></a></p>
<h5 id="④-静态进程池套接字实现"><a href="#④-静态进程池套接字实现" class="headerlink" title="④ 静态进程池套接字实现"></a>④ 静态进程池套接字实现</h5><p>静态进程池：父进程先fork出4个子进程，再由子进程来接收连接，处理任务。</p>
<p>代码实现：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"proto.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPSTRSIZE 40</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFSIZE 1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROCNUM 4 <span class="comment">// 静态进程池中进程的个数</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">server_job</span><span class="params">(<span class="keyword">int</span> sd)</span> </span>{</span><br><span class="line">    <span class="keyword">char</span> buf[BUFSIZE];</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="comment">// 将格式化数据写入到buf中,返回写入的字符总数</span></span><br><span class="line">    len = <span class="built_in">sprintf</span>(buf, FMT_STAMP, (<span class="keyword">long</span> <span class="keyword">long</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">if</span>(send(sd, buf, len, <span class="number">0</span>) &lt; <span class="number">0</span>) { </span><br><span class="line">        perror(<span class="string">"send()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">server_loop</span><span class="params">(<span class="keyword">int</span> sd)</span> </span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">raddr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> raddr_len;</span><br><span class="line">    <span class="keyword">int</span> new_sd;</span><br><span class="line">    <span class="keyword">char</span> ipstr[IPSTRSIZE];</span><br><span class="line"></span><br><span class="line">    raddr_len = <span class="keyword">sizeof</span>(raddr);</span><br><span class="line">    <span class="comment">// 不断接收连接，处理任务</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">        <span class="comment">// 接收连接</span></span><br><span class="line">        new_sd = accept(sd, (<span class="keyword">void</span> *)&amp;raddr, &amp;raddr_len);</span><br><span class="line">        <span class="keyword">if</span>(new_sd &lt; <span class="number">0</span>) {</span><br><span class="line">            perror(<span class="string">"accept()"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        inet_ntop(AF_INET, &amp;raddr.sin_addr, ipstr, IPSTRSIZE);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[%d]Client:%s:%d\n"</span>, getpid(), ipstr, ntohs(raddr.sin_port));</span><br><span class="line">        <span class="comment">// 处理任务</span></span><br><span class="line">        server_job(new_sd);</span><br><span class="line">        close(new_sd);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// nerver reach</span></span><br><span class="line">    close(sd);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> sd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">laddr</span>;</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 采用流式套接字SOCK_STREAM</span></span><br><span class="line">    sd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sd &lt; <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">"socket()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> val = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(setsockopt(sd, SOL_SOCKET, SO_REUSEADDR, &amp;val, <span class="keyword">sizeof</span>(val)) &lt; <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">"setsockopt()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    laddr.sin_family = AF_INET;</span><br><span class="line">    laddr.sin_port = htons(atoi(SERVERPORT));</span><br><span class="line">    inet_pton(AF_INET, <span class="string">"0.0.0.0"</span>, &amp;laddr.sin_addr.s_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定地址</span></span><br><span class="line">    <span class="keyword">if</span>(bind(sd, (struct sockaddr *)&amp;laddr, <span class="keyword">sizeof</span>(laddr)) &lt; <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">"bind()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听连接</span></span><br><span class="line">    <span class="keyword">if</span>(listen(sd, <span class="number">200</span>) &lt; <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">"listen"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; PROCNUM; i++) {</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid &lt; <span class="number">0</span>) {</span><br><span class="line">            perror(<span class="string">"fork()"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>) { <span class="comment">// 子进程</span></span><br><span class="line">            server_loop(sd);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; PROCNUM; i++) {</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    close(sd);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>执行结果：</p>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng pool_static]<span class="comment"># ./server </span></span><br><span class="line">[2828]Client:127.0.0.1:59268</span><br><span class="line">[2829]Client:127.0.0.1:59270</span><br><span class="line">[2830]Client:127.0.0.1:59272</span><br><span class="line">[2831]Client:127.0.0.1:59276</span><br><span class="line">[2828]Client:127.0.0.1:59278</span><br><span class="line">[2829]Client:127.0.0.1:59280</span><br><span class="line">[2830]Client:127.0.0.1:59282</span><br><span class="line">[2831]Client:127.0.0.1:59284</span><br><span class="line">[2828]Client:127.0.0.1:59286</span><br><span class="line">[2829]Client:127.0.0.1:59290</span><br><span class="line">[2830]Client:127.0.0.1:59292</span><br></pre></td></tr></tbody></table></figure>
<h5 id="⑤-动态进程池套接字实现"><a href="#⑤-动态进程池套接字实现" class="headerlink" title="⑤ 动态进程池套接字实现"></a>⑤ 动态进程池套接字实现</h5><p>描
述：进程池主进程最大可fork出20个进程来接收连接和处理任务，当一些进程完成任务后，阻塞等待连接，成为空闲进程，此时主进程需要控制空闲进程（一
直阻塞等待连接）的数量，最大可空闲10个，否则多余的空闲进程由主进程杀死，减少服务器端的资源消耗，最小可空闲5个，小于5个时由主线程fork出，
这一目的是提高服务器的并发性，在有多个客户端突发连接时能够得到有效处理。</p>
<p>主进程任务：初始化进程池，并控制进程池中进程的数量。</p>
<p>子进程任务：不断接收客户端连接，处理任务。</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"proto.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MINSPARESERVER 5 <span class="comment">// 最小可空闲进程</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSPARESERVER 10 <span class="comment">// 最大可空闲进程</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXCLIENT 20 <span class="comment">// 进程资源总量</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIG_NOTIFY SIGUSR2 <span class="comment">// 自定义的信号</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPSTRSIZE 40</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LINEBUFSIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 进程状态的枚举</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> {</span></span><br><span class="line">    STATE_IDLE = <span class="number">0</span>, <span class="comment">// 进程空闲</span></span><br><span class="line">    STATE_BUSY <span class="comment">// 进程忙碌</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 包含进程信息的结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">server_st</span> {</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid; <span class="comment">// 进程pid</span></span><br><span class="line">    <span class="keyword">int</span> state; <span class="comment">// 进程状态</span></span><br><span class="line">    <span class="comment">// int reuse;</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">server_st</span> *<span class="title">serverpool</span>;</span> <span class="comment">// server_st数组的首地址</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> idle_count = <span class="number">0</span>, busy_count = <span class="number">0</span>; <span class="comment">// 计数器</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> sd; <span class="comment">// 监听套接字</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号SIG_NOTIFY的处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">usr2_hanlder</span><span class="params">(<span class="keyword">int</span> s)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子进程的任务：等待连接，处理任务</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">server_job</span><span class="params">(<span class="keyword">int</span> pos)</span> </span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">raddr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> raddr_len;</span><br><span class="line">    <span class="keyword">char</span> ipstr[IPSTRSIZE];</span><br><span class="line">    <span class="keyword">time_t</span> stamp;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">char</span> linebuf[LINEBUFSIZE];</span><br><span class="line">    <span class="comment">// 父进程pid</span></span><br><span class="line">    <span class="keyword">int</span> ppid = getppid();</span><br><span class="line">    <span class="keyword">int</span> client_sd; <span class="comment">// 副套接字</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">        <span class="comment">// 没有连接前，状态为空闲</span></span><br><span class="line">        serverpool[pos].state = STATE_IDLE;</span><br><span class="line">        <span class="comment">// 状态改变时，通知主进程：作用是打断主进程中的阻塞</span></span><br><span class="line">        kill(ppid, SIG_NOTIFY);</span><br><span class="line">        <span class="comment">// 阻塞等待连接</span></span><br><span class="line">        client_sd = accept(sd, (<span class="keyword">void</span> *)&amp;raddr, &amp;raddr_len);</span><br><span class="line">        <span class="keyword">if</span>(client_sd &lt; <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">if</span>(errno != EINTR || errno != EAGAIN) {</span><br><span class="line">                perror(<span class="string">"accept()"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 完成连接，设置状态为忙碌</span></span><br><span class="line">        serverpool[pos].state = STATE_BUSY;</span><br><span class="line">        <span class="comment">// 状态改变时，通知主进程</span></span><br><span class="line">        kill(ppid, SIG_NOTIFY);</span><br><span class="line">        inet_ntop(AF_INET, &amp;raddr.sin_addr, ipstr, IPSTRSIZE);</span><br><span class="line">        <span class="comment">// printf("[%d]Client:%s:%d\n", getpid(), ipstr, ntohs(raddr.sin_port));</span></span><br><span class="line">        stamp = time(<span class="literal">NULL</span>);</span><br><span class="line">        len = <span class="built_in">snprintf</span>(linebuf, LINEBUFSIZE, FMT_STAMP, stamp);</span><br><span class="line">        send(client_sd, linebuf, len , <span class="number">0</span>);</span><br><span class="line">        sleep(<span class="number">5</span>);</span><br><span class="line">        close(client_sd);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个子进程</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add_1_server</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> slot;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">if</span>(idle_count + busy_count &gt;= MAXCLIENT) { <span class="comment">// 空闲和忙碌的进程数大于进程资源总量，则不添加</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 遍历serverpool数组，查找到可用的位置slot</span></span><br><span class="line">    <span class="keyword">for</span>(slot = <span class="number">0</span>; slot &lt; MAXCLIENT; slot++) { </span><br><span class="line">        <span class="keyword">if</span>(serverpool[slot].pid == <span class="number">-1</span>) {  </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    serverpool[slot].state = STATE_IDLE; <span class="comment">// 新增进程的状态设置为空闲</span></span><br><span class="line">    pid = fork(); <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">"fork()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>) { <span class="comment">// 子进程</span></span><br><span class="line">        server_job(slot); <span class="comment">// 干活</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    } <span class="keyword">else</span> { <span class="comment">// 父进程</span></span><br><span class="line">        serverpool[slot].pid = pid; <span class="comment">// 父进程负责设置子进程的pid</span></span><br><span class="line">        idle_count ++; <span class="comment">// 增加一个空闲资源</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">del_1_server</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">if</span>(idle_count == <span class="number">0</span>) { <span class="comment">// 空闲进程数为0，则不删除</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 遍历serverpool数组，查找到可释放的空闲进程</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; MAXCLIENT; i++) { </span><br><span class="line">        <span class="comment">// 找到一个已分配的空闲进程</span></span><br><span class="line">        <span class="keyword">if</span>(serverpool[i].pid != <span class="number">-1</span> &amp;&amp; serverpool[i].state == STATE_IDLE) { </span><br><span class="line">            <span class="comment">// 主线程发送终止信号</span></span><br><span class="line">            kill(serverpool[i].pid, SIGTERM);</span><br><span class="line">            serverpool[i].pid = <span class="number">-1</span>;</span><br><span class="line">            idle_count--;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历进程池</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">scan_pool</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> busy = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> idle = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; MAXCLIENT; i++) {</span><br><span class="line">        <span class="keyword">if</span>(serverpool[i].pid == <span class="number">-1</span>) { <span class="comment">// 进程不存在</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// kill(pid, 0)用于检测pid是否存在，存在返回0，不存在返回-1</span></span><br><span class="line">        <span class="keyword">if</span>(kill(serverpool[i].pid, <span class="number">0</span>) == <span class="number">-1</span>) {</span><br><span class="line">            serverpool[i].pid = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(serverpool[i].state == STATE_IDLE) {</span><br><span class="line">            idle++;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span>(serverpool[i].state == STATE_BUSY) {</span><br><span class="line">            busy++;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Unknown state.\n"</span>);</span><br><span class="line">            <span class="built_in">abort</span>();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    idle_count = idle;</span><br><span class="line">    busy_count = busy;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主进程</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>, <span class="title">osa</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">laddr</span>;</span></span><br><span class="line">    <span class="keyword">sigset_t</span> <span class="built_in">set</span>, oset;</span><br><span class="line">    <span class="keyword">int</span> val = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 避免子进程成为僵尸进程，详见6.2.1节</span></span><br><span class="line">    sa.sa_handler = SIG_DFL;</span><br><span class="line">    sigemptyset(&amp;sa.sa_mask);</span><br><span class="line">    sa.sa_flags = SA_NOCLDWAIT;</span><br><span class="line">    sigaction(SIGCHLD, &amp;sa, &amp;osa);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 自定义信号SIG_NOTIFY的处理</span></span><br><span class="line">    sa.sa_handler = usr2_hanlder;</span><br><span class="line">    sigemptyset(&amp;sa.sa_mask);</span><br><span class="line">    sa.sa_flags = <span class="number">0</span>;</span><br><span class="line">    sigaction(SIG_NOTIFY, &amp;sa, &amp;osa);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 对SIG_NOTIFY信号进行屏蔽</span></span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>, SIG_NOTIFY);</span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;<span class="built_in">set</span>, &amp;oset);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为serverpool申请20个空间</span></span><br><span class="line">    serverpool = mmap(<span class="literal">NULL</span>, <span class="keyword">sizeof</span>(struct server_st) * MAXCLIENT, </span><br><span class="line">        PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(serverpool == MAP_FAILED) {</span><br><span class="line">        perror(<span class="string">"mmap()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 赋初值，表示当前没有产生(fork)进程</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; MAXCLIENT; i++) {</span><br><span class="line">        serverpool[i].pid = <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 创建套接字</span></span><br><span class="line">    sd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sd &lt; <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">"socket()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置套接字选项</span></span><br><span class="line">    <span class="keyword">if</span>(setsockopt(sd, SOL_SOCKET, SO_REUSEADDR, &amp;val, <span class="keyword">sizeof</span>(val)) &lt; <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">"setsockopt()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 本机地址配置</span></span><br><span class="line">    laddr.sin_family = AF_INET;</span><br><span class="line">    laddr.sin_port = htons(atoi(SERVERPORT));</span><br><span class="line">    inet_pton(AF_INET, <span class="string">"0.0.0.0"</span>, &amp;laddr.sin_addr.s_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定地址</span></span><br><span class="line">    <span class="keyword">if</span>(bind(sd, (struct sockaddr *)&amp;laddr, <span class="keyword">sizeof</span>(laddr)) &lt; <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">"bind()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听连接</span></span><br><span class="line">    <span class="keyword">if</span>(listen(sd, <span class="number">200</span>) &lt; <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">"listen"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 初始化进程池，使其空闲进程数等于MINSPARESERVER</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span> ;i &lt; MINSPARESERVER; i++) {</span><br><span class="line">        add_1_server();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">        <span class="comment">// 信号驱动：当子进程的状态发生变化时，向父进程发送信号，父进程相应作出一些动作</span></span><br><span class="line">        <span class="comment">// 解除对SIG_NOTIFY的屏蔽，并且阻塞在这里，直到子进程调用kill，发送给主进程一个信号来打断此阻塞，使得主进程能够向下执行</span></span><br><span class="line">        sigsuspend(&amp;oset);</span><br><span class="line">        <span class="comment">// 扫描进程池</span></span><br><span class="line">        scan_pool();</span><br><span class="line">        <span class="comment">// 控制进程池：多退少补</span></span><br><span class="line">        <span class="keyword">if</span>(idle_count &gt; MAXSPARESERVER) {</span><br><span class="line">            <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; (idle_count - MAXSPARESERVER); i++) {</span><br><span class="line">                del_1_server();</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span>(idle_count &lt; MINSPARESERVER) {</span><br><span class="line">            <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; (MINSPARESERVER - idle_count); i++) {</span><br><span class="line">                add_1_server();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 输出进程池的状态</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; MAXCLIENT; i++) {</span><br><span class="line">            <span class="keyword">if</span>(serverpool[i].pid == <span class="number">-1</span>) { <span class="comment">// 尚未分配的进程</span></span><br><span class="line">                <span class="built_in">putchar</span>(<span class="string">'x'</span>);</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span>(serverpool[i].state == STATE_IDLE) { <span class="comment">// 空闲进程</span></span><br><span class="line">                <span class="built_in">putchar</span>(<span class="string">'.'</span>);</span><br><span class="line">            } <span class="keyword">else</span> { <span class="comment">// 忙碌进程</span></span><br><span class="line">                <span class="built_in">putchar</span>(<span class="string">'$'</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">    }</span><br><span class="line">	<span class="comment">// 恢复信号屏蔽字</span></span><br><span class="line">    sigprocmask(SIG_SETMASK, &amp;oset, <span class="literal">NULL</span>);</span><br><span class="line">    close(sd);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码测试：</p>
<ul>
<li>启动服务器端：</li>
</ul>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng pool_dynamic]<span class="comment"># ./server </span></span><br><span class="line">.....xxxxxxxxxxxxxxx</span><br><span class="line">.....xxxxxxxxxxxxxxx</span><br><span class="line">.....xxxxxxxxxxxxxxx</span><br><span class="line">.....xxxxxxxxxxxxxxx</span><br><span class="line">.....xxxxxxxxxxxxxxx</span><br></pre></td></tr></tbody></table></figure>
<p>这里出现5行的原因为初始化5个子进程。可以看到前五个为启用的进程，且是空闲的，后15个尚未启用。</p>
<p>服务器运行到：fork出子进程</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span> ;i &lt; MINSPARESERVER; i++) {</span><br><span class="line">    add_1_server();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>子进程运行到：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">    serverpool[pos].state = STATE_IDLE;</span><br><span class="line">    kill(ppid, SIG_NOTIFY); <span class="comment">// 设置主进程的SIG_NOTIFY的pending位为1</span></span><br><span class="line">    client_sd = accept(sd, (<span class="keyword">void</span> *)&amp;raddr, &amp;raddr_len); <span class="comment">// 阻塞等待连接</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>由于主进程对<code>SIG_NOTIFY</code>进行了屏蔽（<code>mask=1</code>），因此不会响应，但是<code>pending</code>位为1。</p>
<p>主进程创建完个子进程后，进入循环：</p>
<figure class="highlight c"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">c</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) { </span><br><span class="line">    sigsuspend(&amp;oset); <span class="comment">// 解除对SIG_NOTIFY的屏蔽，同时阻塞</span></span><br><span class="line">    scan_pool();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>主进程阻塞在<code>sigsuspend</code>，然后依次响应之前的信号（存疑）。</p>
<ul>
<li>发送一个请求，服务器端打印的结果：</li>
</ul>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">..$...xxxxxxxxxxxxxx</span><br><span class="line">..$...xxxxxxxxxxxxxx</span><br><span class="line">......xxxxxxxxxxxxxx</span><br></pre></td></tr></tbody></table></figure>
<p>某个子进程接收到连接，改变状态为忙碌，同时发送信号给父进程。父进程响应，扫描进程池后发现空闲进程数量为（<code>5-1=4&lt;5</code>），因此再次fork一个子进程（注意fork出的子进程阻塞在<code>accept</code>之前也要向父进程发送信号）。父进程打印第一二行，分别是对原子进程和新子进程的信号响应；5s后，原子进程完成任务，将状态修改为空闲，并向父进程发送信号，父进程再打印出第三行。此时空闲进程有6个了。</p>
<ul>
<li>连续发送请求：</li>
</ul>
<figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">true</span>; <span class="keyword">do</span> (./client 127.0.0.1 &amp;); sleep 1; <span class="keyword">done</span> <span class="comment"># 每1s发送一个请求，每个请求的处理时间为5s</span></span><br></pre></td></tr></tbody></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://kisugitakumi.net/">Kisugi Takumi</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://kisugitakumi.net/">https://kisugitakumi.net</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">此文章版权归Kisugi Takumi所有，如有转载，请注明来自原作者</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="https://kisugitakumi.net/tags/Linux/">Linux</a><a class="post-meta__tags" href="https://kisugitakumi.net/tags/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/">Linux系统编程</a></div><div class="post_share"><div class="social-share" data-image="/img/linux.png" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20%E6%9D%A5%E7%94%9F%E6%8B%93%E5%B7%B1%20%E3%82%AA%E3%83%95%E3%82%A3%E3%82%B7%E3%83%A3%E3%83%AB%E3%82%B5%E3%82%A4%E3%83%88_files/share.min.css" media="print" onload="this.media='all'"><script src="Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20%E6%9D%A5%E7%94%9F%E6%8B%93%E5%B7%B1%20%E3%82%AA%E3%83%95%E3%82%A3%E3%82%B7%E3%83%A3%E3%83%AB%E3%82%B5%E3%82%A4%E3%83%88_files/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="https://kisugitakumi.net/2022/11/21/Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89/"><img class="prev-cover" src="Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20%E6%9D%A5%E7%94%9F%E6%8B%93%E5%B7%B1%20%E3%82%AA%E3%83%95%E3%82%A3%E3%82%B7%E3%83%A3%E3%83%AB%E3%82%B5%E3%82%A4%E3%83%88_files/leetcode.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Leetcode刷题笔记（简单）</div></div></a></div><div class="next-post pull-right"><a href="https://kisugitakumi.net/2022/11/06/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%9F%BA%E7%A1%80/"><img class="next-cover" src="Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20%E6%9D%A5%E7%94%9F%E6%8B%93%E5%B7%B1%20%E3%82%AA%E3%83%95%E3%82%A3%E3%82%B7%E3%83%A3%E3%83%AB%E3%82%B5%E3%82%A4%E3%83%88_files/51danpianji.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">51单片机基础</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="https://kisugitakumi.net/2023/04/08/Shell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="Shell脚本编程学习笔记"><img class="cover" src="Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20%E6%9D%A5%E7%94%9F%E6%8B%93%E5%B7%B1%20%E3%82%AA%E3%83%95%E3%82%A3%E3%82%B7%E3%83%A3%E3%83%AB%E3%82%B5%E3%82%A4%E3%83%88_files/shell.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-08</div><div class="title">Shell脚本编程学习笔记</div></div></a></div><div><a href="https://kisugitakumi.net/2023/03/22/Unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="Unix网络编程学习笔记"><img class="cover" src="Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20%E6%9D%A5%E7%94%9F%E6%8B%93%E5%B7%B1%20%E3%82%AA%E3%83%95%E3%82%A3%E3%82%B7%E3%83%A3%E3%83%AB%E3%82%B5%E3%82%A4%E3%83%88_files/socket.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-22</div><div class="title">Unix网络编程学习笔记</div></div></a></div><div><a href="https://kisugitakumi.net/2023/04/30/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="Linux内核学习笔记"><img class="cover" src="Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20%E6%9D%A5%E7%94%9F%E6%8B%93%E5%B7%B1%20%E3%82%AA%E3%83%95%E3%82%A3%E3%82%B7%E3%83%A3%E3%83%AB%E3%82%B5%E3%82%A4%E3%83%88_files/linux.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-30</div><div class="title">Linux内核学习笔记</div></div></a></div><div><a href="https://kisugitakumi.net/2023/04/12/%E8%BD%BB%E9%87%8F%E7%BA%A7Web%E6%9C%8D%E5%8A%A1%E5%99%A8/" title="轻量级Web服务器学习笔记"><img class="cover" src="Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20%E6%9D%A5%E7%94%9F%E6%8B%93%E5%B7%B1%20%E3%82%AA%E3%83%95%E3%82%A3%E3%82%B7%E3%83%A3%E3%83%AB%E3%82%B5%E3%82%A4%E3%83%88_files/lightweightweb.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-12</div><div class="title">轻量级Web服务器学习笔记</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage">12</span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0"><span class="toc-text">Linux系统编程学习笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%89%8D%E8%A8%80"><span class="toc-text">1 前言</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E7%8E%AF%E5%A2%83"><span class="toc-text">1.1 环境</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-GCC"><span class="toc-text">1.2 GCC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-make"><span class="toc-text">1.3 make</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-makefile"><span class="toc-text">1.4 makefile</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-1-%E4%BD%BF%E7%94%A8gcc%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-text">1.4.1 使用gcc的例子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-2-%E8%AF%AD%E6%B3%95%E8%A7%84%E5%88%99"><span class="toc-text">1.4.2 语法规则</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-POSIX"><span class="toc-text">1.5 POSIX</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-1-%E7%AE%80%E4%BB%8B"><span class="toc-text">1.5.1 简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-2-%E5%8E%86%E5%8F%B2"><span class="toc-text">1.5.2 历史</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-3-%E5%8F%AF%E7%A7%BB%E6%A4%8D%E6%80%A7"><span class="toc-text">1.5.3 可移植性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%92%8C%E5%BA%93%E5%87%BD%E6%95%B0"><span class="toc-text">① 系统调用和库函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A1-%E5%8C%BA%E5%88%AB"><span class="toc-text">② 区别</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-4-%E5%AE%9E%E4%BE%8B"><span class="toc-text">1.5.4 实例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%A0%87%E5%87%86IO"><span class="toc-text">2 标准IO</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E7%AE%80%E4%BB%8B"><span class="toc-text">2.1 简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-fopen"><span class="toc-text">2.2 fopen</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-fclose"><span class="toc-text">2.3 fclose</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-fgetc%E5%92%8Cfputc"><span class="toc-text">2.4 fgetc和fputc</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-fgets%E5%92%8Cfputs"><span class="toc-text">2.5 fgets和fputs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-fread%E5%92%8Cfwrite"><span class="toc-text">2.6 fread和fwrite</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-printf%E5%92%8Cscanf"><span class="toc-text">2.7 printf和scanf</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-8-fseek%E5%92%8Cftell"><span class="toc-text">2.8 fseek和ftell</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-9-fflush"><span class="toc-text">2.9 fflush</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-10-getline"><span class="toc-text">2.10 getline</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-11-%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6"><span class="toc-text">2.11 临时文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8IO"><span class="toc-text">3 系统调用IO</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E7%AE%80%E4%BB%8B"><span class="toc-text">3.1 简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-text">3.2 文件描述符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link active" href="#3-2-1-FILE%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">3.2.1 FILE结构体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2-%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-text">3.2.2 文件描述符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-open%E5%92%8Cclose"><span class="toc-text">3.3 open和close</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1-%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90"><span class="toc-text">3.3.1 文件权限</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0-rwx"><span class="toc-text">① rwx</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A1-%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7"><span class="toc-text">② 文件属性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A2-umask"><span class="toc-text">③ umask</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-open"><span class="toc-text">3.3.2 open</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-3-close"><span class="toc-text">3.3.3 close</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-read%EF%BC%8Cwrite%E5%92%8Clseek"><span class="toc-text">3.4 read，write和lseek</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-IO%E6%95%88%E7%8E%87"><span class="toc-text">3.5 IO效率</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-C%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E5%B8%83%E5%B1%80"><span class="toc-text">3.6 C程序的内存空间布局</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-1-%E5%8A%A8%E6%80%81%E5%8C%BA"><span class="toc-text">3.6.1 动态区</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0-%E6%A0%88%E5%8C%BA"><span class="toc-text">① 栈区</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A1-%E5%A0%86%E5%8C%BA"><span class="toc-text">② 堆区</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-2-%E9%9D%99%E6%80%81%E5%8C%BA"><span class="toc-text">3.6.2 静态区</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0-%E6%95%B0%E6%8D%AE%E5%8C%BA"><span class="toc-text">① 数据区</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A1-%E5%B8%B8%E9%87%8F%E5%8C%BA"><span class="toc-text">② 常量区</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A2-%E4%BB%A3%E7%A0%81%E5%8C%BA"><span class="toc-text">③ 代码区</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-3-%E6%A0%88%E7%9A%84%E5%9C%B0%E5%9D%80%E6%B5%8B%E8%AF%95"><span class="toc-text">3.6.3 栈的地址测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-4-%E5%A0%86%E7%9A%84%E5%9C%B0%E5%9D%80%E6%B5%8B%E8%AF%95"><span class="toc-text">3.6.4 堆的地址测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-5-%E9%9D%99%E6%80%81%E5%8C%BA%E6%BC%94%E7%A4%BA"><span class="toc-text">3.6.5 静态区演示</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB"><span class="toc-text">3.7 文件共享</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-8-dup%E5%92%8Cdup2"><span class="toc-text">3.8 dup和dup2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-9-fcntl%E5%92%8Cioctl"><span class="toc-text">3.9 fcntl和ioctl</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-10-dev-fd%E7%9B%AE%E5%BD%95"><span class="toc-text">3.10 /dev/fd目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-11-%E8%A1%A5%E5%85%85%EF%BC%9A%E5%87%A0%E4%B8%AA%E6%96%87%E4%BB%B6%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">3.11 补充：几个文件的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-11-1-%E7%94%A8%E6%88%B7%E5%8F%98%E9%87%8F"><span class="toc-text">3.11.1 用户变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-11-2-%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-text">3.11.2 全局变量</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-text">4 文件系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-Linux%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E6%9E%84%E6%88%90"><span class="toc-text">4.1 Linux文件目录构成</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-1-%E6%A6%82%E8%BF%B0"><span class="toc-text">4.1.1 概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-2-etc-passwd"><span class="toc-text">4.1.2 /etc/passwd</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-3-etc-group"><span class="toc-text">4.1.3 /etc/group</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-4-usr-include"><span class="toc-text">4.1.4 /usr/include</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A5%E5%85%85-inode"><span class="toc-text">补充 inode</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0-%E7%AE%80%E4%BB%8B"><span class="toc-text">① 简介</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A1-inode%E7%9A%84%E4%BF%A1%E6%81%AF"><span class="toc-text">② inode的信息</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A2-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4"><span class="toc-text">③ 相关命令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A3-%E7%A1%AC%E9%93%BE%E6%8E%A5"><span class="toc-text">④ 硬链接</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A4-%E7%AC%A6%E5%8F%B7%E9%93%BE%E6%8E%A5"><span class="toc-text">⑤ 符号链接</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95"><span class="toc-text">4.2 文件和目录</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-1-stat"><span class="toc-text">4.2.1 stat</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2-%E7%A9%BA%E6%B4%9E%E6%96%87%E4%BB%B6"><span class="toc-text">4.2.2 空洞文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-3-st-mode"><span class="toc-text">4.2.3 st_mode</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0-%E7%AE%80%E4%BB%8B-1"><span class="toc-text">① 简介</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A1-%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90"><span class="toc-text">② 实例分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A2-%E5%AE%8F"><span class="toc-text">③ 宏</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A3-%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-text">④ 代码示例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-4-%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90"><span class="toc-text">4.2.4 文件权限</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0-umask"><span class="toc-text">① umask</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A1-chmod"><span class="toc-text">② chmod</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A2-%E7%B2%98%E4%BD%8F%E4%BD%8D"><span class="toc-text">③ 粘住位</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-5-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-text">4.2.5 文件系统</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0-%E7%A3%81%E7%9B%98%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-text">① 磁盘的结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A1-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B"><span class="toc-text">② 文件系统简介</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A2-%E9%93%BE%E6%8E%A5"><span class="toc-text">③ 链接</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-6-%E6%9D%82%E9%A1%B9"><span class="toc-text">4.2.6 杂项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-7-glob"><span class="toc-text">4.2.7 glob</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E8%BF%9B%E7%A8%8B%E7%8E%AF%E5%A2%83"><span class="toc-text">5 进程环境</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-main%E5%87%BD%E6%95%B0"><span class="toc-text">5.1 main函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E8%BF%9B%E7%A8%8B%E7%BB%88%E6%AD%A2"><span class="toc-text">5.2 进程终止</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-1-%E7%BB%88%E6%AD%A2%E6%96%B9%E5%BC%8F"><span class="toc-text">5.2.1 终止方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-2-main%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-text">5.2.2 main函数的返回值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-3-%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0atexit"><span class="toc-text">5.2.3 钩子函数atexit</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-4-exit%E5%92%8C-exit"><span class="toc-text">5.2.4 exit和_exit</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0"><span class="toc-text">5.3 命令行参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="toc-text">5.4 环境变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-1-%E7%AE%80%E4%BB%8B"><span class="toc-text">5.4.1 简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-2-%E6%9F%A5%E7%9C%8B%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="toc-text">5.4.2 查看环境变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-3-%E8%AE%BE%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="toc-text">5.4.3 设置环境变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-4-%E7%8E%AF%E5%A2%83%E8%A1%A8"><span class="toc-text">5.4.4 环境表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-%E5%85%B1%E4%BA%AB%E5%BA%93"><span class="toc-text">5.5 共享库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-%E5%87%BD%E6%95%B0%E9%97%B4%E8%B7%B3%E8%BD%AC"><span class="toc-text">5.6 函数间跳转</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-7-%E8%B5%84%E6%BA%90%E7%9A%84%E8%8E%B7%E5%8F%96%E5%92%8C%E6%8E%A7%E5%88%B6"><span class="toc-text">5.7 资源的获取和控制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-text">6 进程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E8%BF%9B%E7%A8%8B%E6%A0%87%E8%AF%86"><span class="toc-text">6.1 进程标识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E8%BF%9B%E7%A8%8B%E4%BA%A7%E7%94%9F"><span class="toc-text">6.2 进程产生</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-1-fork"><span class="toc-text">6.2.1 fork</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-2-vfork"><span class="toc-text">6.2.2 vfork</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-wait%E5%92%8Cwaitpid"><span class="toc-text">6.3 wait和waitpid</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-exec%E5%87%BD%E6%95%B0%E6%97%8F"><span class="toc-text">6.4 exec函数族</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-1-%E7%AE%80%E4%BB%8B"><span class="toc-text">6.4.1 简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-2-%E4%BD%BF%E7%94%A8"><span class="toc-text">6.4.2 使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-shell%E5%A4%96%E9%83%A8%E5%91%BD%E4%BB%A4%E5%AE%9E%E7%8E%B0"><span class="toc-text">6.5 shell外部命令实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E5%92%8C%E7%BB%84%E6%9D%83%E9%99%90"><span class="toc-text">6.6 用户权限和组权限</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-1-UID%E5%92%8CGID"><span class="toc-text">6.6.1 UID和GID</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-2-SUID%E5%92%8CSGID"><span class="toc-text">6.6.2 SUID和SGID</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-3-%E7%9B%B8%E5%85%B3%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-text">6.6.3 相关系统调用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-7-%E8%A7%A3%E9%87%8A%E5%99%A8%E6%96%87%E4%BB%B6"><span class="toc-text">6.7 解释器文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-8-system%E5%87%BD%E6%95%B0"><span class="toc-text">6.8 system函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-9-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B"><span class="toc-text">6.9 守护进程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-9-1-%E7%AE%80%E4%BB%8B"><span class="toc-text">6.9.1 简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-9-2-%E8%BF%9B%E7%A8%8B%E7%BB%84%E4%B8%8E%E4%BC%9A%E8%AF%9D"><span class="toc-text">6.9.2 进程组与会话</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-9-3-%E5%88%9B%E5%BB%BA%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B"><span class="toc-text">6.9.3 创建守护进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-9-4-%E5%90%8E%E5%8F%B0%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%AE%88%E6%8A%A4%E5%8C%96"><span class="toc-text">6.9.4 后台进程和守护化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-10-%E7%B3%BB%E7%BB%9F%E6%97%A5%E5%BF%97"><span class="toc-text">6.10 系统日志</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E4%BF%A1%E5%8F%B7"><span class="toc-text">7 信号</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E5%89%8D%E7%BD%AE%E6%A6%82%E5%BF%B5"><span class="toc-text">7.1 前置概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E4%BF%A1%E5%8F%B7%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">7.1 信号的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-signal%E5%87%BD%E6%95%B0"><span class="toc-text">7.3 signal函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-%E4%B8%8D%E5%8F%AF%E9%9D%A0%E7%9A%84%E4%BF%A1%E5%8F%B7"><span class="toc-text">7.4 不可靠的信号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-%E5%8F%AF%E9%87%8D%E5%85%A5%E5%87%BD%E6%95%B0"><span class="toc-text">7.5 可重入函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-6-%E4%BF%A1%E5%8F%B7%E7%9A%84%E5%93%8D%E5%BA%94%E8%BF%87%E7%A8%8B"><span class="toc-text">7.6 信号的响应过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-7-%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E2%85%A0"><span class="toc-text">7.7 常用函数Ⅰ</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-7-1-kill"><span class="toc-text">7.7.1 kill</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-7-2-raise"><span class="toc-text">7.7.2 raise</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-7-3-alarm"><span class="toc-text">7.7.3 alarm</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-7-4-pause"><span class="toc-text">7.7.4 pause</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-7-5-%E6%BC%8F%E6%A1%B6"><span class="toc-text">7.7.5 漏桶</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-7-6-%E4%BB%A4%E7%89%8C%E6%A1%B6"><span class="toc-text">7.7.6 令牌桶</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-8-%E4%BF%A1%E5%8F%B7%E9%9B%86"><span class="toc-text">7.8 信号集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-9-sigprocmask%E5%87%BD%E6%95%B0"><span class="toc-text">7.9 sigprocmask函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-10-sigpending%E5%87%BD%E6%95%B0"><span class="toc-text">7.10 sigpending函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-11-%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E2%85%A1"><span class="toc-text">7.11 常用函数Ⅱ</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-11-1-sigsuspend%E5%87%BD%E6%95%B0"><span class="toc-text">7.11.1 sigsuspend函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-11-2-sigaction%E5%87%BD%E6%95%B0"><span class="toc-text">7.11.2 sigaction函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-12-%E5%AE%9E%E6%97%B6%E4%BF%A1%E5%8F%B7"><span class="toc-text">7.12 实时信号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-13-%E4%BF%A1%E5%8F%B7%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">7.13 信号实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-13-1-%E6%9C%AA%E5%86%B3%E5%92%8C%E9%98%BB%E5%A1%9E%E4%BF%A1%E5%8F%B7%E9%9B%86"><span class="toc-text">7.13.1 未决和阻塞信号集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-13-2-%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D"><span class="toc-text">7.13.2 原理介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0-%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">① 信号处理相关的数据结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A1-%E5%8F%91%E9%80%81%E4%BF%A1%E5%8F%B7"><span class="toc-text">② 发送信号</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E7%BA%BF%E7%A8%8B"><span class="toc-text">8 线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5"><span class="toc-text">8.1 线程概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-1-POSIX%E7%BA%BF%E7%A8%8B%E6%8E%A5%E5%8F%A3"><span class="toc-text">8.1.1 POSIX线程接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-2-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="toc-text">8.1.2 进程和线程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0-%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97"><span class="toc-text">① 进程控制块</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A1-%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB%E5%92%8C%E7%A7%81%E6%9C%89%E5%86%85%E5%AE%B9"><span class="toc-text">② 线程共享和私有内容</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-%E7%BA%BF%E7%A8%8B%E6%A0%87%E8%AF%86"><span class="toc-text">8.2 线程标识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA"><span class="toc-text">8.3 线程创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-%E7%BA%BF%E7%A8%8B%E7%BB%88%E6%AD%A2"><span class="toc-text">8.4 线程终止</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-1-%E7%BB%88%E6%AD%A2%E6%96%B9%E5%BC%8F"><span class="toc-text">8.4.1 终止方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-2-%E6%A0%88%E7%9A%84%E6%B8%85%E7%90%86"><span class="toc-text">8.4.2 栈的清理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-3-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8F%96%E6%B6%88"><span class="toc-text">8.4.3 线程的取消</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-5-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-text">8.5 线程同步</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-5-1-%E6%A6%82%E5%BF%B5%E5%92%8C%E4%BE%8B%E5%AD%90"><span class="toc-text">8.5.1 概念和例子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-5-2-%E4%BA%92%E6%96%A5%E9%87%8F"><span class="toc-text">8.5.2 互斥量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-5-3-%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">8.5.3 线程池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-5-4-%E7%BA%BF%E7%A8%8B%E4%BB%A4%E7%89%8C%E6%A1%B6"><span class="toc-text">8.5.4 线程令牌桶</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-5-5-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="toc-text">8.5.5 条件变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-5-6-%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-text">8.5.6 信号量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-6-%E7%BA%BF%E7%A8%8B%E5%B1%9E%E6%80%A7"><span class="toc-text">8.6 线程属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-7-%E5%90%8C%E6%AD%A5%E5%B1%9E%E6%80%A7"><span class="toc-text">8.7 同步属性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-7-1-%E4%BA%92%E6%96%A5%E9%87%8F%E5%B1%9E%E6%80%A7"><span class="toc-text">8.7.1 互斥量属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-7-2-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E5%B1%9E%E6%80%A7"><span class="toc-text">8.7.2 条件变量属性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-8-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8IO"><span class="toc-text">8.8 线程安全IO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-9-%E7%BA%BF%E7%A8%8B%E5%92%8C%E4%BF%A1%E5%8F%B7"><span class="toc-text">8.9 线程和信号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-10-%E7%BA%BF%E7%A8%8B%E4%B8%8Efork"><span class="toc-text">8.10 线程与fork</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E9%AB%98%E7%BA%A7IO"><span class="toc-text">9 高级IO</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-0-IO%E8%BF%87%E7%A8%8B"><span class="toc-text">9.0 IO过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-BIO%E5%92%8CNIO"><span class="toc-text">9.1 BIO和NIO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA"><span class="toc-text">9.2 有限状态机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-linux%E7%BB%88%E7%AB%AF"><span class="toc-text">9.3 linux终端</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-3-1-%E7%BB%88%E7%AB%AF%EF%BC%8C%E6%8E%A7%E5%88%B6%E5%8F%B0%E5%92%8Ctty"><span class="toc-text">9.3.1 终端，控制台和tty</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-3-2-%E6%8E%A7%E5%88%B6%E5%8F%B0"><span class="toc-text">9.3.2 控制台</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0-%E7%B3%BB%E7%BB%9F%E6%8E%A7%E5%88%B6%E5%8F%B0"><span class="toc-text">① 系统控制台</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A1-%E5%BD%93%E5%89%8D%E6%8E%A7%E5%88%B6%E5%8F%B0"><span class="toc-text">② 当前控制台</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A2-%E8%99%9A%E6%8B%9F%E6%8E%A7%E5%88%B6%E5%8F%B0"><span class="toc-text">③ 虚拟控制台</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-3-3-%E4%BC%AA%E7%BB%88%E7%AB%AF"><span class="toc-text">9.3.3 伪终端</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-3-4-%E4%B8%B2%E5%8F%A3%E7%BB%88%E7%AB%AF"><span class="toc-text">9.3.4 串口终端</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-4-IO%E5%A4%9A%E8%B7%AF%E8%BD%AC%E6%8E%A5"><span class="toc-text">9.4 IO多路转接</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-4-1-select"><span class="toc-text">9.4.1 select</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-4-2-poll"><span class="toc-text">9.4.2 poll</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-4-3-epoll"><span class="toc-text">9.4.3 epoll</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-5-%E5%85%B6%E5%AE%83IO%E5%87%BD%E6%95%B0"><span class="toc-text">9.5 其它IO函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-6-%E5%AD%98%E5%82%A8%E6%98%A0%E5%B0%84IO"><span class="toc-text">9.6 存储映射IO</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="toc-text">10 进程间通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-%E7%AE%A1%E9%81%93"><span class="toc-text">10.1 管道</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-1-1-%E5%8C%BF%E5%90%8D%E7%AE%A1%E9%81%93"><span class="toc-text">10.1.1 匿名管道</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-1-2-%E5%91%BD%E5%90%8D%E7%AE%A1%E9%81%93"><span class="toc-text">10.1.2 命名管道</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-XSI-IPC"><span class="toc-text">10.2 XSI IPC</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-2-1-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4"><span class="toc-text">10.2.1 相关命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-2-2-%E6%A0%87%E8%AF%86%E7%AC%A6%E5%92%8C%E9%94%AE"><span class="toc-text">10.2.2 标识符和键</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-2-3-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-text">10.2.3 消息队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-2-4-%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-text">10.2.4 信号量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-2-5-%E5%85%B1%E4%BA%AB%E5%AD%98%E5%82%A8"><span class="toc-text">10.2.5 共享存储</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E7%BD%91%E7%BB%9C%E5%A5%97%E6%8E%A5%E5%AD%97"><span class="toc-text">11 网络套接字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-1-%E5%BC%95%E8%A8%80"><span class="toc-text">11.1 引言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-%E5%A5%97%E6%8E%A5%E5%AD%97%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-text">11.2 套接字描述符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-3-%E5%88%B6%E5%AE%9A%E5%8D%8F%E8%AE%AE"><span class="toc-text">11.3 制定协议</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11-3-1-%E5%AD%97%E8%8A%82%E5%BA%8F"><span class="toc-text">11.3.1 字节序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-3-2-%E5%AF%B9%E9%BD%90"><span class="toc-text">11.3.2 对齐</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-3-3-%E7%B1%BB%E5%9E%8B%E9%95%BF%E5%BA%A6%E9%97%AE%E9%A2%98"><span class="toc-text">11.3.3 类型长度问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-3-4-%E4%B8%BB%E5%8A%A8%E7%AB%AF%E5%92%8C%E8%A2%AB%E5%8A%A8%E7%AB%AF"><span class="toc-text">11.3.4 主动端和被动端</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-4-%E5%AF%BB%E5%9D%80"><span class="toc-text">11.4 寻址</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11-4-1-%E5%9C%B0%E5%9D%80%E6%A0%BC%E5%BC%8F"><span class="toc-text">11.4.1 地址格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-4-2-%E5%A5%97%E6%8E%A5%E5%AD%97%E4%B8%8E%E5%9C%B0%E5%9D%80%E5%85%B3%E8%81%94"><span class="toc-text">11.4.2 套接字与地址关联</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-5-%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5"><span class="toc-text">11.5 建立连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-6-%E5%A5%97%E6%8E%A5%E5%AD%97%E9%80%89%E9%A1%B9"><span class="toc-text">11.6 套接字选项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-7-%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93"><span class="toc-text">11.7 数据传输</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11-7-1-%E5%8F%91%E9%80%81%E5%92%8C%E6%8E%A5%E6%94%B6"><span class="toc-text">11.7.1 发送和接收</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-7-2-%E6%8A%A5%E5%BC%8F%E5%A5%97%E6%8E%A5%E5%AD%97%E7%A4%BA%E4%BE%8B"><span class="toc-text">11.7.2 报式套接字示例</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0-%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0"><span class="toc-text">① 基本实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A1-%E5%8A%A8%E6%80%81%E6%8A%A5%E5%BC%8F%E5%A5%97%E6%8E%A5%E5%AD%97"><span class="toc-text">② 动态报式套接字</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A2-%E5%B9%BF%E6%92%AD"><span class="toc-text">③ 广播</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A3-%E5%A4%9A%E6%92%AD-%E7%BB%84%E6%92%AD"><span class="toc-text">④ 多播/组播</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-7-3-%E6%B5%81%E5%BC%8F%E5%A5%97%E6%8E%A5%E5%AD%97%E7%A4%BA%E4%BE%8B"><span class="toc-text">11.7.3 流式套接字示例</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0-%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0-1"><span class="toc-text">① 基本实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A1-%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0"><span class="toc-text">② 并发实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A2-%E8%AF%B7%E6%B1%82http%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0"><span class="toc-text">③ 请求http服务实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A3-%E9%9D%99%E6%80%81%E8%BF%9B%E7%A8%8B%E6%B1%A0%E5%A5%97%E6%8E%A5%E5%AD%97%E5%AE%9E%E7%8E%B0"><span class="toc-text">④ 静态进程池套接字实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A4-%E5%8A%A8%E6%80%81%E8%BF%9B%E7%A8%8B%E6%B1%A0%E5%A5%97%E6%8E%A5%E5%AD%97%E5%AE%9E%E7%8E%B0"><span class="toc-text">⑤ 动态进程池套接字实现</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background: linear-gradient(20deg, #0062be, #925696, #cc426e, #fb0347)"><div id="footer-wrap"><div class="copyright">©2021 - 2023 By Kisugi Takumi</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">欢迎来到我的个人博客!</div></div></footer></div><div id="rightside" style="opacity: 0.8; transform: translateX(-58px);"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20%E6%9D%A5%E7%94%9F%E6%8B%93%E5%B7%B1%20%E3%82%AA%E3%83%95%E3%82%A3%E3%82%B7%E3%83%A3%E3%83%AB%E3%82%B5%E3%82%A4%E3%83%88_files/utils.js"></script><script src="Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20%E6%9D%A5%E7%94%9F%E6%8B%93%E5%B7%B1%20%E3%82%AA%E3%83%95%E3%82%A3%E3%82%B7%E3%83%A3%E3%83%AB%E3%82%B5%E3%82%A4%E3%83%88_files/main.js"></script><script src="Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20%E6%9D%A5%E7%94%9F%E6%8B%93%E5%B7%B1%20%E3%82%AA%E3%83%95%E3%82%A3%E3%82%B7%E3%83%A3%E3%83%AB%E3%82%B5%E3%82%A4%E3%83%88_files/fancybox.umd.js"></script><script src="Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20%E6%9D%A5%E7%94%9F%E6%8B%93%E5%B7%B1%20%E3%82%AA%E3%83%95%E3%82%A3%E3%82%B7%E3%83%A3%E3%83%AB%E3%82%B5%E3%82%A4%E3%83%88_files/lazyload.iife.min.js"></script><script src="Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20%E6%9D%A5%E7%94%9F%E6%8B%93%E5%B7%B1%20%E3%82%AA%E3%83%95%E3%82%A3%E3%82%B7%E3%83%A3%E3%83%AB%E3%82%B5%E3%82%A4%E3%83%88_files/snackbar.min.js"></script><script src="Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20%E6%9D%A5%E7%94%9F%E6%8B%93%E5%B7%B1%20%E3%82%AA%E3%83%95%E3%82%A3%E3%82%B7%E3%83%A3%E3%83%AB%E3%82%B5%E3%82%A4%E3%83%88_files/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20%E6%9D%A5%E7%94%9F%E6%8B%93%E5%B7%B1%20%E3%82%AA%E3%83%95%E3%82%A3%E3%82%B7%E3%83%A3%E3%83%AB%E3%82%B5%E3%82%A4%E3%83%88_files/canvas-fluttering-ribbon.min.js"></script><script id="click-heart" src="Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20%E6%9D%A5%E7%94%9F%E6%8B%93%E5%B7%B1%20%E3%82%AA%E3%83%95%E3%82%A3%E3%82%B7%E3%83%A3%E3%83%AB%E3%82%B5%E3%82%A4%E3%83%88_files/click-heart.min.js" async="async" mobile="false"></script><script async="" data-pjax="" src="Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20%E6%9D%A5%E7%94%9F%E6%8B%93%E5%B7%B1%20%E3%82%AA%E3%83%95%E3%82%A3%E3%82%B7%E3%83%A3%E3%83%AB%E3%82%B5%E3%82%A4%E3%83%88_files/busuanzi.pure.mini.js"></script></div></body></html>